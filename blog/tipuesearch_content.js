var tipuesearch = {"pages":[{"title":"About","text":"mde.tw 課程倉儲: https://github.com/mdecycu/mdecycu.github.io 內容管理: https://mde.tw/ 課程投影片: https://mde.tw/reveal 課程網誌: https://mde.tw/blog","tags":"misc","url":"./pages/about/"},{"title":"2023 Spring 第三週","text":"2023 Spring 課程開始第三週, 這個學期起, 開課論述與先前大同小異, 但是執行內容將會有很大的不同. Stud 與 Stud2 虛擬主機 stud.cycu.org 是 2022 Fall 用來建構多人網際內容管理系統的虛擬主機, 由於刪除用戶資料過於繁瑣, 於是選擇重新建立 stud2.cycu.org. 而建構一台大約兩百多人使用的虛擬主機, 需要下列執行環境: 多人環境下的 Python3 環境, 可以順利執行動態 cmsimde 網際內容管理系統 https 的代理伺服器 (stunnel) 與連外的網站數位簽章建置 (letsencrypt) 建立多人帳號所需的準備工作 (使用 newusers 指令) 將所配置的多人帳號資訊, 逐一透過郵件進行通知 (Gmail) 除了先前採 waitress 執行 Flask 網站, 當網站內容變更後 (通常因為 git pull), 需要再利用 hupper -m 執行 server.py, 才能 auto reload 協同產品設計 pj1 希望透過 Python remote API 建立一個 browser based 跨網路的機器人足球遊戲, 採 CoppeliaSim 建立. 其中需要在 remoteApiConnections.txt 設定場景主機預定開啟的 ports, 以便讓各 client 能夠經由主機 IPv4 位址 (IPv6 尚無法運作) 中的特定 port 傳送 API 指令. 且各 client 可以由場景主機所啟動的 Visualization Streaming 串流同時觀看運動場景 (內建在 23020 埠號播放). 2023 年 Spring 開始導入 zmqRemoteAPI, 先前的 legacy Python 程式將會隨著新版 CoppeliaSim 的內容架構而逐步退場. Solid Edge 與 Femap 2021 年起 Siemens 開始釋出 Community 版本的 Solid Edge, 允許非營利單位可以免費使用. 同時也提供永久免費的 Femap 讓教育單位使用. 針對這兩項工具的新教育版使用授權, 全球各級學校終於可以更有彈性使用專業的 CAD/E 套件. Proxy and DNS Servers 固定的幾台 Proxy servers 必須定時對系統以及服務更新, 其中包括 3, 4, 42, 53, 69: sudo apt update sudo apt upgrade sudo apt autoremove sudo /etc/init.d/squid restart sudo service bind9 restart for Windows Server connected from Mac RDT need to setup under the admin connect session. 3 and 4 on 209 and 6 (eng) on 0811-2-0-cd02 Excel 計算平均 =INT(SUM(IF(B2=\"缺席\",0, B2),IF(C2=\"缺席\",0,C2),IF(D2=\"缺席\",0,D2),IF(E2=\"缺席\",0,E2),IF(F2=\"缺席\",0,F2))/5) Nginx 伺服下的 public_html sudo_user@cad2:~#sudo vi /etc/nginx/sites-available/default # 設定讓各用戶的 public_html 目錄可以作為 nginx 伺服網頁目錄 server { ..... ..... location ~ &#94;/~(.+?)(/.*)?$ { alias /home/$1/public_html$2; index index.html index.htm; autoindex on; } # 設定完成後必須重新啟動 nginx sudo_user@cad2:~# systemctl restart nginx Exam_dot_cycu https 數位簽章更新, 每 90 天必須更新一次 renew certificate (更新數位簽章) stop nginx service (必須先關閉 nginx 伺服器) on administrator command window (cmd 在管理者模式下啟動) execute (執行下列指令) certbot certonly --standalone","tags":"cd2023","url":"./2023_spring_w3.html"},{"title":"2022 Fall 課程總結","text":"2022 Fall 課程進入最後兩週, 將要讓每一位學員上台簡報各自的網站與倉儲. Repository 透過 Github Classroom 建立各學員的課程倉儲, 可以讓開課教師省下許多設定, 而利用 Repository 中的 Pages 設定, 各學員可以利用網站展示個人的課程作業與學習心得, 同時若再納入 Reveal.js 就能直接在線上進行課程心得簡報. cmsimde 的 Reveal 簡報系統位於 reveal 目錄中, 是一組超文件檔案, 可以利用 config 目錄中的 reveal.leo 進行管理. 在 Reveal.js 簡報中執行 Brython 程式的範例, 請參考 https://mde.tw/content/Revealjs.html . Git 學習教材 https://github.com/doggy8088/Learn-Git-in-30-days/tree/master/zh-tw https://backlog.com/git-tutorial/tw/ https://learngitbranching.js.org/ Brython 程式學習 Brython 環境建置? 導入所需程式庫, 啟動 Brython, 開始編寫 Brython 程式. Brython 網際程式編輯器如何建置? i.e. https://mde.tw/content/Python.html 這一頁是如何建立的? Brython 讀取 Gist 中的檔案與程式檔案後, 如何將字串轉為可用的程式內容? 試著了解 https://stackoverflow.com/questions/15197673/using-pythons-eval-vs-ast-literal-eval 中的說明. Brython 的 canvas 2D 繪圖應用. Brython 的 WebGL 3D 繪圖應用, 設法利用 Three.js 編寫 STL 零件檔案檢視程式. https://www.adobe.com/creativecloud/file-types/image/vector/stl-file.html CAD 套件 NX CAD 系統安裝與可攜程式建置. NX 零組件繪圖練習. NX 零組件轉入 CoppeliaSim, 加入感測器與 actuation system. 手足球系統建置, 將 NX 換為 Onshape 或 Solvespace. 自行編譯 Solvespace. 自行編寫 Python 或 Brython 程式分割 STL 組立件. 自行編譯 CoppeliaSim.","tags":"cad2022","url":"./2022_fall_courses_w17.html"},{"title":"2022 Fall 課程 w14","text":"2022 Fall 課程進入第十四週, 計算機程式從最基本的關鍵字列印、變數設定, 變數型別轉換到數值運算, 理論上各學員應該已經會編寫溫度轉換程式. 至於電腦輔助設計實習則除了操作 Solvespace 套件 C++ 原始碼的編譯與零組件繪圖、NX2027 與 Onshape 的參數式零組件的繪圖, 並且將零組件轉入 Coppeliasim 進行模擬. 計算機程式學習流程 // <![CDATA[ window.onload=function(){ brython({debug:1, pythonpath:['./../cmsimde/static/','/downloads/py/']}); } // ]]> 靜態網站中設置 Brython 程式環境的超文件: // <![CDATA[ window.onload=function(){ brython({debug:1, pythonpath:['./../cmsimde/static/','/downloads/py/']}); } // ]]> Brython 程式的關鍵字如下: import keyword from browser import document, html position = document[\"position\"] kw = keyword.kwlist for i in kw: position <= i position <= \", \" position <= html.BR() position <= \"共有 \" + str(len(kw)) + \" 個\" position <= html.BR() position <= html.BR() 列出關鍵字的原始碼: import keyword from browser import document, html position = document[\"position\"] kw = keyword.kwlist for i in kw: position <= i position <= \", \" position <= html.BR() position <= \"共有 \" + str(len(kw)) + \" 個\" position <= html.BR() 接下來只要將溫度轉換程式寫為 Function, 並且透過函式呼叫與 return 傳值, 就能讓程式編寫更加模組化. 之後假如能夠針對線上考試結果的 json 檔案解讀與 ast 模組中 literal_eval() 方法的運用, 就能將從 Gist 讀進的 list 或 dist 檔案內容, 轉為 Python 對應的資料結構. 從 w15 開始將要再導入 html5 中的 canvas 靜態與動態繪圖, 也希望下列以簡單物件導向方式編寫的線上考試成績處理程式, 可以作為初學者練習 OOP (Object Orient Programming)的範例. 至於, 有沒有 Python Programming 計算機程式課程相關的教課書? 有: [The Absolute Beginner's Guide to Python Programming] (在學校網段可以直接下載), w15-w18 可以將 Python 程式語法相關的內容設法整理在個人的課程網頁中. [The Absolute Beginner's Guide to Python Programming]: https://link.springer.com/book/10.1007/978-1-4842-8716-3 import ast from browser import document, html, bind brython_div = document[\"brython_div1\"] # create a button using html brython_div <= html.BUTTON(\"輸入 cname, url\", id=\"get_cname\") class quiz: def __init__(self, cname, url): self.cname = cname self.url = url # 定義一個函式, 以班級代號字串作為輸入, 可以傳回各班修課學員的學號數列 def get_stud(self): # 將課程的班級代號字串作為 dict 的 key, 而 2022 fall 的課程代號作為對應值 # 使用者可以利用班級代號從 courses dict 取出課程代號 courses = {\"1a\": \"0747\", \"1b\": \"0761\", \"2a\": \"0773\", \"2b\": \"0786\"} # 利用 c_name 從 courses 得到該學期的課程代號 c = courses[self.cname] # 利用課程代號從學校教務主機取的該班修課人員名單 curl = \"https://nfu.cycu.org/?semester=1111&courseno=\" + c + \"&column=True\" # 讀出各修課人員資料後, 以跳行符號切割, 得到的 data 為數列 data = open(curl).read().split(\"\\n\") # 因為最後一筆資料為空字串, 因此利用數列運算將其去除 stud = data[:-1] # get_stud() 函式最後將對應班級的修課人員學號以數列格式傳回 return stud def get_score(self): # 利用 open() 與 read() 讀取考試結果 JSON 檔案 json_data = open(self.url).read() # 利用 ast.literal_eval() 將字串 dict, 轉為程式可用的 dict 資料型別 big_dict = ast.literal_eval(json_data) # 從 big_dict 中, 取出 body 中的 testuser 欄位資料 data = big_dict[\"body\"][\"testuser\"] # 定義一個空 dict 資料變數, 隨後利用迴圈逐一將學號作為 key, 考試成績為 valude # 組成 quiz_dict 的資料內容, 以便之後可以用學號當作輸入, 取得該員考試成績 quiz_dict = {} for i in data: # data 資料中的 user_name 為考試學員的帳號, 也就是學號 stud_id = data[i][\"user_name\"] # data 資料中的 total_score 欄位為考試成績 # 因為考試成績為字串, 先轉為浮點數後, 再轉為整數 stud_score = int(float(data[i][\"total_score\"])) # 逐一以學號為 key, 考試成績為對應 value, 將資料放入 quiz_dict quiz_dict[stud_id] = stud_score # 取得各學員的考試成績 quiz_dict 後, 將資料傳回 return quiz_dict def gen_result(stud, score): abs_num = 0 for i in stud: brython_div <= i + \":\" try: s = score[i] except: s = \"缺考\" abs_num += 1 brython_div <= s brython_div <= html.BR() brython_div <= \"總計有 \" + str(abs_num) + \"人缺考\" @bind(document[\"get_cname\"], 'click') def get_cname(env): user_input = input(\"請輸入 cname,url\") cname_url = user_input.split(\",\") cname = cname_url[0] url = cname_url[1] data = quiz(cname, url) stud = data.get_stud() score = data.get_score() # 以 stud, score 為輸入, 列出展示用的超文件結果 gen_result(stud, score) 電腦輔助設計與實習 ----","tags":"cad2022","url":"./2022_fall_courses_w14.html"},{"title":"2022 Fall 課程 w12","text":"2022 Fall 課程進入第十二週, 決定將計算機程式與電腦輔助設計實習課程的考試題庫公佈, 並希望在下週看看各班小組能夠提出甚麼樣的考試題目來. 紙本或電子教科書 上過 KMOLab 開設的課程, 就知道在計算機程式、網際內容管理、電腦輔助設計與實習、協同產品設計與實習等課程的教學, 沒有紙本教材, 同時也不會有紙本的考試, 所有的教學內容都是數位資料, 學生必備的除了電腦以外, 就是耳機、隨身碟以及想要學習的心. 這裡 可以讀到有關紙本與數位教科書的優缺點比較, 儘管紙本教材可能永遠不會退流行, 但數位教材的好處將會逐步凌駕紙本類比教材, 也比較適合用來解決零碎且日趨複雜的各種專業難題. 近端、遠端與雲端 KMOLab 的課程集合 Python、C++、NX、Solvespace、Onshape、CoppeliaSim、Github 以及自行編寫的網際內容管理系統及零星的小程式片段, 課程的目的在探討機械設計工程師該如何面對近端、遠端與雲端工具? 這裡所謂的近端指的是工程師面前的數位裝置, 包括個人電腦、平板與手機, 而遠端則指個人電腦或伺服器, 但位於系上工作站室, 至於雲端則泛指 OneDrive、Github、Replilt 與 Onshape 等由大型公司提供的免費帳號, 可以將近端與遠端的內容同步至這些雲端主機. 近端的個人電腦間的工作環境, 除了依賴 Windows 10 或 11 外, 還包括 USB 隨身碟, 其中存放者 Python、C 與 C++ 的解譯或編譯套件, 也放入可攜的 NX、Solvespace 與 CoppeliaSim 等電腦輔助設計與模擬套件. NX 之所以能採可攜啟動, 主要原因是其源自 Unix 操作系統下各功能模組的獨立性, 只要在操作系統設定環境變數, 並且連網至認證主機後就可啟動, 而 Solvespace 與 CoppeliaSim 則因為都各自能跨操作系統平台, 所以在 Windows 環境可以只依賴隨身碟上的系統動態連結程式庫就可以運作. 只是當 KMOLab 課程希望讓所有學員都利用網路遊走在近端、遠端與雲端時, 已經無法分配給每一位學員連外的 IPv4 網路位址, 因此只能採 DHCP6 讓所有學員在電腦輔助設計室中的 PC 取得 IPv6 網路位址, 這就造成隨後所使用的各種網路協定, 都必須確認是否能夠在客戶端或遠端僅支援 IPv6 環境下, 與雲端上的伺服器穩定連線. 而許多人可能也弄不清楚, 就連中華電信的光世代也並非全時都提供用戶 IPv4 + IPv6 的網路環境, 幾乎每隔一陣子, 光世代在某些時段也會只給用戶 IPv4 的環境, 同時對於一般用戶也只核撥固定的 IPv4 網路位址, 而仍不提供一般用戶固定的 IPv6 網路位址. 因此希望在近端、遠端與雲端上平步設定防火牆連線的內容, 也必須設法因應. stud 伺服器 2022 課程中長出 stud 伺服器, 讓所有學員都能在其上執行動態的個人網站, 其實是為了取代雲端的 Replit 與 Heroku 服務, 但至截至目前為止 NX2027 無法在 Ubuntu 伺服器上安裝, stud 伺服器也就無法採網際模式直接與 NX2027 互動, 還是需要一台 Windows based 的伺服器能夠同時執行 Python 3.8.10 以及 NX2027. 只是若要兩百多人同時在一台 Windows 主機上, 該如何設置? 目前想到的方式是透過 OpenSSH 伺服器, 讓各用戶以 ssh 遠端登入到 Windows based NX server, 然後透過動態個人網站的 Flask Blueprint 編寫延伸程式, 透過 Python 3.8.10 與 NX2027 及 CoppeliaSim 進行互動. 所以目前的問題是 Windows bulk account creation、OpenSSH server installation and setup、NX2027 environment setup 以及遠端登入後採 Github Token 或 SSH 協定對 Github 連線等議題.","tags":"cad2022","url":"./2022_fall_courses_w12.html"},{"title":"2022 Fall 課程 w10","text":"2022 Fall 課程進入第十週, 各班每六名學員自選組員分組, 目的除了鼓勵同儕間的互相學習外, 也希望每週各組依照 TCExam 題組的 XML 檔案格式出題. XML 格式檔案 在第十週的課程中, 無論是 TCExam 線上考試題庫的格式或是 CoppeliaSim 文字檔案格式, 都可以使用 XML 格式檔案表示. XML 格式檔案就是利用標註 (tags) 涵蓋特定區域範圍的資料, 表示該段範圍資料的屬性. 超文件檔案就是典型的一種 XML 檔案. 希望處理 XML 檔案, 必須先取得該檔案所使用的 tags, 以下程式就可以取出某一 XML 檔案中的 tags: # from https://stackoverflow.com/questions/29596584/getting-a-list-of-xml-tags-in-file-using-xml-etree-elementtree import xml.etree.ElementTree as ET # load and parse the file filename = 'two_link_slvs_shaft_simple.simscene.xml' xmlTree = ET.parse(filename) elemList = [] for elem in xmlTree.iter(): elemList.append(elem.tag) # now I remove duplicities - by convertion to set and back to list elemList = list(set(elemList)) # Just printing out the result print(elemList) for i in elemList: print(i) TCExam 考試題目輸出後的 XML, 其主要 Tags 大約只有 20 個, 但 CoppeliaSim 完整的 XML 場景存檔後的 XML tags 則超過 340 個. 在這裡我們要使用 Leo Editor 來處理這些 XML 檔案. Leo Editor 有一個 @settings 的設計, 其中除了利用 @data qt-gui-plugin-style-sheet 來設定套件畫面各部分字型的大小與顏色外, 也提供專用於 XML import 的解讀設定, 其設定名稱為 @data import-xml-tags, 以條列式逐一列出希望由 Leo Editor import 流程解讀的 tags 名稱, 然後放在 @settings 節點之下, 且對應的 .leo 必須先行存檔然後再開啟, 此一用來 parse XML tags 的設定才會生效. 因此利用 Leo Editor 處理 XML 的流程就是先使用上述程式讀取希望解讀的 .xml 檔案, 然後將取出的 tags 放入 @settings 節點下的 @data import-xml-tags 節點內文, 將 .leo 存檔後打開, 以 File import 讀入 .xml 檔案, 就可以得到利用 @auto 解讀後的 .xml 內容. stud Linux server 先前的 Heroku 提供免費使用帳號時, 上課學員可以設法將 cmsimde 動態網站部署到 Heroku, 儘管 persistent content 的儲存需要收費, 但若能將 Heroku 中的內容與 Github 保持雙向同步, 上課學員就可以利用動態網站即時管理個人倉儲的內容. 現在 Heroku 收掉免費帳號後, 原本希望利用 Replit 所提供的 Python 網際 IDE 環境來執行學員的動態網站, 無奈 Replit 所提供的免費資源沒有 Heroku 優渥, 在緊密連線下無法勝任上課使用. 最終只能自行啟動 stud 伺服器. 讓所有學員在一台 Ubuntu 主機上執行動態網站. 由於 stud 沒有與 DNS 動態設定互動, 因此無法如 Heroku 或 Replit 給每位學員一個獨立的 domain name, 而是發給每一位學員不同的內部與外部埠號, 以 uwsgi 模式執行各自的動態網站. 基本的 stud 主機環境與使用流程如下: stud 主機只有 IPv6 網路協定, 因此 ssh, sftp 以及 http 等連線的使用都必須透過雙支援協定才能與僅支援 IPv4 的電腦相連. 若希望遠端登入 stud 伺服器的電腦, 使用 IPv6 網路協定, 可以直接以 ssh 連線, sftp 也可直接連線. 若希望遠端登入 stud 伺服器的電腦, 只有 IPv4 網路協定, 則遠端登入使用 ssh 必須設定雙支援代理主機, 假如連線的電腦位於校外, 則可以使用專責 Proxy 或透過校方所提供的 vpn 進行連線後, 再使用 ssh 遠端登入 stud 主機. 使用者遠端登入 stud 主機後, 因為該主機只有 IPv6 網路, 因此對 github.com 主機的連線, 無論是 ssh 或 http 都必須設定 proxy 代理主機. 使用者登入 stud, 主要目的是利用主機上的 Python 3 執行位於 github.com 上的個人倉儲動態網站, 因此必須先使用 git clone 取下個人的倉儲. 由於位於 github.com 上的個人倉儲使用子模組, 因此 git clone 之前必須先設定 ssh 對 github.com 連線的代理主機, 以及取下子模組用的 http 代理主機. 利用 ssh 協定取下個人的代理主機, 其設定必須先用 ssh-keygen 在 .ssh 目錄中建立 private key (id_rsa) 以及 public key (id_rsa.pub), 並且將 id_rsa.pub 登錄到個人 github.com 帳號下 Settings 下的 SSH and GPG keys 設定區. 而且需要在 .ssh 目錄中, 利用 config 設定檔案, 指定 Host 以及代理主機, 此 Host 名稱可以視為 Linux 操作系統下, 以 ssh 對 github.com 連線的 session 名稱. git clone 執行時所使用的 http 代理主機設定可透過 git config --global http.proxy http://your_proxy_server:3128 達成. 完成將個人倉儲取下至個人帳號下的工作目錄後, 因為要採 waitress 方式執行 cmsimde, 因此還需要取得對應的 server.py, 必須放入倉儲目錄中, 另外 acp 也必須使用 Linux 的指令格式, 並且若要使用網際 acp, 則必須 cd 至 cmsimde 後, 以 git pull origin master 取下最新版本. 當使用 python3 server.py & 執行 process 後, ps axo pid,comm,uid | grep \"python3\" 的指令, 可以列出各自帳號下所 background 執行的 process pid, 若需要列出執行 process 對應目錄, 則可以利用 pwdx 加上 pid 後執行取得.","tags":"cad2022","url":"./2022_fall_courses_w10.html"},{"title":"2022 Fall 課程 w9","text":"2022 Fall 課程進入第九週, 期中線上考試週. TCExam 這個學期又重新啟用 TCExam, 這是一套用 PHP 加上資料庫所寫的線上考試系統, 只不過從 https://github.com/tecnickcom/tcexam 取得的原始碼無法在最新的 PHP 8.1 與 PostgreSQL 15 版中執行. 從 TIOBE Index 可以很清楚看出, 2005-2010 年是 PHP 程式語言最盛行的階段, 目前已經掉到常用程式語言第十名左右. 但因為 TCExam 的架構完整, 允許利用題庫出題, 且能夠使用 xml 匯入或匯出題庫, 因此只要能在最新的 PHP 與 PostgreSQL 系統中執行, 應該還算堪用. 由於目前 HTML5 中的 Canvas 與 WebGL 可以建立網際互動式題目, 但若要與 TCExam 結合, 多少還是得使用 PHP, 因此在 https://mde.tw/content/pjexam.html 才會希望利用 Flask 編寫延伸程式, 最終若能擷取其資料庫架構, 重新以 Flask 編寫, 並且置入 AI 與使用者群組的命題內容, 應該是個不錯的專案研究主題. 考試題庫 線上考試的主要目的是鑑別出各學員在特定課程主題的學習成效. 理論上應該會有選擇題, 填充題與問答申論題目. 但是目前僅利用複選題, 讓學員在考試交卷後, 就可以知道分數, 好處是流程效率高, 但卻犧牲掉讓學生填空與思考申論的機會. 題型 目前所使用的題型, 全部都是要求學員從答題選項中, 選出正確的敘述, 而各選擇項目的說明大多採用文字敘述 (目前沒有計算與推導式的題目). 其中, 在電腦輔助設計室中的網路設定部分, 學員必須了解如何設定, 並且針對 IPv6 網路協定所使用的設定細節描述, 從選擇項目中選出正確的設定. 另外與 SSH 協定連線有關的題目, 或是 git http 網路協定的設定題目, 也大抵與上課時採用純 IPv6 網路連線有關. 只要學員在上課時有實際操作設定, 應該都能分辨出選擇項目中正確的敘述. 在 Python 程式語法的題目部分, 則通常給定一段程式碼, 然後試圖讓學員將程式碼複製到可以執行的 Brython 程式環境執行後, 再詢問是否可以執行, 或者經過特定修改後是否能夠執行等問題, 以文句敘述, 要求學員判斷真偽. 至於與電腦輔助設計有關的題目, 則希望學員能夠正確開啟 Solvespace, NX2027 與 Onshape 將零組件載入後再答題. 目前的 CAD 相關題目, 以 Onshape 而言, 要求使用者了解各零組件檔案擷取, 是採螢幕下方 tab 頁面區分, 並且可從零件繪圖流程查詢相關設計參數. 其餘 NX 與 Solvespace 的題型也大抵類似, 要求學員開啟檔案後, 再進入利用 measure 量測尺寸或查詢設計參數等. 學員分組建立題庫 預計每六人一組, 每週根據先前授課內容, 交出十個複選題, 且每一個題目針對一個課程教學主題, 提供十個選項, 其中規定正確敘述與錯誤敘述各半. 因此若以每題四個選擇, 則每一個題目可以產生 10C4 個組合, 也就是共有 10 9 8 7/4 3 2 1 = 210 種不同組合題目. 因此針對每班約 60 人的線上考題, 應可避開針對同一題組內相同題目的問題. 計算機程式課程主題 當各學員能夠在 stud Ubuntu 主機開啟個人倉儲的動態網站後, 即可直接透過 Gist 與 stud 動態網站練習編寫各種 Brython 程式. 首先是希望學員了解如何透過 Brython 特有的 Open() 與 read() 讀取相關網站上的資料後, 進行相關 split() 後, 將資料納入數列後, 可以透過 for 迴圈與判斷式, 熟悉如何使用 List, Tuple 與 Dict 等資料結構. 並且從 random 模組及其 shuffle(), 可以編寫各班學號抽點的程式, 之後再利用 Brython 的 html 模組, 直接在 stud 動態網站中建立超文件內容, 其中包括 anchor 與 form 表單等. 目前在 Brython 頁面中已經有 block 動態模擬, 貪食蛇以及俄羅斯方塊等遊戲的基本程式範例, 若學員能夠了解如何透過視覺暫留的方式, 在網頁上建立各種遊戲, 接下來或可朝貪食蛇與俄羅斯方塊的基本 AI 架構程式學習. 以貪食蛇的 AI 程式而言, 操控者每走一步, 都必須先行評估後續的最佳得分策略, 其中牽涉 BFS 與 DFS 搜尋法的探討與程式碼實現. 電腦輔助設計與實習課程主題 目前的進度在讓學員針對 Solvespace, NX2027 (即 NX2007 最後一個版本, 與 NX2008 檔案格式相容), 以及 Onshape 進行鑽床零組件繪製練習. 其中 Solvespace 可以利用 https://pypi.org/project/python-solvespace/ 以 Python 解各繪圖 Group 中草圖尺寸間的約束條件. NX2027 則可透過 NXOpen Python API 對零組件進行程式設計. 若將 NX20227 在 Python 3.8 版次的解譯器環境中啟動, 且模組搜尋連結指向 NX2027\\NXBIN\\Python, 則可使用 Flask 網際程式與 NX2027 進行 non-interactive 互動, 協助使用者在瀏覽器中的動態網站執行電腦輔助機械零組件設計. 至於 Onshape, 則可以利用 https://dev-portal.onshape.com/ 與 https://github.com/onshape-public/onshape-clients , 以 Python 建立 API 延伸程式. RoboDK RoboDK 源自 http://www.parallemic.org/RoKiSim.html , 在電腦輔助設計與實習課程, 可以作為 STL 零組件檢視器. 使用者也可以透過 RoboDK 套件中的各種功能, 了解產業界如何利用機械手臂執行各種電腦輔助製造流程.","tags":"cad2022","url":"./2022_fall_courses_w9.html"},{"title":"2022 Fall 課程 w8","text":"2022 Fall 課程進入第八週, 就計算機程式與電腦輔助設計實習等課程的架構, 其核心都是繞著網站運作. 計算機程式課程核心 一言以蔽之, 計算機程式課程的核心, 就是教導如何在網站上執行程式, 假如只是考慮到網站的前端, 就是讓學員了解如何運用 html、css 與 Javascript, 若涵蓋網站後端, 則指如何使用 Python 程式與網站前端互動. 然而對機械設計流程之後的應用而言, 在網站上執行程式的重點, 是如何利用網路與程式在網站上進行機電系統模擬. 網站 KMOLab 課程的網站雖然以 Github Pages 上的網站為主, 但是在轉換為 html 超文件網站之前, 使用者可以透過網站前端與後端的計算機程式與 CAD 套件互動, 然後再設法將模擬或設計的機電資系統結果呈現在 Github Pages 網站上. 由於 Siemens NX 套件的 NXOpen 程式延伸架構允許利用 Python 程式編寫 API 程式, 因此就網站前端的程式語言選擇, 並非直接使用 Javascript, 而是採用 Brython. 也就是使用者可以在網頁上編寫 Python 格式的 Brython 程式, 然後再轉為 Javascript 執行. 至於後端則使用 CPython + Flask 設法與 NX 、Solvespace 及 Coppeliasim 進行互動. 2022 Fall 各學員的網站倉儲採用 Github Classroom 配置, 也就是讓各學員的個人課程倉儲位於計算機程式 (cp2022) 與電腦輔助設計實習 (cad2022) 的 organization 代號下: mdecp2022 與 mdecad2022. 目前 Github Pages 上的倉儲只能顯示最新版特定 branch 上的資料, 因此若希望靜態或動態網站能夠將曾經改版的歷史資料逐一呈現, 則必須在自行架構的同步倉儲中利用網際程式, 或將倉儲的歷程資料同步轉入 Fossil SCM 的 Docs 網站才可達成. 這裡所謂的網站指符合 WWW 網路協定規範的伺服器, 假如只是純粹在 Ubuntu 或 Windows 上希望透過 WWW server 伺服網頁, 可以採用 Nginx, 其中可以設定為 http 伺服或加上 LetsEncrypt 設定為 https 伺服. 至於 區分靜態與動態網站 的關鍵在於是否可透過程式方法, 直接登入 WWW 網站修改內容, 一般來說, 靜態網頁的內容修改, 是修改 html, css 或 Javascript 資料, 該靜態網站的 html 檔案並無讓管理者登入的選項, 但動態網站則通常透過 server 端的程式來產生網頁, 而這些網頁可以採用純 html 的方式儲存, 也可透過 Database 的方式儲存. 使用者可以將靜態網站視為一個網站最終呈現給使用者的資料, 而動態網站則可以透過程式方法, 配合組織內的各種運作流程來呈現網站內容. 而這些產生網站資料的流程允許置入審查機制或各種內部管理流程的運作後才產生配置在網站上的內容. 然而隨著 Javascript 前端程式的蓬勃發展, 靜態網站與動態網站的區別可以透過網站內容是否牽涉伺服器上的程式運作而定. 網站內容所執行的程式僅依賴網站前端的程式者可視為靜態網站. 而網站內容除了網站前端程式外, 還包括網站後端 server 程式的搭配才產生網站內容者, 則可視為動態網站. 程式的編寫與儲存 計算機程式課程的推動, 在各學員都能透過 Github Pages 呈現個人倉儲網站內容之後, 就可以直接在個人的靜態網頁中呈現其學習計算機程式語言的歷程. 由於各學員所編寫的 Brython 被要求儲存在其帳號下的 Gist 區域, 因此每次的程式內容改版都能透過版次號碼擷取, 假如再要求各種程式開發過程, 必須仔細透過程式註解說明各段程式編寫的構想與採行方法, 如此便可經由各學員繳交程式的改版歷程所參照的資料或構想判定其原創程度. 例如: 各學員在 Gist 上編寫程式時, 必須先提供程式編寫目的, 編寫構想, 編寫參考資料與所擬採行的步驟後, 再逐一實現程式內容. 計算機程式問題 window.onload=function(){ brython({debug:1, pythonpath:['./../cmsimde/static/','./../downloads/py/']}); } 以下為 1a 計算機程式學員的靜態網頁連結: # 從 Brython 的 browser 模組導入 document 與 html 程式庫 from browser import document, html # 利用 document 物件, 以索引 \"brython_div1\" 取得已經位於 html 網頁中 id=\"brython_div1\" 的位置, 且對應到 brython_div1 變數 brython_div1 = document[\"brython_div1\"] # 可以用三個單引號或三個雙引號標註多行註解 # 其中的 html 物件有許多建立 html 超文件內容的方法, 以下分別建立 # BUTTON 按鈕, BR 跳行 (break), 以及 A 網站連結 (Anchor) # <= 是 Brython 程式語言的特殊符號, 專用於將 html 超文件資料送給網頁對應變數 \"\"\" brython_div1 <= html.BUTTON(\"hello\") brython_div1 <= html.BR() brython_div1 <= html.A(\"google\", href=\"https://google.com\") \"\"\" try: c = document.query[\"c\"] except: c = \"1a\" # 將 1b.txt 資料從 Github Pages 網頁中取下 url = \"https://mde.tw/studlist/2022fall/\" + c + \".txt\" # 利用 open() 開啟網頁, 利用 read() 讀取網頁內容 # 然後利用 split() 方法, 利用跳行符號對資料進行切割, 切割後的資料結構為 list # list 資料結構以 [] 區隔, 表示資料為數列, 其起始的索引值為 0 data = open(url).read().split(\"\\n\") # 將每一位學員的靜態網頁共同的網路連結部分設為字串, 且與 mdecp2022 變數對應 mdecp2022 = \"https://mdecp2022.github.io/site-\" # 因為取下的資料第一筆為標題, 而最後一筆為空字串, 可以利用 Brython 的數列索引取值範圍將索引 0 與最後一個數列值去除 data = data[1:-1] # 利用 for 重複迴圈逐一取出 data 數列中的值, 然後以 \\t, 也就是 tab 符號切割 count = 0 for i in data: count += 1 stud = i.split(\"\\t\") # 第一欄位為學號 stud_num = stud[0] # 第二欄未為 github 帳號 try: github_acc = stud[1] except: github_acc = stud_num # 將靜態網頁共同連結的變數與各自的 github 帳號, 組成完整的各學員靜態網頁連結 site = mdecp2022 + github_acc # 利用 A 物件產生連結, 然後放入 id=\"brython_div1 所在的網頁位置 link = html.A(stud_num, href=site) brython_div1 <= link # 每一筆資料列出後, 以 break 標註跳行 # 每一行列出五筆資料後, 跳行 brython_div1 <= \" \" if count % 5 == 0: brython_div1 <= html.BR() 以下為計算機程式 1b 修課學員的個人倉儲靜態網頁連結: # 從 Brython 的 browser 模組導入 document 與 html 程式庫 from browser import document, html # 利用 document 物件, 以索引 \"brython_div2\" 取得已經位於 html 網頁中 id=\"brython_div2\" 的位置, 且對應到 brython_div2 變數 brython_div2 = document[\"brython_div2\"] # 可以用三個單引號或三個雙引號標註多行註解 # 其中的 html 物件有許多建立 html 超文件內容的方法, 以下分別建立 # BUTTON 按鈕, BR 跳行 (break), 以及 A 網站連結 (Anchor) # <= 是 Brython 程式語言的特殊符號, 專用於將 html 超文件資料送給網頁對應變數 \"\"\" brython_div2 <= html.BUTTON(\"hello\") brython_div2 <= html.BR() brython_div2 <= html.A(\"google\", href=\"https://google.com\") \"\"\" try: c = document.query[\"c\"] except: c = \"1a\" c = \"1b\" # 將 1b.txt 資料從 Github Pages 網頁中取下 url = \"https://mde.tw/studlist/2022fall/\" + c + \".txt\" # 利用 open() 開啟網頁, 利用 read() 讀取網頁內容 # 然後利用 split() 方法, 利用跳行符號對資料進行切割, 切割後的資料結構為 list # list 資料結構以 [] 區隔, 表示資料為數列, 其起始的索引值為 0 data = open(url).read().split(\"\\n\") # 將每一位學員的靜態網頁共同的網路連結部分設為字串, 且與 mdecp2022 變數對應 mdecp2022 = \"https://mdecp2022.github.io/site-\" # 因為取下的資料第一筆為標題, 而最後一筆為空字串, 可以利用 Brython 的數列索引取值範圍將索引 0 與最後一個數列值去除 data = data[1:-1] # 利用 for 重複迴圈逐一取出 data 數列中的值, 然後以 \\t, 也就是 tab 符號切割 count = 0 for i in data: count += 1 stud = i.split(\"\\t\") # 第一欄位為學號 stud_num = stud[0] # 第二欄未為 github 帳號 try: github_acc = stud[1] except: github_acc = stud_num # 將靜態網頁共同連結的變數與各自的 github 帳號, 組成完整的各學員靜態網頁連結 site = mdecp2022 + github_acc # 利用 A 物件產生連結, 然後放入 id=\"brython_div21 所在的網頁位置 link = html.A(stud_num, href=site) brython_div2 <= link # 每一筆資料列出後, 以 break 標註跳行 # 每一行列出五筆資料後, 跳行 brython_div2 <= \" \" if count % 5 == 0: brython_div2 <= html.BR() 2D 靜態繪圖 # 畫美國國旗 # 根據 https://en.wikipedia.org/wiki/Flag_of_the_United_States#Specifications 規格繪圖 # 導入 doc from browser import document as doc # 以下將利用 html 產生所需的繪圖畫布 from browser import html # 利用 math 函式庫執行三角函數運算 import math # height = 1, width = 1.9 width = 600 height = int(600/1.9) canvas = html.CANVAS(width = width, height = height) #canvas.style = {\"width\": \"100%\"} canvas.id = \"taiwan_flag\" # 將圖畫至 id 為 brython_div 的 cnavas 標註 brython_div = doc[\"usa_flag\"] brython_div <= canvas # 準備繪圖畫布 canvas = doc[\"taiwan_flag\"] ctx = canvas.getContext(\"2d\") # 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點 # ctx.setTransform(1, 0, 0, -1, 0, canvas.height) # 以下採用 canvas 原始座標繪圖 flag_w = canvas.width flag_h = canvas.height # 先畫滿地紅 ctx.fillStyle='#B31942' ctx.fillRect(0,0,flag_w,flag_h) # 6 條白色長方形 # 每條高度 height/13 ctx.fillStyle ='#FFFFFF' white_height = int(height/13) whitex = 0 whitey = white_height white_width = width for i in range(6): ctx.fillRect(whitex, whitey+i*2*white_height, white_width, white_height) # 藍色區域 blue_height = int(height*7/13) blue_width = int(width*2/5) bluex = 0 bluey = 0 ctx.fillStyle ='#0A3161' ctx.fillRect(bluex, bluey, blue_width, blue_height) # 建立畫直線函式 def draw_line(x1, y1, x2, y2, color=\"#ff0000\"): ctx.beginPath() ctx.moveTo(x1, y1) ctx.lineTo(x2, y2) ctx.strokeStyle = color ctx.stroke() # 測試畫直線函式功能 #draw_line(10, 10, 100, 100) # 定義角度轉換為徑度變數 deg = math.pi/180. # 建立五星繪圖函式 #x, y 為中心, r 為半徑, angle 旋轉角, solid 空心或實心, color 顏色 def star(x, y, r, angle=0, solid=False, color=\"#ff0000\"): #以 x, y 為圓心, 計算五個外點 # 圓心到水平線距離 a = r*math.cos(72*deg) # a 頂點向右到內點距離 b = (r*math.cos(72*deg)/math.cos(36*deg))*math.sin(36*deg) # 利用畢氏定理求內點半徑 rin = math.sqrt(a*a + b*b) # 查驗 a, b 與 rin #print(a, b, rin) if solid: ctx.beginPath() # angle 角度先轉 360/10, 讓五星對正 angle = angle + 360/10 for i in range(5): xout = (x + r*math.sin((360/5)*deg*i+angle*deg)) yout = (y + r*math.cos((360/5)*deg*i+angle*deg)) # 外點增量 + 1 xout2 = x + r*math.sin((360/5)*deg*(i+1)+angle*deg) yout2 = y + r*math.cos((360/5)*deg*(i+1)+angle*deg) xin = x + rin*math.sin((360/5)*deg*i+36*deg+angle*deg) yin = y + rin*math.cos((360/5)*deg*i+36*deg+angle*deg) # 查驗外點與內點座標 #print(xout, yout, xin, yin) if solid: # 填色 if i==0: ctx.moveTo(xout, yout) ctx.lineTo(xin, yin) ctx.lineTo(xout2, yout2) else: ctx.lineTo(xin, yin) ctx.lineTo(xout2, yout2) else: # 空心 draw_line(xout, yout, xin, yin, color) # 畫空心五芒星, 無關畫線次序, 若實心則與畫線次序有關 draw_line(xout2, yout2, xin, yin, color) if solid: ctx.fillStyle = color ctx.fill() # 白色五星 white = \"#FFFFFF\" # 單數排白色五星 star1x = int(blue_width/12) star1y = int(blue_height/10) star_radius = int(white_height*4/5/2) # 沿 x 方向有 6 顆白色五星 # 沿 y 方向有 5 顆白色五星 inc1x = int(2*blue_width/12) inc1y = int(2*blue_height/10) for i in range(6): for j in range(5): star(star1x+i*inc1x, star1y+j*inc1y, star_radius, solid=True, color=white) # 雙數排白色五星 star2x = int(blue_width/12 + blue_width/12) star2y = int(blue_height/10 + blue_height/10) # 沿 x 方向有 5 顆白色五星 # 沿 y 方向有 4 顆白色五星 for i in range(5): for j in range(4): star(star2x+i*inc1x, star2y+j*inc1y, star_radius, solid=True, color=white) # Spur Gear in Cango and gearUtils-09.js from browser import document as doc from browser import html from browser import window import browser.timer import math # 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應 canvas = html.CANVAS(width = 600, height = 400) # 將 canvas 標註的 id 設為 \"cango_gear\" canvas.id = \"cango_gear\" # 將 document 中 id 為 \"spurgear\" 的標註 # 設為與 brython_div 變數對應 brython_div = doc[\"spurgear\"] # 將 canvas 標註放入 brython_div 所在位置 brython_div <= canvas # 將頁面中 id 為 cango_gear 的 CANVAS 設為與 canvas 對應 canvas = doc[\"cango_gear\"] # convert Javascript objects to Brython variables cango = window.Cango.new circle = window.circle.new shape = window.Shape.new path = window.Path.new creategeartooth = window.createGearTooth.new svgsegs = window.SVGsegs.new # 經由 Cango 轉換成 Brython 的 cango # 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") # 以下將要使用 gearUtils-09.js 畫出正齒輪外形 # 假設齒數為 25 num = 25 # 利用 gearUtils-09 產生單一齒輪外形資料 tooth = creategeartooth(10, num, 20) # 在 Cango 中, 只有 SVG 才能 rotate, appendPath 或 joinPath # 將齒輪外形轉為 SVG segment toothSVG = svgsegs(tooth) path1 = path(toothSVG.scale(1), {\"degs\": 45, \"x\": 100, \"y\": 100, \"strokeColor\": \"#606060\"}) #print(path1) # SVG list circle = circle(50) #print(circle) circleSVG = svgsegs(circle) #print(circleSVG) # 若將 circleSVG 轉為 Cango path, 則可以用 cgo.render() #circlePath = path(circleSVG, {\"x\": 100, \"y\": 100, \"strokeColor\": \"#606060\"}) #cgo.render(circlePath) # svgsegs 資料可以 joinPath 或 appendPath # joinPath 按照頭尾順序銜接 # appendPath 則無順序銜接 # 從 toothSVG 複製出單齒 SVG 資料 one = toothSVG.dup() # 以照齒數, 逐一複製並附加在原單齒資料中 # 第一齒的資料已經在 toothSVG 中, 因此重複迴圈從 1 開始 for i in range(1, num): newSVG = one.rotate(360*i/num) toothSVG = toothSVG.appendPath(newSVG) # 將 SVG 轉為 path 資料 #gear = path(toothSVG, {\"x\": 150, \"y\": 150, \"strokeColor\": \"#606060\"}) # path 資料可以透過 cgo.render()顯示繪圖物件 #cgo.render(gear) # 當 circle 接外齒使用 appendPath toothSVG = toothSVG.appendPath(circleSVG) #print(toothSVG) spurPath = path(toothSVG, {\"x\": 150, \"y\": 150, \"strokeColor\": \"#606060\"}) cgo.render(spurPath) 2D 動態繪圖 # from https://levelup.gitconnected.com/writing-tetris-in-python-2a16bddb5318 # 改為可自動執行模式 import random # 以下為 Brython 新增 from browser import document as doc from browser import html import browser.timer def intersects(game_field, x, y, game_width, game_height, game_figure_image): intersection = False for i in range(4): for j in range(4): if i * 4 + j in game_figure_image: if i + y > game_height - 1 or \\ j + x > game_width - 1 or \\ j + x < 0 or \\ game_field[i + y][j + x] > 0: intersection = True return intersection def simulate(game_field, x, y, game_width, game_height, game_figure_image): while not intersects(game_field, x, y, game_width, game_height, game_figure_image): y += 1 y -= 1 height = game_height holes = 0 filled = [] breaks = 0 for i in range(game_height-1, -1, -1): it_is_full = True prev_holes = holes for j in range(game_width): u = '_' if game_field[i][j] != 0: u = \"x\" for ii in range(4): for jj in range(4): if ii * 4 + jj in game_figure_image: if jj + x == j and ii + y == i: u = \"x\" if u == \"x\" and i < height: height = i if u == \"x\": filled.append((i, j)) for k in range(i, game_height): if (k, j) not in filled: holes += 1 filled.append((k,j)) else: it_is_full = False if it_is_full: breaks += 1 holes = prev_holes return holes, game_height-height-breaks def best_rotation_position(game_field, game_figure, game_width, game_height): best_height = game_height best_holes = game_height*game_width best_position = None best_rotation = None for rotation in range(len(game_figure.figures[game_figure.type])): fig = game_figure.figures[game_figure.type][rotation] for j in range(-3, game_width): if not intersects( game_field, j, 0, game_width, game_height, fig): holes, height = simulate( game_field, j, 0, game_width, game_height, fig ) if best_position is None or best_holes > holes or \\ best_holes == holes and best_height > height: best_height = height best_holes = holes best_position = j best_rotation = rotation return best_rotation, best_position # 建立一個自動執行的函式 # step 1 ''' def run_ai(): game.rotate() ''' #step 2 def run_ai(game_field, game_figure, game_width, game_height): rotation, position = best_rotation_position(game_field, game_figure, game_width, game_height) if game_figure.rotation != rotation: game.rotate() elif game_figure.x < position: game.go_side(1) elif game_figure.x > position: game.go_side(-1) else: game.go_space() # 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應 canvas = html.CANVAS(width = 400, height = 500, id=\"canvas\") brython_div = doc[\"tetris\"] brython_div <= canvas ctx = canvas.getContext(\"2d\") colors = [ (0, 0, 0), (120, 37, 179), (100, 179, 179), (80, 34, 22), (80, 134, 22), (180, 34, 22), (180, 34, 122), ] class Figure: x = 0 y = 0 figures = [ [[1, 5, 9, 13], [4, 5, 6, 7]], [[4, 5, 9, 10], [2, 6, 5, 9]], [[6, 7, 9, 10], [1, 5, 6, 10]], [[1, 2, 5, 9], [0, 4, 5, 6], [1, 5, 9, 8], [4, 5, 6, 10]], [[1, 2, 6, 10], [5, 6, 7, 9], [2, 6, 10, 11], [3, 5, 6, 7]], [[1, 4, 5, 6], [1, 4, 5, 9], [4, 5, 6, 9], [1, 5, 6, 9]], [[1, 2, 5, 6]], ] def __init__(self, x, y): self.x = x self.y = y self.type = random.randint(0, len(self.figures) - 1) self.color = random.randint(1, len(colors) - 1) self.rotation = 0 def image(self): return self.figures[self.type][self.rotation] def rotate(self): self.rotation = (self.rotation + 1) % len(self.figures[self.type]) class Tetris: level = 2 score = 0 state = \"start\" field = [] height = 0 width = 0 x = 100 y = 60 zoom = 20 figure = None def __init__(self, height, width): self.height = height self.width = width self.field = [] self.score = 0 self.state = \"start\" for i in range(height): new_line = [] for j in range(width): # 起始時每一個都填入 0 new_line.append(0) self.field.append(new_line) def new_figure(self): self.figure = Figure(3, 0) def intersects(self): intersection = False for i in range(4): for j in range(4): if i * 4 + j in self.figure.image(): # block 到達底部, 左右兩邊界, 或該座標有其他 block if i + self.figure.y > self.height - 1 or \\ j + self.figure.x > self.width - 1 or \\ j + self.figure.x < 0 or \\ self.field[i + self.figure.y][j + self.figure.x] > 0: intersection = True return intersection def break_lines(self): lines = 0 for i in range(1, self.height): zeros = 0 for j in range(self.width): if self.field[i][j] == 0: zeros += 1 if zeros == 0: lines += 1 for i1 in range(i, 1, -1): for j in range(self.width): self.field[i1][j] = self.field[i1 - 1][j] self.score += lines ** 2 def go_space(self): while not self.intersects(): self.figure.y += 1 self.figure.y -= 1 self.freeze() def go_down(self): self.figure.y += 1 if self.intersects(): self.figure.y -= 1 self.freeze() def freeze(self): for i in range(4): for j in range(4): if i * 4 + j in self.figure.image(): self.field[i + self.figure.y][j + self.figure.x] = self.figure.color self.break_lines() self.new_figure() if self.intersects(): self.state = \"gameover\" def go_side(self, dx): old_x = self.figure.x self.figure.x += dx if self.intersects(): self.figure.x = old_x def rotate(self): old_rotation = self.figure.rotation self.figure.rotate() if self.intersects(): self.figure.rotation = old_rotation # Define some colors # from https://stackoverflow.com/questions/3380726/converting-a-rgb-color-tuple-to-a-six-digit-code BLACK = '#%02x%02x%02x' % (0, 0, 0) WHITE = '#%02x%02x%02x' % (255, 255, 255) GRAY = '#%02x%02x%02x' % (128, 128, 128) RED = '#%02x%02x%02x' % (255, 0, 0) done = False fps = 5 game = Tetris(20, 10) counter = 0 pressing_down = False def key_down(eve): key = eve.keyCode #if event.type == pygame.QUIT: # 32 is pause if key == 32: done = True # 82 is r key to rotate if key == 82: game.rotate() # 40 is down key if key == 40: pressing_down = True # 37 is left key if key == 37: game.go_side(-1) # 39 is right key if key == 39: game.go_side(1) # 68 is d key to move block to bottom if key == 68: game.go_space() # 27 is escape # reset the game if key == 27: # clear the previous score ctx.fillStyle = WHITE ctx.fillRect( 100, 0, 200, 50) game.__init__(20, 10) def key_up(eve): key = eve.keyCode # 40 is down key if key == 40: pressing_down = False #while not done: def do_game(): global counter if game.figure is None: game.new_figure() counter += 1 if counter > 100000: counter = 0 if counter % (fps // game.level // 2) == 0 or pressing_down: if game.state == \"start\": game.go_down() run_ai(game.field, game.figure, game.width, game.height) for i in range(game.height): for j in range(game.width): ctx.fillStyle = WHITE #ctx.scale(game.zoom, game.zoom) ctx.fillRect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom) if game.field[i][j] > 0: ctx.fillStyle = '#%02x%02x%02x' % colors[game.field[i][j]] ctx.fillRect(game.x + game.zoom * j + 1, game.y + game.zoom * i + 1, game.zoom - 2, game.zoom - 1) ctx.lineWidth = 1 ctx.strokeStyle = GRAY ctx.beginPath() ctx.rect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom) ctx.stroke() if game.figure is not None: for i in range(4): for j in range(4): p = i * 4 + j if p in game.figure.image(): ctx.fillStyle = '#%02x%02x%02x' % colors[game.figure.color] ctx.fillRect(game.x + game.zoom * (j + game.figure.x) + 1, game.y + game.zoom * (i + game.figure.y) + 1, game.zoom - 2, game.zoom - 2) # score and Game Over scripts from https://s40723245.github.io/wcm2022 # 宣告文字的大小為36px ctx.font = '36px serif' # 宣告文字顏色為黑色 ctx.fillStyle = BLACK # 將分數顯示在遊戲區上方, 座標為(10, 50), 並設定變數為text ctx.fillText('Score:'+ str(game.score), 10,50) # 宣告變數int = 1 ，如果分數大於int，則畫布清掉原本的分數填上新的得分分數 int = 1 if game.score >= int: ctx.fillStyle = WHITE ctx.fillRect( 100, 0, 200, 50) ctx.fillStyle = BLACK ctx.fillText(str(game.score), 108,50) # 如果遊戲狀態為gameover，顯示Game Over及Press ESC，並將文字設定為紅色 if game.state == \"gameover\": ctx.fillStyle = RED ctx.fillText(\"Game Over\", 100, 200) ctx.fillText(\"Press ESC\", 105, 265) ctx.fillStyle = WHITE ctx.fillRect( 100, 0, 200, 50) game.__init__(20, 10) doc.addEventListener(\"keydown\", key_down) doc.addEventListener(\"keyup\", key_up) browser.timer.set_interval(do_game, fps) 2D 機構模擬 # make canvas 600x400 from browser import document as doc from browser import window from browser import timer from browser import html import math # 建立 fourbar canvas canvas = html.CANVAS(width = 600, height = 400) canvas.id = \"fourbar1\" brython_div = doc[\"fourbar\"] brython_div <= canvas # 準備繪圖畫布 canvas = doc[\"fourbar1\"] # 建立 buttons brython_div <= html.BUTTON(\"啟動\", id=\"power\") brython_div <= html.BUTTON(\"反向\", id=\"reverse\") # 利用 window 擷取 PrairieDraw 程式庫變數物件, 然後以 JSConstructor 函式轉為 Brython 變數 pdraw = window.PrairieDraw.new # 利用 window 擷取 PrairieDrawAnim 程式庫變數物件, 然後以 JSConstructor 函式轉為 Brython 變數 PrairieDrawAnim = window.PrairieDrawAnim.new # 利用 window 擷取 sylvester 程式庫變數物件 Vector, 並將其 create 方法直接轉為 Brython 變數 # 在 sylvester 中的 $V 簡化變數無法直接在 Brython 程式中引用 vector = window.Vector.create.new # 在 \"fourbar\" 畫布中建立 panim 動態模擬案例 panim = PrairieDrawAnim(\"fourbar1\") # 平面連桿繪圖以 t = 0 起始 t = 0 # 控制轉動方向變數 direction = True # 繪製不同 t 時間下的平面連桿 def draw(): global t, direction, fast # 設定模擬繪圖範圍 panim.setUnits(6, 6) # 設定箭頭線寬 panim.setProp(\"arrowLineWidthPx\",2) # 起始變數設定 omega = 1 length_bar1 = 1 length_bar2 = 26/18 length_bar3 = 2 length_base = 40/18 time = 0 # 畫出地面直線 G = vector([0, -0.5]) panim.ground(G, vector([0, 1]), 10) # 連桿長度與角度計算 A = t*omega # \"theta\" AD = length_bar1 #length of left bar AB = length_base #distance between two stationary pivots BC = length_bar3 #length of right bar CD = length_bar2 #length of middle bar BD = math.sqrt(AD*AD + AB*AB - 2*AD*AB*math.cos(A)) C = math.acos((BC*BC + CD*CD - BD*BD)/(2*BC*CD)) ABD = math.asin(CD * math.sin(C) / BD) DBC = math.asin(AD * math.sin(A) / BD) B = ABD + DBC D = math.pi - B - C # draw pivot pivot_left = vector([AB/-2, 0]) pivot_right = vector([AB/2, 0]) panim.pivot(vector([pivot_left.e(1), -0.5]), pivot_left, 0.5) panim.pivot(vector([pivot_right.e(1), -0.5]), pivot_right, 0.5) # 儲存轉換矩陣 panim.save() #FIRST BAR panim.translate(pivot_left) panim.rotate(A) panim.rod(vector([0,0]), vector([AD,0]), 0.25) panim.point(vector([0,0])) #SECOND BAR panim.translate(vector([AD,0])) panim.rotate(A*-1) #\"undo\" the original A rotation panim.rotate(D) #rotate by D only panim.rod(vector([0,0]), vector([CD,0]), 0.25) panim.point(vector([0,0])) #THIRD BAR panim.translate(vector([CD,0])) panim.rotate(math.pi+C) panim.rod(vector([0,0]), vector([BC,0]), 0.25) panim.point(vector([0,0])) # 回復原先的轉換矩陣 panim.restore() panim.point(vector([pivot_right.e(1), 0])) # 時間增量 if direction == True: t += 0.08 else: t += -0.08 # 先畫出 t = 0 的連桿機構 draw() # 將 anim 設為 None anim = None def launchAnimation(ev): global anim # 初始啟動, anim 為 None if anim is None: # 每 0.08 秒執行一次 draw 函式繪圖 anim = timer.set_interval(draw, 80) # 初始啟動後, 按鈕文字轉為\"暫停\" doc['power'].text = '暫停' elif anim == 'hold': # 當 anim 為 'hold' 表示曾經暫停後的啟動, 因此持續以 set_interval() 持續旋轉, 且將 power 文字轉為\"暫停\" anim = timer.set_interval(draw, 80) doc['power'].text = '暫停' else: # 初始啟動後, 使用者再按 power, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停 # 且將 anim 變數設為 'hold', 且 power 文字轉為\"繼續\" timer.clear_interval(anim) anim = 'hold' doc['power'].text = '繼續' def reverse(ev): global anim, direction # 當 anim 為 hold 時, 按鈕無效 if anim != \"hold\": if direction == True: direction = False else: direction = True doc[\"power\"].bind(\"click\", launchAnimation) doc[\"reverse\"].bind(\"click\", reverse) 電腦輔助設計與實習課程核心 CAD 課程的重點是利用電腦輔助設計套件進行產品設計, 而 KMOLab 所使用的套件包含 Siemens NX, Solvespace 與 Onshape, 機電模擬系統則採用 CoppeliaSim. 下載 NX2027 lite 可攜版本 下載 Solvespace 3.1 版 for Windows 下載 CoppeliaSim 4.3.0 rev12 在 Onshape 建立教育版帳號. 因為電腦輔助設計與實習課程承接先前以 Brython 及 Python 為核心的計算機程式課程, 因此透過 python-solvespace 可以解 2D 設計約束條件, Python for NX 可以利用 NXOpen 中的 Python API 處理零組件設計, 利用 Onshape-clients 也能與 Onshape 零組件進行延伸互動. 當零組件設計繪圖完成後轉入 CoppeliaSim, 則可以利用 Python remote API 執行控制系統設計. 最終將完成的零組件設計與前述網站結合則除了透過 threejsFrontend 外, 也可自行利用 Pyweb3d 完成. 以下為電腦輔助設計與實習課程 2a 修課學員的個人倉儲靜態網頁連結: # 從 Brython 的 browser 模組導入 document 與 html 程式庫 from browser import document, html # 利用 document 物件, 以索引 \"brython_div3\" 取得已經位於 html 網頁中 id=\"brython_div3\" 的位置, 且對應到 brython_div3 變數 brython_div3 = document[\"brython_div3\"] # 可以用三個單引號或三個雙引號標註多行註解 # 其中的 html 物件有許多建立 html 超文件內容的方法, 以下分別建立 # BUTTON 按鈕, BR 跳行 (break), 以及 A 網站連結 (Anchor) # <= 是 Brython 程式語言的特殊符號, 專用於將 html 超文件資料送給網頁對應變數 \"\"\" brython_div3 <= html.BUTTON(\"hello\") brython_div3 <= html.BR() brython_div3 <= html.A(\"google\", href=\"https://google.com\") \"\"\" try: c = document.query[\"c\"] except: c = \"1a\" c = \"2a\" # 將 1b.txt 資料從 Github Pages 網頁中取下 url = \"https://mde.tw/studlist/2022fall/\" + c + \".txt\" # 利用 open() 開啟網頁, 利用 read() 讀取網頁內容 # 然後利用 split() 方法, 利用跳行符號對資料進行切割, 切割後的資料結構為 list # list 資料結構以 [] 區隔, 表示資料為數列, 其起始的索引值為 0 data = open(url).read().split(\"\\n\") # 將每一位學員的靜態網頁共同的網路連結部分設為字串, 且與 mdecad2022 變數對應 mdecad2022 = \"https://mdecad2022.github.io/site-\" # 因為取下的資料第一筆為標題, 而最後一筆為空字串, 可以利用 Brython 的數列索引取值範圍將索引 0 與最後一個數列值去除 data = data[1:-1] # 利用 for 重複迴圈逐一取出 data 數列中的值, 然後以 \\t, 也就是 tab 符號切割 count = 0 for i in data: count += 1 stud = i.split(\"\\t\") # 第一欄位為學號 stud_num = stud[0] # 第二欄未為 github 帳號 try: github_acc = stud[1] #print(stud_num, github_acc) # 若沒有找到 github 帳號, 以學號作為帳號 except: github_acc = stud_num # 將靜態網頁共同連結的變數與各自的 github 帳號, 組成完整的各學員靜態網頁連結 site = mdecad2022 + github_acc # 利用 A 物件產生連結, 然後放入 id=\"brython_div21 所在的網頁位置 link = html.A(stud_num, href=site) brython_div3 <= link # 每一筆資料列出後, 以 break 標註跳行 # 每一行列出五筆資料後, 跳行 brython_div3 <= \" \" if count % 5 == 0: brython_div3 <= html.BR() 以下為電腦輔助設計與實習課程 2b 修課學員的個人倉儲靜態網頁連結: # 從 Brython 的 browser 模組導入 document 與 html 程式庫 from browser import document, html # 利用 document 物件, 以索引 \"brython_div3\" 取得已經位於 html 網頁中 id=\"brython_div3\" 的位置, 且對應到 brython_div3 變數 brython_div3 = document[\"brython_div4\"] # 可以用三個單引號或三個雙引號標註多行註解 # 其中的 html 物件有許多建立 html 超文件內容的方法, 以下分別建立 # BUTTON 按鈕, BR 跳行 (break), 以及 A 網站連結 (Anchor) # <= 是 Brython 程式語言的特殊符號, 專用於將 html 超文件資料送給網頁對應變數 \"\"\" brython_div3 <= html.BUTTON(\"hello\") brython_div3 <= html.BR() brython_div3 <= html.A(\"google\", href=\"https://google.com\") \"\"\" try: c = document.query[\"c\"] except: c = \"1a\" c = \"2b\" # 將 1b.txt 資料從 Github Pages 網頁中取下 url = \"https://mde.tw/studlist/2022fall/\" + c + \".txt\" # 利用 open() 開啟網頁, 利用 read() 讀取網頁內容 # 然後利用 split() 方法, 利用跳行符號對資料進行切割, 切割後的資料結構為 list # list 資料結構以 [] 區隔, 表示資料為數列, 其起始的索引值為 0 data = open(url).read().split(\"\\n\") # 將每一位學員的靜態網頁共同的網路連結部分設為字串, 且與 mdecad2022 變數對應 mdecad2022 = \"https://mdecad2022.github.io/site-\" # 因為取下的資料第一筆為標題, 而最後一筆為空字串, 可以利用 Brython 的數列索引取值範圍將索引 0 與最後一個數列值去除 data = data[1:-1] # 利用 for 重複迴圈逐一取出 data 數列中的值, 然後以 \\t, 也就是 tab 符號切割 count = 0 for i in data: count += 1 stud = i.split(\"\\t\") # 第一欄位為學號 stud_num = stud[0] # 第二欄未為 github 帳號 try: github_acc = stud[1] #print(stud_num, github_acc) # 若沒有找到 github 帳號, 以學號作為帳號 except: github_acc = stud_num # 將靜態網頁共同連結的變數與各自的 github 帳號, 組成完整的各學員靜態網頁連結 site = mdecad2022 + github_acc # 利用 A 物件產生連結, 然後放入 id=\"brython_div21 所在的網頁位置 link = html.A(stud_num, href=site) brython_div3 <= link # 每一筆資料列出後, 以 break 標註跳行 # 每一行列出五筆資料後, 跳行 brython_div3 <= \" \" if count % 5 == 0: brython_div3 <= html.BR() cmsimde cmsimde 是一套利用 Python 與 Flask 建立的網際內容管理系統. 利用 cmsimde 與 Github Classroom 配置使用者網站的複雜度, 其中大部分來自電腦輔助設計室的網路環境與自架伺服器都只部署在純 IPv6 的網路環境中. 其實 IPv6 網路協定早在 1995 年便已推出, 但台灣至今的 IPv6 的 網路部署 也僅達到將近 50%. 就連 github.com 截至目前的 git clone 與 git push 都還僅支援 IPv4. 因此在僅有 IPv4 的網路環境下, 或僅有 IPv6 的電腦輔助設計室與自架伺服器的各別協定使用, 都必須選擇性設定雙網路協定的代理主機. 上課時段將電腦輔助設計室直接連結到系主幹的目的, 是為了取得最大對外連線頻寬, 且避開許多錯誤設定的 IPv4 伺服器所造成的網路封包阻絕效應. 但其結果就是必須在純 IPv6 的網路環境中工作, 而當學員回到宿舍或其他網路連線條件下, 又幾乎都在 IPv4 的網路協定下工作, 為因應這兩種互不相容的網路環境, 最佳的設定就是使用兩套可攜的隨身系統, 分別在不同網路協定下運用. 道理雖然簡單, 但由於其他課程並未觸及 IPv6, 且即便在中華電信的網路連線下, 也並非全時提供 IPv6 網路環境, 因此造成許多初學者使用 cmsimde 網站與 Github 倉儲上的諸多困難. 要克服網路與電腦使用上的諸多問題, 唯一的方法就是先了解基本原理, 然後再逐步依照教學流程設定後, 仔細比對網路連線原理, 多多針對不同使用情境加以調適練習就可逐步熟悉各種設定細節. 使用 cmsimde 建立網站的另外一項瓶頸也來自子模組的使用, 最早將 cmsimde 用於 Github 倉儲與網站設定的背景是, 各使用者可以在既有 cmsimde 子模組的架構下, 透過 user.py 採 Blueprints 延伸各種網際內容管理或電腦輔助設計前後端流程的功能. 但隨著 Github Classroom、 MS Teams 與多種 CAD 套件的導入, 延伸程式的編寫門檻越堆越高, 這幾年的課程即便推展至 KMOLab 的協同產品設計課程, 進度也難以觸及 user.py 的範圍. 尤其最近幾年的手機軟硬體功能已經足以與電腦並駕齊驅, 將手機與平板的應用導入課程已經是必然的趨勢, 因此接下來必須進一步思考是否重新架構 cmsimde 與學員個人倉儲及網站的配置, 刪除子模組的配置, 直接以 cmsimde 目錄導入, 如此至少可以免除 ssh 與 https 網路協定的雙重設定, 以降低配置上的複雜度. stud.cycu.org 2022 Fall 由於 Heroku 取消免費帳號的使用, 且 Replit 的免費帳號資源過少, 導致在廣域網路上必須自行配置所有學員的動態網站伺服器, 也就是 stud.cycu.org 主機的啟用與配置. 為了讓兩百多名學員能在同一台伺服器上執行動態網站, 各學員必須遠端登入伺服器使用 shell script 指令, 並以 Filezilla 的 sftp 降低學員對 Linux 指令不熟悉所造成的檔案編輯與配置問題. 其中用來查核個人是否啟動 python3 server.py 的 ps 指令為 ps axo pid,comm,user | grep \"server.py\" 只是 Quota 與 port 使用權限的配置仍需進一步思考最佳管理模式. TCExam 2022 Fall 重啟線上考試後, 重新啟用 TCExam, 目前正朝讓各學員自行出複選題目建立題庫的可行性.","tags":"cad2022","url":"./2022_fall_courses_w8.html"},{"title":"2022 Fall w7","text":"2022 Fall 課程進入第七週, 隨著一台 HP 大主機的硬碟毀損, 原本的課程教學流程必須隨之改變. 代理主機升級 進入代號 4 的主機, 希望將 LTS 20.04 升級為 22.04, 其生命週期可以橫跨 2026.02, 因為 EOL 為 2027.04. 步驟如下: sudo apt update sudo apt upgrade sudo apt autoremove sudo reboot lbs_release -a sudo do-release-upgrade 由於代號 4 的主機允許外部電腦連接用的代理任務, 因此更新之前, 先將系統備份後進行. 代號 4 的代理主機透過 dstdomain , 將 cycu.org 的連線納入. DNS 伺服器 目前 代號 3 為 mde DNS, 代號 2 為 mde 備份 DNS, 代號 6 為 eng DNS, 代號 7 則為 eng 備份 DNS. 之前 2 and 3 已經升級為 22.04, 但 6 目前仍為 20.04.","tags":"cad2022","url":"./2022_fall_cad2022_w7.html"},{"title":"2022 Fall w6","text":"2022 Fall 課程進入第六週, 原本只在近端運作的個人倉儲動態網頁, 這學期可以利用 Replit 與自建的 Ubuntu 伺服器執行, 只是學員必須適應在不同平台上執行程式的挑戰. 使用雲端免費資源教學 一直以來的課程教學都希望採用與業界相同的工具及系統, 其中包括 Github, Gmail, Microsoft 365 等工具, 還好這些工具都提供免費帳號註冊, 而且提供的權限與資源都能符合教學需求. 但若希望使用業界的 Application Server, 因為耗費的資源較多, 當 Heroku 在 2022 年宣布不再提供免費資源後, 雖然轉向 Replit, 但是由於免費帳號的 Replit 所提供的 CPU 運算時間與記憶體並非如 Heroku 優渥, 因此只能作為測試使用. 解決之道就是自行架構 Server, 讓所有學員能夠執行網際程式, 然後再設法與 Github 倉儲保持同步, 如此就能補足 Heroku 無免費帳號使用, 而 Replit 免費帳號不敷使用的問題. 疫情下的教學 這個月是台灣對外全面解封的時間點, 在更早之前, 已經有不少學員因疫情無法實體上課, 因此自 w3 開始, 即便在電腦輔助設計室實體上課, 但採用的模式與 remote 上課相同, 即時上課之外, 也將每一堂課的教學影片存檔, 以方便學員在任何地方同步或非同步上課. 另外與前幾年不同的教學方式, 是又重啟 TCExam 作為課程線上考試的系統, 這個系統應該比任何能夠買到的封閉源系統都更有彈性, 唯一的限制就是尚無 OAuth2 登入系統, 而且因為原始開發者已經不再積極維護原始碼, 所以必須自行讓老舊的 PHP 程式與資料庫連結系統, 在最新的系統中執行. 至於先前一直使用的 Ethercalc, 在配置的舊電腦無法開啟後, 已經無法在最新的 node.js 中運行, 目前只能暫時棄用, 因為開發者在忙著成立數位發展部, 應該沒有時間關心這項議題. 之後若有時間再設法修改處理. cp2022 2022 的計算機程式仍從 Brython 教起, 配合 Javascript 與 html, 希望使用者能夠透過 Canvas 與 WebGL, 了解 Web based 前端程式如何進行 2D 與 3D 系統的模擬, 2D 的部分先前已經做過貪食蛇與俄羅斯方塊遊戲, 而 3D 的部分則必須使用 three.js 程式庫, 主要目的是希望能夠用來解析機械零組件的 STL 檔案, 其中牽涉 ASCII 格式與 Binary 格式檔案的讀取與 WebGL 展示. 而銜接 Brython 前端程式的後端 Server 程式, 仍希望採 Python + Flask 的架構進行, 其間的變數傳送將透過 WebSocket 進行. 且儘可能透過 cmsimde 架構下的 Blueprint 進行延伸. 之後, 假如學員能在 Brython 與 Python 的前後端程式架構下, 再進行延伸, 則可以透過 C 編寫程式庫, 或將 Server 端的 Python 轉為 Cython, 或者可以轉進 Rust 程式語言的全新領域. cad2022 與先前的課程相同, 採用的 MCAD 分別為可自行編譯的 Solvespace, 雲端的 Onshape 與高階的 Siemens NX, 假如設計的機構零件外型是在初始設計階段, Solvespace 即可勝任參數式零組件繪圖與設計分析的工作. 比較可惜的是, 目前 Solvespace 尚不支援直接利用程式建構零組件, 使用者倒是可以透過程式建立零件的草圖, 然後匯入 Solvespace 後, 再長出 3D 外形. 至於 Onshape, 雖然使用者可以直接利用瀏覽器、平板或手機建立零組件, 但其能讓一般使用者進行零件 API 的部分, 僅限 Featurescript, 後端的 API 還需要申請授權碼才能進行. Siemens NX 一直以來都是包含 CAD/E/M 的大套工具, 其中最值得與 cp2022 計算機程式結合應用的部分是其 NXOpen 支援 Python 延伸程式的架構, 使用者可以在一台 Windows 操作系統上安裝 Siemens NX2027, 然後利用 NXOpen Python 編寫延伸程式, 透過 run_journal.bat 執行, 並且透過 Flask 與 WebSocket 從網際前端傳送設計變數, 然後在 Server 端結合 NX 運算後, 將前端設計所需尺寸或架構的產品零組件檔案, 讓使用者下載. 在結合 Python 與 NX 的過程中, 可以再設法直接從產品組立件所轉出的 STL 零件, 透過 API 程式組成 CoppeliaSim 系統模擬所需的檔案格式, 以便接續進行零組件的控制系統設計與模擬流程. 此外, cad2022 希望能將先前建構的手足球系統, 套用到 CoppeliaSim 的 Visualization Stream 功能上, 讓位於不同電腦的使用者可以透過不同埠號對同一個手足球場景進行控制, 可進行的模式分為 human vs human, human vs computer, 以及 computer vs computer 的對陣模式.","tags":"cad2022","url":"./2022_fall_cad2022_w6.html"},{"title":"2022 Fall w4-w5","text":"2022 Fall w4 繼續說明網路設定與個人網頁維護. 2022 Fall w5, 為每位學員在 stud.cycu.org 建立帳號. 建立帳號指令檔案 自 w4 起, 利用一台 Ubuntu 虛擬主機建立各學員帳號, 並且利用雙埠號派送方式 (內部為 9xxxx, 外部為 8xxxx), 讓各學員得以利用 https://stud.cycu.org 符號名稱執行個人倉儲中的動態網頁, 如同 Replit 上的雲端系統, 使用者可以將此動態網站內容與個人 Github 倉儲中的靜態網頁同步. 各學員擁有動態網頁與靜態網頁的目的, 在能透過伺服器上的 Python 程式與靜態網頁上的 Brython 前端程式進行互動, 將之後進行電腦輔助設計與實習過程中的歷程整理在網頁上外, 還能透過 NX2027 NXOpen 與 CoppeliaSim Remote API 程式編寫各種電腦輔助設計延伸程式. with open(\"2022_fall_ubuntu_account_pass.txt\") as f: data = f.readlines() # newusers format: # pw_name:pw_passwd:pw_uid:pw_gid:pw_gecos:pw_dir:pw_shell # uid starts from 1002 uid_starts = 1001 users = \"\" send = \"\" for i in data: #stud_num \\t account \\t password \\n stud = i.split(\"\\t\") stud_num = stud[0] account = stud[1] password = stud[2].rstrip() uid_starts += 1 uid = str(uid_starts) gid = uid gecos = account home_dir = \"/home/\" + account shell = \"/bin/bash\" #print(stud_num, account, password) users += account + \":\" + password + \":\" + uid + \":\" + gid + \":\" + gecos + \":\" + home_dir + \":\" + shell + \"\\n\" send += stud_num + \":\" + account + \":\" + password + \"\\n\" with open(\"users.txt\", \"w\", encoding=\"utf-8\", newline='\\n') as f: f.write(users) with open(\"send.txt\", \"w\", encoding=\"utf-8\", newline='\\n') as f: f.write(send) 帳號派送 從 @nfu 電子郵箱中可以收到各學員在 stud.cycu.org 伺服器中的登入帳號與密碼. 在 Windows cmd 命令提示字元視窗中, 可以利用: ssh 帳號@stud.cycu.org 登入伺服器. 進入後, 必須先設定 git 指令的代理主機: git config --global http.proxy \"http://p42.cycu.org:3128\" 完成後, 就可以利用 git clone --recurse-submodules https://github.com/mdecad2022/site-Github_帳號.git 取下倉儲內容. 以 cd site-Github_帳號, 可以進入倉儲根目錄, 然後設法利用 vi 建立 server.py 或者在 Windows 環境建立後, 以 sftp 送至倉儲根目錄. server.py 的內容如下: from waitress import serve from cmsimde import flaskapp # 9xxxx is for localhost internal connect port # 8xxxx is for Stunnel accept port serve(flaskapp.app, listen='127.0.0.1:您所分配的_127.0.0.1_埠號', threads=4) 然後在倉儲根目錄, 執行 python3 server.py, 就可以在 https://stud.cycu.org:您所分配的_stud.cycu.org_埠號 擷取到倉儲的動態網站, 以 config 修改管理者密碼後, 即可對此動態網站進行改版, 改版後轉靜態網站資料後, 就可以在 Ubuntu 上先利用 Token 將倉儲改版資料以 acp script 傳至 Github: source acp \"提交字串\" for linux and Max #! /bin/bash # bash script for Linux and Mac # chmod u+x acp # source acp \"commit message\" git add . git commit -m \"$1\" git push cms for linux and Mac #! /bin/bash # for Linux and Mac # chmod u+x cms # source cms python3 cmsimde/wsgi.py 利用 chmod u+x acp 讓 acp 可以執行. 之後要執行 acp: source acp \"提交字串\" Ubuntu SSH 以 ssh-keygen 建立 private and public keys, 存放於 .ssh 目錄下, 以 sftp 取下 id_rsa.pub 放入 Github 後, 就可以利用 SSH 對 Github 倉儲改版. .ssh/config 設定 Proxy: 設定之前管理者必須先安裝 ncat: sudo apt install ncat Host 等同為 Putty SSH 設定中的 sesstion 名稱. Host github.com User git Hostname github.com ProxyCommand /usr/bin/ncat --proxy p42.cycu.org:3128 --proxy-type http %h %p 若採用上述設定, 則以 scrum-1 github 帳號用戶為例, 使用 SSH 協定 git clone 個人位於 mdecad2022 帳號下的 site-scrum-1 倉儲指令為: git clone --recurse-submodules git@github.com:mdecp2022/site-scrum-1.git, 若將 .ssh/config 檔案, 且 git clone 後倉儲中的 .git/config url 為: git@github.com:mdecp2022/site-scrum-1.git 若 .ssh/config 中的 Host 設為 scrum1, 則 git clone 的指令將成為: git clone --recurse-submodules git@scrum1:mdecp2022/site-scrum-1.git, 而 git clone 後倉儲中的 .git/config url 為: git@scrum1:mdecp2022/site-scrum-1.git 參考: 1. Ubuntu ssh 2. ssh proxy 埠號分配 stud.cycu.org 伺服器中, 已經按照 port table 對每位學員所能使用的 127.0.0.1 與 stud.cycu.org 埠號進行分配. stunnel 服務重新啟動: sudo /etc/init.d/stunnel4 restart 以系統服務設定 stunnel4: sudo systemctl enable stunnel4.service cp2022 w4 教學影片 cadlab 網路設定, 取下個人倉儲, 計算機程式學習順序 (for @nfu users only) 在 Replit 執行動態網頁, 並與 Github 倉儲內容同步 (for @nfu users only) 網路設定與可攜程式系統 (for @nfu users only) 利用 diagrams.net 繪製流程圖, 說明可攜系統批次檔案內容 (for @nfu users only) Github token, SSH 與 Brython 抽點程式說明 (for @nfu users only) cp2022 w5 教學影片 利用 random 模組編寫亂數密碼產生程式教學影片 (for @nfu users only) 如何在 Windows 以 Putty 利用 SSH 協定對 Github 倉儲改版提交推送 (for @nfu users only) 如何利用 cms 執行動態網站, 改版後以 acp 將靜態網頁推向 Github Pages (for @nfu users only) 如何設定 SSH 與 https 協定, 對個人倉儲改版 (for @nfu users only) cad2022 w4 教學影片 下載可攜系統, 建立 exam.cycu.org 考試帳號 (for @nfu users only) Replit 執行動態網站, 如何與 Github 倉儲同步 (for @nfu users only) 近端可攜環境準備 (for @nfu users only) cmsimde 改版, Replit 套用新倉儲版本 (for @nfu users only) cad2022 w5 教學影片 如何在 stud.cycu.org Ubuntu 伺服器上執行動態網站, 如何將改版的靜態網頁推向 Github Pages (for @nfu users only)","tags":"cad2022","url":"./2022_fall_cad2022_w5.html"},{"title":"有關 Leo Editor","text":"終於 Leo Editor 也到了轉型的關鍵點, 準備 透過 leojs 開啟新的一頁. Node.js vscode and leojs 下載 可攜 Node.js + vscode + leojs References: Leo is complete","tags":"Leo Editor","url":"./2022_fall_about_leo_editor.html"},{"title":"伺服器與版本","text":"2022 Fall 計算機程式及電腦輔助設計與實習等兩門課程, 總共牽涉 github, onedrive, mail2000, replit, onshape, gmail 等廠商提供的伺服器, 另外還有自架的 Flask 伺服器. 廠商提供的伺服器 github, onedrive, mail2000, replit, onshape, gmail 等廠商提供的伺服器中, 只有 mail2000 由學校購買, 其餘都使用免費帳號, 之所以免費, 是以使用歷程換來的. 可想而知, 各廠商所提供的免費帳號都有許多限制, 其中 replit 雖然使用方便, 但所能取得的免費資源有限, 當使用頻率較高時, 經常會無法連線. 至於自架的 Flask server, 因為硬體在校內工作站室, 偶爾會有斷電與主機故障的問題, 但正常運作下, 仍然比雲端許多免費帳號下的伺服器好用許多. 自架 Server 假如要以自己架設的伺服器來取代 Replit, 第一步是如何在 Ubuntu 22.04 Server 上建立每位學員的帳號. 使用 newusers 指令, 配合建立一個包含帳號、密碼、uid、gid、comment、home dir 以及 shell (/bin/bash) 資料的 users.txt, 然後使用 sudo newusers users.txt 就可以完成所有學員帳號的建立. 但必須要先取得初始 uid, 也就是列出現有帳號的所屬 uid, 然後才能設定後續代號的 user id. 列出現有帳號 uid 的指令為: cut -d: -f1,3 /etc/passwd 表示要從 /etc/passwd 檔案, 以 : 符號分割檔案, 然後只取出第一與第三欄位的資料. 假如傳回: root:0 daemon:1 bin:2 sys:3 sync:4 games:5 man:6 lp:7 mail:8 news:9 uucp:10 proxy:13 www-data:33 backup:34 list:38 irc:39 gnats:41 nobody:65534 _apt:100 systemd-network:101 systemd-resolve:102 messagebus:103 systemd-timesync:104 pollinate:105 sshd:106 syslog:107 uuidd:108 tcpdump:109 tss:110 landscape:111 usbmux:112 tcexam:1000 lxd:999 postgres:113 tcexamdb:1001 cad2022:1002 stunnel4:998 cd1:1002 cd3:1003 表示新建帳號的 uid 與 gid 就可以從 1004 開始, 然後連續增量後配給新的用戶. IP 位址或埠號分配 當各學員在一台 Ubuntu 22.04 Server 上擁有帳號 (最理想的情況是用 Email 通知其主機資訊與帳號密碼) 之後, 隨即可以利用 ssh 進行遠端登入. 進入 Ubuntu 操作系統後, 就能夠利用 git clone 取下課程倉儲, 然後利用 python3 cmsimde/wsgi.py 執行動態網頁, 若各學員能夠從 port 8000 - 9000 之間進行分配區隔, 只要各學員配合修改 init.py 中的 IP 與 port 設定後, 就可以分別以自架主機取代 Replit. waitress 直接利用 Python3 執行 wsgi.py 儘管可以讓使用者登入編輯動態網站, 但效率並沒有 wsgi 模式高, 因此若能採用 waitress 的方式啟用動態網頁, 應該是較好的做法. 但 https 對外連線仍需透過 Stunnel 或 Nginx 銜接完成. 這時, 只要在倉儲根目錄建立 waitress_server.py from waitress import serve from cmsimde import flaskapp serve(flaskapp.app, listen=\"127.0.0.1:9443\") 然後 stunnel.conf 搭配設定: [https] accept = stud.cycu.org:443 connect = 127.0.0.1:9443 cert = fullchain.pem key = privkey.pem TIMEOUTclose = 0 就可以在 python3 waitress_server.py 執行下, 讓外部以 https://stud.cycu.org 連結到對應的動態網頁. 在此的問題是, waitress_server.py 如何以 service 啟動, stunnel 如何搭配執行. 最簡單的情況是 Stunnel 先以 service 執行, 但事先納入所有學員的規劃 port, 其中包括內容 port 以及外部 port, 並且讓學員在需要編輯動態網頁的時候, 自行啟動各自的 waitress_server.py 利用 Python 取 IPv6 網路位址: import socket ip = socket.getaddrinfo(\"stud.cycu.org\", 0, socket.AF_INET6)[0][4][0] print(ip) Virtualbox 虛擬主機 利用一台 16 核 80 GB 記憶體的虛擬主機, 建立約 250 個用戶後, 看能否透過 Stunnel 與 wsgi 啟動各自的 cmsimde 動態網站. 為了建立多用戶帳號, 可以利用 newusers 指令, 配合 users.txt 檔案: users.txt 檔案格式, 分別是: 使用者帳號, 預計使用 cad 加上學號, 或者是 cp 加上學號, 而密碼可以採用亂數產生, 至於 uid 與 gid 則需先使用 cut -d: -f1,3 /etc/passwd 查詢現有帳號的對應 id 後, 再逐一利用迴圈增量. 至於 comment 欄位, 可以直接採用 cad 或 cp 加上學號, 而 shell 欄位則選用 /bin/bash user_1:password_2:1002:1002:user_1:/home/user_1:/bin/bash sudo newusers users.txt 依照上述流程建立帳號後, 可以保留使用者學號、帳號與對應密碼, 然後利用 Gmail 將此訊息郵寄給各用戶. 至於透過程式方法必須完成下列事項: 建立 users.txt, 然後傳送至虛擬主機 利用 sudo newuser users.txt 建立各用戶帳號與 home directory 建立 users_account.txt, 包含與 users.txt 各用戶帳號與密碼資訊 利用 Gmail 逐一將 users_account.txt 的帳號與密碼資訊寄給用戶 password generator Brython 版 password generator . import random import string def password_generator(size=4, chars=string.ascii_lowercase + string.digits): \"\"\"Generate random password \"\"\" return ''.join(random.choice(chars) for _ in range(size)) pass_string = \"abcdefghkmnpqrstuwxyz123456789\" for i in range(10): print(password_generator(4, pass_string)) 2022 Fall 課程代號 首先要建立各課程對應的 Ubuntu 帳號與密碼檔案: # 導入亂數模組 import random # 導入字串模組 import string # 利用 def 關鍵字定義函式 # 函式的輸入變數可以設定初始值 def password_generator(size=4, chars=string.ascii_lowercase + string.digits): # 函式內以多行註解說明函式功能 \"\"\"Generate random password \"\"\" # 利用 return 關鍵字將所產生的亂數字串傳回 return ''.join(random.choice(chars) for _ in range(size)) # 建立一個變數與隨後的字串對應 pass_string = \"abcdefghkmnpqrstuwxyz123456789\" cp_num = [\"0747\", \"0761\"] cad_num = [\"0773\", \"0786\"] def gen_acc_pass(course, course_num): stud_list =[] for num in course_num: url = \"https://nfu.cycu.org/?semester=1111&courseno=\" + num + \"&column=True\" class_list = open(url).read().split(\"\\n\")[:-1] stud_list += class_list #print(stud_list) for stud_num in stud_list: password = password_generator(4, pass_string) #print(password) account = course + stud_num #print(account) print(stud_num + \"\\t\" + account + \"\\t\" + password) gen_acc_pass(\"cp\", cp_num) gen_acc_pass(\"cad\", cad_num) Windows 與 Ubuntu 格式差異 create_users_txt.py with open(\"2022_fall_ubuntu_account_pass.txt\") as f: data = f.readlines() # newusers format: # pw_name:pw_passwd:pw_uid:pw_gid:pw_gecos:pw_dir:pw_shell # uid starts from 1002 uid_starts = 1001 users = \"\" send = \"\" for i in data: #stud_num \\t account \\t password \\n stud = i.split(\"\\t\") stud_num = stud[0] account = stud[1] password = stud[2].rstrip() uid_starts += 1 uid = str(uid_starts) gid = uid gecos = account home_dir = \"/home/\" + account shell = \"/bin/bash\" #print(stud_num, account, password) users += account + \":\" + password + \":\" + uid + \":\" + gid + \":\" + gecos + \":\" + home_dir + \":\" + shell + \"\\n\" send += stud_num + \":\" + account + \":\" + password + \"\\n\" with open(\"users.txt\", \"w\", encoding=\"utf-8\", newline='\\n') as f: f.write(users) with open(\"send.txt\", \"w\", encoding=\"utf-8\", newline='\\n') as f: f.write(send) 假如沒有採用 newline='\\n', 在 Windows 寫檔案所使用的跳行符號, 以 sftp 傳到 Ubuntu 時將會因為 shell 並非 /bin/bash 而是加上 &#94;M$ 的錯誤 shell 資料, 導入用戶無法 login. 若要修正跳行符號錯誤, 可以採用: change_shell.py import os with open(\"users.txt\", \"r\", encoding=\"UTF-8\") as f: data = f.read().splitlines() for i in data: account = i.split(\":\")[0] print(account) os.system(\"sudo chsh -s /bin/bash \" + account) 當執行上列程式時, 為避免在程式中列出管理者密碼, 可以編輯 /etc/sudoers 並加入: # only require a password once every 60 minutes Defaults timestamp_timeout=60 可以讓 sudo python3 change_shell.py 執行時無需輸入管理者密碼. Stunnel /etc/default/stunnel4 需要加入 ENABLED=1 才能讓 stunnel4 與伺服器同時啟動, 重新啟動則使用 sudo /etc/init.d/stunnel4 restart 當伺服器運作期程結束, 可以在 /etc/sudoers 已經納入 timeout 設定後, 利用 python3 del_users.py 刪除對應的使用者與其用戶目錄. import subprocess \"\"\" /etc/sudoers vi /etc/sudoers use w! to write the read only file add the following to sudoers # only require a password once every 60 minutes Defaults timestamp_timeout=60 use sudo python3 del_users.py to delete users and their home directories \"\"\" with open(\"users.txt\", \"r\") as f: data = f.read().splitlines() #print(data) stud_list = [] for i in data: stud_num = i.split(\":\")[0] #print(stud_num) stud_list.append(stud_num) for user in stud_list: try: subprocess.run([\"sudo\", \"userdel\", \"-r\", user], check=True) print(str(user) + \" deleted!\") subprocess.run([\"sudo\", \"rm\", \"-rf\", f\"/home/{user}\"], check=True) print(str(user) + \" home deleted!\") except subprocess.CalledProcessesError: print(str(user) + \" is not deleted!\") 其中的 users.txt 就是前面用來建立用戶帳號的設定檔案.","tags":"Server","url":"./2022_fall_cad2022_server _and_version.html"},{"title":"cad2022 第三週課程","text":"電腦輔助設計第三週課程內容. 各教學影片均需透過 @nfu 登錄的 Onedrive 帳號登入後, 才能觀看. 個人課程網頁設定 教學影片: 課程倉儲與 Github Pages 設定說明 Replit and Github 教學影片: 建立 Replit 帳號, 並將課程倉儲 import 至 Repl 專案 教學影片: Replit 動態網站與 Github 倉儲同步 課程筆記 第三週內容摘要: 透過 mdecad2022 的 organization 建立個人可以管理的倉儲 (名稱為 site-Github_帳號). 利用 replit 帳號所啟動的動態網站進行內容管理. 將動態網站內容轉為靜態網站內容之後, 設法與 Github 倉儲同步. 之後申請帳號都使用 @nfu 電子郵箱登記並收信 (可從 https://mail.nfu.edu.tw 登入) 修補課程網站安全疑慮 目的: 不想讓 config/config 帶有編碼後的管理者密碼, 直接公開在 Github 倉儲歷程中. 執行步驟: 必須先在個人的 mdecad2022/site-github_帳號 倉儲進行處理. 接著刪除 config/config 設定檔案. 修改 .gitignore 成為: https://raw.githubusercontent.com/mdecad2022/site-41023242/main/.gitignore 加入 main.py: https://raw.githubusercontent.com/mdecad2022/site-41023242/main/main.py 在倉儲根目錄加入 nocache.py, 內容如: https://github.com/mdecycu/cmsimde/blob/2a41b26b6d9b1446a8b448bb6fb58a6dbb41c867/nocache.py 之後再設法以 import 方式, 利用個人課程倉儲內容在 replit 建立 Repl 專案. 在 Replit 執行動態網站: 必須進入 Shell, 在倉儲根目錄執行下列兩則指令 (取下子模組內容, 並安裝執行所需模組). git submodule update --init --recursive pip install flask flask_cors bs4 lxml pelican markdown gevent 2b 開始在 https://exam.cycu.org 建立考試帳號.","tags":"cad2022","url":"./2022_fall_cad2022_w3.html"},{"title":"cp2022 第三週課程","text":"計算機程式第三週課程內容. 各教學影片均需透過 @nfu 登錄的 Onedrive 帳號登入後, 才能觀看. 針對 Proxy 設定無法存檔 有關電腦輔助設計室中, 代理主機設定無法存檔的問題, 可以參考 cp2022 w3 cadlab 網路設定影片 (必須登入 @nfu Teams 帳號) 中的說明, 主要設定流程為直接進入 Windows Registry 進行設定後, 將設定內容匯出為 .reg 檔案後, 放入隨身碟, 下一次重新開機後, 可以利用滑鼠左鍵雙點擊 .reg 檔案, 就可以完成自動設定. 下載 cadlab_network_setup.zip 網誌與課程內容回顧 教學影片: 課程網誌製作與先前課程內容回顧 ethercalc 登錄與 RDT 教學影片: ethercalc登錄 Github 帳號 - 遠端桌面與虛擬主機介紹 https://ethercalc.net/ 倉儲與 Github Pages 教學影片: 課程倉儲與 Github Pages 網頁設定教學 從教務主機擷取學員名單 原先配置在 Heroku 的 [nfulist] 網際程式, 由於校務主機已經排除台灣境外網段連接, 且 Heroku 也即將終止免費帳號使用. 因此只能將程式配置在系工作站室中的電腦. 程式如下, 目前以 Ubuntu 22.04 實體主機下的 Virtualbox Win10 虛擬主機運行. 採 waitress 模式配置, 以 nssm 安排成為系統服務. # 以 Flask 作為網際框架, from flask import Flask, request # 允許跨網站擷取資料 from flask_cors import CORS # 利用 requests 取回網站中的頁面資料 import requests # 利用 beautifulsoup 解讀超文件網頁內容 import bs4 # 若在近端啟動也要採用 SSL 時導入 #import ssl ''' 2022 Fall 各班課程代號 1a - 2b ?semester=1111&courseno=0747&column=True ?semester=1111&courseno=0761&column=True ?semester=1111&courseno=0773&column=True ?semester=1111&courseno=0786&column=True ''' proxies ={ 'http': 'http://account:password@[2001:288:6004:17::4]:3128', 'https': 'http://account:password@[2001:288:6004:17::4]:3128' } app = Flask(__name__) CORS(app) @app.route('/studlist') @app.route('/') def studlist(): semester = request.args.get('semester') courseno = request.args.get('courseno') column = request.args.get('column') if semester == None: semester = '1091' if courseno == None: courseno = '0762' headers = {'X-Requested-With': 'XMLHttpRequest'} url = 'https://qry.nfu.edu.tw/studlist_ajax.php' post_var = {'pselyr': semester, 'pseqno': courseno} # 可透過 Proxy server 執行程式 #result = requests.post(url, data = post_var, headers = headers, proxies = proxies) result = requests.post(url, data = post_var, headers = headers) soup = bs4.BeautifulSoup(result.content, 'lxml') table = soup.find('table', {'class': 'tbcls'}) data = [] rows = table.find_all('tr') for row in rows: cols = row.find_all('td') cols = [ele.text.strip() for ele in cols] data.append([ele for ele in cols if ele]) # Get rid of empty values output = \"\" for i in data[2:]: #print(i[0]) if column == \"True\": output +=i[0] + \" \" else: output +=i[0] + \"\\n\" return output #return str(pselyr) + \" + \" +str(pseqno) # 即使在近端仍希望以 https 模式下執行 #context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2) #context.load_cert_chain('localhost.crt', 'localhost.key') if __name__ == '__main__': app.run(host='127.0.0.1', port=8080, debug=True) 2022 Fall 學員名單: 1a 計算機程式修課學員名單 (取自教務主機) 1b 計算機程式修課學員名單 (取自教務主機) 2a 電腦輔助設計與實習修課學員名單 (取自教務主機) 2b 電腦輔助設計與實習修課學員名單 (取自教務主機)","tags":"cp2022","url":"./2022_fall_cp2022_w3.html"},{"title":"有關 CAD","text":"簡要說明 2022 Fall 與 CAD 有關的應用議題. 常見的 CAD 套件 Solidworks AutoDesk Inventor Solid Edge Siemens NX PTC Creo Dassalut Catia Onshape AutoDesk Fusion 360","tags":"CAD","url":"./2022_fall_about_cad.html"},{"title":"有關 PostgreSQL","text":"簡要說明 2022 Fall 與 PostgreSQL 有關的設定與應用議題. 教學影片 這一部 PostgreSQL 教學影片 應該非常適合初學者觀看學習, 配合內容逐步了解如何安裝 PostgreSQL, 設定與應用. 下載安裝 PostgreSQL 安裝檔案可以從 這裡 下載, 安裝包括: PostgreSQL Server pgAdmin 4 Stack Builder Command Line Tools data 目錄 database superuser: postgres postgres password database port: 5432 database service: postgresql-x64-14 disable Stack Builder download function 安裝結束後, postgresql-x64-14 服務將會自動執行. pg_ctl - initialize, start, stop, or control a PostgreSQL server","tags":"PostgreSQL","url":"./2022_fall_about_postgresql.html"},{"title":"有關網路","text":"簡要說明 2022 Fall 在綜一館八樓的電腦網路使用與觀察. 實際觀察 註: 以下的相關下載連結, 必須登入學校下載中心主機, 或者使用校內網路才能下載. 而各種教育版套件則必須透過校內 VPN 登入後, 才可進行認證. 為了方便, 接下來將要從學校下載目前可以取得的 1909 64 位元 Windows 10操作系統 (for nfu intranet only), 並且利用 Virtualbox 安裝為虛擬機. 因為這個教育版的 Windows 需要每半年進行認證更新, 因此還要同時下載 認證批次檔 (for nfu intranet only). 另外若要配合仍廣為流行的 MS Office, 可以再下載 Office 2016 (for nfu intranet only) 版, 以及認證用的 Office_2016_KMS.bat (for nfu intranet only). 下載 Windows 10 與 Office iso 畫面: Virtualbox 安裝 接下來利用 Virtualbox 安裝 Windows 10, 可以得到 Win10_2022_20H2.7z (for @gm users) ( Win10_2022_20H2.7z @nfu ) 檔案. 同一個 Virtualbox 應用程式下的虛擬硬碟檔案, 其 uuid 不可相同, 因此若直接從某一虛擬檔案複製在同一台 Virtualbox 進行設定之前, 必須更改其中一個檔案的 uuid. 更改硬碟檔案的 uuid: vboxmanage internalcommands sethduuid win10_21H2.vmdk 查詢虛擬硬碟檔案的 uuid: vboxmanage.exe\" showhdinfo win10_2022.vdi 刪除虛擬硬碟中的無用檔案 (通常已經在虛擬主機中, 將硬碟重組並刪除無用檔案後, 以 sdelete c: -z 將系統沒有使用的磁區, 逐一寫入 zero): vboxmanage.exe modifymedium --compact disk win10_2022.vdi 這裡必須特別注意的是: 目前 vboxmanage 只能對 .vdi 執行 compact, 不適用於 .vmdk 虛擬機檔案. NAT 上網 經過上述 Windows 10 虛擬主機安裝後, 得到 Win10_2022_20H2.7z (for @gm users) ( Win10_2022_20H2.7z @nfu ) 檔案, 可以在實體的 Windows 10 或 Ubuntu 操作系統中以 Virtualbox 若要在同一台實體主機設定源自同一虛擬主機檔案的多台電腦, 可以更改硬碟檔案的 uuid: vboxmanage internalcommands sethduuid win10_21H2.vdi 啟動 虛擬 Windows 10 之前, 查驗一下記憶體給定 4GB, 並且採用 NAT network 模式後開機. NAT 的網路設定就是讓虛擬機模擬以實體主機的網路卡作為 NAT 的對外通道, 讓虛擬機可以經由實體機的網路連線上網. NAT 這時可以視為虛擬主機的防火牆, 外部電腦在無 NAT port mapping 的情況下, 無法直接連線到虛擬主機. 更改硬碟檔案的 uuid: vboxmanage internalcommands sethduuid win10_21H2.vmdk 在使用 Windows 10 代理主機設定過程, 若發現無法手動儲存 Proxy 設定時, 可以將 Proxy 設定寫入: 電腦\\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer 字串值中. 也可以透過 Windows 10 登錄檔案 (Registry) 進行設定, 以滑鼠左鍵雙點擊下列 manual_proxy_setting.reg 即可完成設定: Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings] ; disable AutoDetect \"AutoDetect\"=dword:00000000 \"MigrateProxy\"=dword:00000001 ; enable Proxy \"ProxyEnable\"=dword:00000001 \"ProxyHttp1.1\"=dword:00000000 \"ProxyServer\"=\"http://[2001:288:6004:17::42]:3128\" \"ProxyOverride\"=\"localhost;\" NAT 內定使用 IPv4 當我們使用 Virtualbox Windows 10 虛擬主機, 利用 NAT 作為聯外網路設定時, default 只能使用 IPv4 網路協定. 假如要讓虛擬主機使用更有彈性的 NAT 網路機制, 可以從 Network 設定中轉用 NAT Network 設定, 首先在 Virtualbox Manager - File - Preferences - Network - NAT Networks 項目中新增一個 NATNetwork, 開啟 edit 編輯模式, 內部網段使用 10.0.2.0/24, 打勾 Support DHCP. 當虛擬主機關機後, 重新設定 Network 後重開後選用 NAT Network, 就可以使用此項設定. 因此, 假如同一台實體主機中有多台採 NAT 上網的虛擬主機, 就可以利用 NAT Networks 選擇各種內部網路協定與連線架構. 採用 NAT Network 設定的虛擬主機雖然也能透過 Port Forwarding 擔任伺服器, 但是只能與實體主機共用聯外的網路線, 假如要將虛擬主機當作 server, 且採實體網路線聯外, 可以將 Network 設為 Bridged Adapter. 虛擬主機 Win 認證 前面提到, 使用學校購買的 Windows 10 操作系統, 每半年必須在校網進行認證, 由於目前的認證設定主機只允許 IPv4 網路協定進行, 因此假如 Virtualbox 實體主機帶有外部 IPv4 網路位址, 附屬於其下的虛擬主機若無外部 IPv4 address 可以設定, 最佳認證方案是, 在既有的網路卡設定模式下, 新增一個採用 NAT Networks 網路卡 (一台虛擬主機最多可以新增 36 片虛擬網路卡), 就能以實體主機的 IPv4 作為 NAT 外部 IP, 而完成 Windows 10 操作系統的使用授權認證. 假如實體主機位於校外, 只要讓實體主機透過學校的 VPN 聯網, 然後再依上述 NAT Networks 方式進行第二片網卡的設定, 就可以每 180 天順利完成認證. Virtualbox 網路卡巡禮 接下來將要在同一台虛擬主機上啟動四片網路卡 (這是 GUI 介面允許的數量, 若要再增加必須使用設定檔案進行). 其中分別包括: NAT Network, Bridged Adapter, Internal Network 與 Host-only Network 等. NAT Network 使用時機 NAT Network 的使用前面已經提過, 可以讓虛擬主機透過實體主機的網路上網, 且 NAT 扮演防火牆的任務, 若要在虛擬主機中啟動伺服器服務, 則可以利用 Port Forwarding 的方式設定. 由於經過 NAT 之後是採實體主機的 IP 聯網, 因此若實體主機帶有 IPv4 協定位址, NAT Network 設定的虛擬主機可以順利完成 Windows 10 操作系統的使用授權認證. Bridged Adapter 使用時機 選用 Bridged Adapter 網路卡設定的目的在於讓虛擬主機可以對外擁有實體網路連線的頻寬, 最適合用於作為虛擬伺服器. 啟動橋接網卡後的虛擬主機網路定位與實體主機相同, 兩者可循同一條實體網路線聯網, 或者各自使用一條實體網路進行連接. Internal Network 使用時機 Internal Network 的基本運作機制與橋接網卡相同, 都能透過實體網路卡從虛擬主機聯外, 但不同點是, 橋接網卡設定後, 其網路位階與實體主機相同, 必須應付廣域網路上的各種封包, 彈性雖高, 但較不安全. 而 Internal Networks 設定的聯網機制是由 Virtualbox 自行設定, 且不一定要依附到實體網路連線. 假如設定過程需要實體主機下的 Internal Network 電腦群彼此連網, 但不聯外網, 就適合採用 Internal Network. Host-only Network Host-only Network 可視為 Bridged Adapter 與 Internal Network 的 Hybrid 設定模式, 就網路連線上, 可以如 Bridged Adapter 採實體網路線聯外, 並且具有 Internal Network 的特點, 彼此相連但與外網隔絕. 在進行上述四種網路設定過程, 可以針對需求開啟或關閉特定網路卡, 以便在不同實際需求下進行設定. 網路實況觀察 首先在虛擬主機中只開啟 Bridged Adapter, IPv4 與 IPv6 都採 DHCP 方式取得 IP 位址. 結果: 有一台 MAC 為 00-e0-98-29-9c-70 的硬體, 設為 192.168.1.1 啟動 DHCP server 在發送 192.168.1.X 內部 IP. 從 https://www.cleancss.com/mac-lookup/00-E0-98 可以查到這台硬體網卡的資訊: Devices with MAC addresses that start with 00-E0-98 were manufactured by AboCom Device Manufacturer AboCom Manufacturer Location 12F-3, NO. 333, SEC. 1 HSIN-CHU 12345 Estimated Devices using 00-E0-98 16,256,250 Estimated Total Devices From Mfg 48,768,750 根據判斷, 這應該是一台 Wifi Router, 誤將應該連接內部網路的接頭聯外. 至於 IPv6 的網段, 雖然成功從校方 DHCP 6 取得系上聯外 IPv6 位址, 但是該伺服器並沒有設定 DNS, 因此採 IPv6 網路協定自動擷取 IP 位址的電腦, 必須自行設定 DNS 伺服器.","tags":"Network","url":"./2022_fall_about_network.html"},{"title":"有關 Ubuntu","text":"簡要說明 2022 Fall 與計算機程式及電腦輔助設計與實習課程相關的 Ubuntu 伺服器安裝與設置. Ubuntu 目前使用 Ubuntu 20.04 與 22.04, 20.04 生命週期可以到 2025, 而 22.04 則可以到 2027, 其中主要安裝配置 Squid, Bind, Nginx, uwsgi 以及 Fossil SCM. 管理的網域有 mde.nfu 與 eng.nfu. 下載 Ubuntu 22.04 vdi Virtualbox 虛擬主機檔案. 基本指令 查 Ubuntu 操作系統的版本: lsb_release -a 更新 LTS 版本 sudo apt update sudo apt upgrade sudo apt autoremove sudo retoob sudo do-release-upgrade openssh-server 讓 Ubuntu 可以接受 ssh: sudo apt install openssh-server Squid 安裝 squid: sudo apt install squid 設定檔案位置: /etc/squid/squid.conf 重新啟動 squid: sudo /etc/init.d/squid restart ufw 以管理者身分執行指令: sudo -s 查驗 ufw 狀態 (以下各指令必須採管理者模式才能執行): ufw status 允許主機連線: 若允許單一主機連線所有 ports, 則直接列出完整的 IP addresses. 若涵蓋特定範圍, 則需加以標示, 以 IPv6 為例: 2001:xxxx:xxxx:: 表示前三區段為固定標示, 隨後的五個區段 以 :: 表示, 則涵蓋所有組合的 IPv6 addresses. ufw allow from 192.168.1.1 ufw allow from 2001:xxxx:xxxx::/24 只允許 IPv6 群組電腦經由 port 22 連線, 拒絕其他電腦連線: ufw allow from 2001:288:6004:xx::/32 to any port 22 ufw deny 22 令上述設定生效: ufw enable 其次, 若要刪除原先 ufw 的所有設定可以使用 ufw reset, 若要暫時關閉 ufw, 採用 ufw disable. 符號名稱的部分, 需要限制 port 22 連線外, 必須讓所有主機都能對 port 53 連線: sudo -s ufw status ufw allow from your_ipv4_or_ipv6_ip ufw allow from 2001:288::/16 to any port 22 ufw deny 22 ufw allow 53 ufw enable WWW 伺服器若採用 port 80 與 443 配置, 則需要對所有主機開放, port 5443 若執行 Fossil SCM, 也必須開放, 其他也是對 port 22 有連線範圍的限制. sudo -s ufw status ufw allow from your_ipv4_or_ipv6_ip ufw allow from 2001:288::/16 to any port 22 ufw deny 22 ufw allow 80 ufw allow 443 ufw allow 5443 ufw enable 其他參考範例: sudo -s ufw status ufw allow from 192.168.1.1 ufw allow from 2001:xxxx:d005::/24 to any port 22 ufw allow from 2001:288:6004:xx::/32 to any port 22 ufw deny 22 ufw allow from 2001:288:6004:xx::/32 to any port 3128 ufw allow from 2001:288:6004:xx::/32 to any port 3130 ufw deny 3128 ufw deny 3130 ufw allow 80 ufw allow 443 ufw allow 53 ufw enable ufw 刪除特定 rule 在 ufw enable 之後, 可以使用 ufw status numbered 列出 rules 順序編號, 然後再以: ufw delete 編號 刪除特定編號的 rule 後, 例如: ufw delete 21 而編號 21 的 rule 為 ufw deny 3389, 即除了前面所允許的主機網址可以對伺服器 3389 port 連線外, 其餘一律禁止連線, 此地則將 ufw deny 3389 刪除, 接著以: ufw allow from 2001:xxxx:d005::/24 to any port 3389 納入允許 3389 port 連線的主機網址範圍後, 再加上: ufw deny 3389 ufw enable 就等同額外在 port 3389 可連線的主機納入特定的電腦群之後, 再重新啟動防火牆. Ubuntu update 與 upgrade Ubuntu 各版次釋出後, 經常會有各種套件的更新與升級, 因此若要採手動 update 與 upgrade, 可以執行: sudo apt update sudo 是希望以 super user 的權限執行隨後的指令, 等同在 Windows 操作系統中以管理者模式執行指令的意思. 通常在牽涉操作系統內部套件安裝與設定修改時, 只能由管理員身分進行處理. 至於 apt 則為 Ubuntu 的套件管理工具, 可以用來安裝或移除套件. 而最後的 update 則是 apt 命令的一個 option, 表示要更新目前針對此一操作系統, 可以安裝的套件列表, 以及如何取得這些套件安裝的相關資訊. 完成 sudo apt update 之後, 就可以利用 sudo apt upgrade, 將所有已經安裝在操作系統中, 可升級的套件進行更新. 各套件更新升級後, 通常會留下一些目前版本沒有使用的舊檔案, 可以利用 sudo apt autoremove 加以移除. Ubuntu 的遠端桌面 Ubuntu 安裝 Desktop 版本之後, 可以加裝 xrdp, 並且允許遠端主機對 port 3389 連線, 就可以從其他操作系統電腦上, 以 Remote Desktop client 進行遠端連線: sudo apt install xrdp 在 Mac 操作系統上, 可以安裝 Microsoft Remote Desktop 套件對遠端的 Ubuntu 進行連線操控. 在 Ubuntu 則可以使用 Remmina 作為 Remote Desktop client. Add super user account 新增 username 帳號, 並授予管理者權限. sudo adduser username sudo usermod -aG sudo username Delete user account sudo deluser --remove-home account_name 列出 user id 列出現有帳號 uid 的指令為: cut -d: -f1,3 /etc/passwd 表示要從 /etc/passwd 檔案, 以 : 符號分割檔案, 然後只取出第一與第三欄位的資料. increase open file limits sudo vi /etc/sysctl.conf add fs.file-max = 2097152","tags":"Ubuntu","url":"./2022_fall_about_ubuntu.html"},{"title":"Enjoy your ride","text":"Being an entrepreneur is a bug. George Hatsopoulos You shouldn't lose sight of your purpose. 莫忘初衷. You learn a subject more by teaching it than anything else. 教授一門科目, 能學到的比其他任何東西都多. About teaching: I did it because it is fun. 關於教學: 這樣做是因為它很有趣. It's useful to set a certain direction you want to go. After you set the direction, don't focus in your goal. Focus in enjoying the ride. 設定想要達成的方向非常受用. 一旦方向確立, 不要專注於目標, 而應專注於享受過程. 有夠好先生 John Goodenough 先生今年正好滿一百歲, 在 1986 年轉到 UT Austin 機械系任教, 他不僅是至今獲頒諾貝爾獎最高齡紀錄保持人, 也是目前德州大學唯二之一的諾貝爾獎者鎮校之寶. 他的教研生涯堪稱有夠好!!","tags":"Video","url":"./enjoy_your_ride.html"},{"title":"2022 秋季學期第二週","text":"簡要說明 2022 Fall 與計算機程式及電腦輔助設計與實習課程的相關規劃與期程安排. 課程網站 目前將課程網站放在同一個倉儲, 相關連結可以參考 https://mde.tw/blog/pages/about/index.html . 現在 mde.tw 的倉儲容量大約 800 MB, 每次在新的環境重新 git clone --recurse-submodules 會有一些負擔, 但若使用隨身碟進行逐次改版, 應該還好. Fall 學期上的課程為大一的計算機程式, 還有大二的電腦輔助設計與實習. 計算機程式是從網頁上的 Python 語法教起, 採用的解譯器為 Brython , 終極目標是希望能夠利用 Brython 與 Three.js , 開發出類似 https://sim.firialabs.com/ 的網際套件, 直接在瀏覽器上透過 Brython 程式控制 Robot 模擬場景. 計算機程式課程學員可以直接從 https://mde.tw/content/Python.html 進入, 直接在線上練習 Brython 所支援的 Python 語法. 由於是在瀏覽器上, 必須要對 HTML 與 Javascript 有些基本認識, 才能充份使用 Brython . 學員在計算機程式課程所寫的程式, 被要求要設法放入自己管理的 Github 倉儲, 而倉儲是採用 Github Classroom 建立, 並且直接導入 cmsimde 子模組. 假如要將個人倉儲 git clone 到近端電腦上改版, 就必須使用: git clone --recurse-submodules 加上擷取倉儲內容的網路_URL 或 SSH 連線字串 假如第一階段只用 git clone, 而沒有 --recurse-submodules 附屬指令選項, 則可以在取下主倉儲內容後, 以 git submodule update --init --recursive 取下所有子模組的內容. 光是要能以 git 取下倉儲檔案, 使用者的近端電腦就必須能夠執行 git, 可以使用操作系統安裝版, 或者使用課堂上所推薦的可攜程式套件中的 portablegit . 至於要使用 https 或 ssh 協定進行 git, 主要牽涉到隨後改版 push 時的權限驗證, 因為只有具備倉儲管理權的用戶, 才能對 Github 上的倉儲進行改版. 網路協定 所有網路上的應用, 都牽涉網路協定, 以 https 而言, 所使用的網路協定就是 http, 也就是超文件傳輸協定. 而 https 就是在利用超文件傳輸的過程中, 將傳送的資料加以加密編碼後, 直到接收後再解開, 是相較於 http 嚴謹安全的傳送. 以 https 擷取 Github 倉儲的時候, 需要在 URL 中加上帳號 token , 而這串連線驗證身分用的字串, 還帶有權限範圍, 以及時效, 使用者可以在 Github 帳號設定頁中取得. 由於 Github 目前只支援 IPv4 協定, 而在電腦輔助設計室為了擴大可用頻寬, 採用 IPv6 協定, 要讓 IPv6 協定下的 git 指令, 正確與 Github 倉儲連線, 必須透過 Proxy server (使用 Squid ), 而且是能同時支援 IPv4 與 IPv6 協定的代理主機. 以 https 對 git 指令的 Proxy 設定, 位於可攜程式環境中的 home_ipv6 目錄下, 檔案名稱為 .gitconfig, 使用者執行 git config 後的設定就是存入 home_ipv6/.gitconfig 檔案中. 至於 git 所使用的 SSH 連線協定, 在 Windows 操作系統, 可以透過 Putty session 設定達成, 其中的 session 包含連線到 github.com, 所使用的 SSH 認證用 private key 位置, 還有 Proxy 設定. 上述將使用 cmsimde 作為子模組的倉儲取至近端電腦的目的, 共有兩個: 進行改版以及進行協同. 在近端進行倉儲內容改版的意思是, 利用 Python 與必要模組, 可以執行 cmsimde 網站中的動態系統, 其中所需要的模組為: flask flask_cors bs4 lxml pelican markdown leo pyopenssl flask 與 flask_cors 是網際框架, 安裝 flask_cors 的目的是讓網站可以跨網域擷取資料. bs4 是用來對超文件分頁的工具, 讓 cmsimde 中的 config/content.htm 可以根據 H1, H2 與 H3 的標題進行分頁. lxml 是將動態網頁內容轉為靜態網頁內容時所需要的解讀模組. pelican 是用來建立網誌的工具, 可以將使用者所寫的 Markdown 轉為網誌格式的內容. markdown 是用來解讀 .md 檔案的工具. leo 是大綱管理模組, 用來作為編寫網誌或簡報的工具, 也可以當作程式開發的 IDE. pyopenssl 則是在動態網頁中, 以程式方法伺服靜態網頁內容時, 建立 SSL 連線時所需. Replit 作為應用程式伺服器 除了將 Github 上的倉儲, git clone 到近端改版外, 也可以利用 Replit , 直接在瀏覽器上以 wsgi 模式, 執行 cmsimde 的動態網站. 如此可以免除在近端執行動態網站所需要的網路協定與 git 指令. 只不過 Replit 只給免費帳號 500 MB 的儲存空間, 過大的倉儲並不適合採用 Replit 執行 cmsimde 的動態網站. 使用 Replit 執行 cmsimde 的過程, 需要在 shell 執行: git submodule update --init --recursive 目的是取下子模組資料, 因為 Replit 與 Github 的連結, 似乎只使用 git clone, 並沒有加上 --recurse-submodules, 使用者必須手動執行. 另外則是利用 pip install flask flask_cors bs4 lxml pelican markdown gevent 安裝 cmsimde 所需模組, 與上述近端改版的差異是: 無需安裝 leo 與 pyopenssl, 因為系統是在雲端 Replit 的主機上執行, 目前還無法在 Replit 系統上使用 leo , 也無需自行配置近端伺服器的 SSL. 一旦將動態網站配置到 Replit 之後, 可以將動態網頁改版內容, 同步到對應的 Github 倉儲, 主要利用倉儲的 Github Pages 伺服靜態網頁. 電腦輔助設計與實習 What is CAD software? From: https://formlabs.com/blog/cad-software/ CAD (computer-aided design) is the tool that brings a design to a manufacture-ready state. It is the all-important software environment where designers and engineers translate concept sketches into three-dimensional models which are then visualized, optimized, simulated, and can be directly 3D printed or produced with traditional manufacturing tools. Computer-aided design (CAD) is a method to digitally create 2D drawings and 3D models that has replaced manual drafting across a wide range of industries. CAD software tools empower designers to explore design ideas, modify designs easily, visualize concepts through renderings, simulate how a design performs in the real world, draft documentation, share designs for feedback, and more—facilitating innovation and allowing companies to get to market faster. Benefit of CAD From: https://formlabs.com/blog/cad-software/ The benefits of CAD integration across the product development process are: Rapid concept development: Envisioned designs can be accurately sketched for early visualization and 3D printed rapid prototypes. Specialization: Spreading CAD throughout the organization develops specific knowledge which results in a common understanding of how to bring specific parts to the manufacturing-ready stage. Visualization: Clients and target customers can be informed and impressed with cutting-edge 3D renderings, animations, and virtual reality experiences of works-in-progress. Optimization: Faults and imperfections can be detected and optimized much faster in a virtual environment. Gaps between design intent and manufacturing reality are bridged using accurately toleranced mechanical drawings. Rapid manufacturing: Products can be brought to production faster using CAM systems and rapid manufacturing technologies. Uses of CAD From: https://formlabs.com/blog/cad-software/ Traditionally, CAD software systems lead to the generation of a set of mechanical drawings that inform the factory how to produce a product, along with the manufacturing technology, materials, mold finishes, and tolerances required. Nowadays though, they do much more: Creating photorealistic renderings for internal presentations and marketing collateral BOM (Bill of Materials) integration for managing all parts in an assembly as well as cost estimation. Direct import of standard mechanical parts and/or ornamental elements from linked databases of various suppliers Deriving an injection mold design from a part after setting up some basic parameters Assisting the design and simulation of sheet metal components, welded frames, and composite parts Stress and buckling (屈曲) analysis (FEA), drop test simulation, and generative design (GD)-generated suggestions for optimization Mold flow analysis for injection molding Thermal, vibration, and aerodynamics analysis Motion analysis and interference detection for assemblies Ergonomics analysis with posable 3D manikins Surface flattening for die-cut (沖壓剪切) drawings based on a 3D model Nesting algorithms ( 嵌套演算 ) for optimizing the layout of parts on the 2D bed of a laser cutter or 3D printer Automatic gemstone prong settings for jewelry design Simulation of fabrics (編織物) and inflatables (充氣件) PLM systems to manage assemblies, part version history, releases, engineering changes, file formats, metadata, cost estimation, vendors and suppliers, collaborations, access control, revision control, manufacturing process planning, and related part files, documents, and presentations Advanced Geometric Dimensioning and Tolerancing (GD&T) in order to convey design intent and optimize the manufacturing process. Direct import of 3D scanning data for reverse engineering Preparing models for 3D printing Texture mapping (紋理映射) and painting for use in art, video games, movies, and full-color 3D printing Types of CAD Software Systems From: https://formlabs.com/blog/cad-software/ Polygonal modeling - 代表套件 Blender Solid modeling - 代表套件 Solidworks, AutoDesk Inventor, Solid Edge, NX, Creo, Catia, Onshape Surface modelers - 代表套件 AutoDesk Alias, Rhino, 以及高端 CAD: NX, Creo, Catia Parametric modelers - 代表套件 Solidworks, AutoDesk Inventor, Solid Edge, NX, Creo, Catia, Onshape Generative design - 代表套件 AutoDesk Fusion360, Creo, Ansys Discovery, nTopology, Catia, Altair Inspire, NX, 相較於計算機程式所有上課的內容均為自由開源軟體, 電腦輔助設計與實習課程所採用的 NX 與 Coppeliasim 則分別是商用套件與教育開源工具. 下載 NX12.0.2.9_lite_cad2022.7z (for @gm users only, 1.20 GB, 解開後 6.24 GB) / 下載 NX12.0.2.9_lite_cad2022 for @nfu ) 2022 Fall 所使用的 NX 為 2027.3401 版: 下載 NX2027.3401_lite_cad2022.7z (for @gm users only, 1.97 GB, 解開後 7.49 GB) / 下載 NX2027.3401_lite_cad2022.7z for @nfu 下載 NX2027.3401_cad2022.7z (for @gm users only, 8.02 GB, 解開後 28.32 GB) / 下載 NX2027.3401_cad2022.7z for @nfu 下載 NX2007_documentation.7z (for @gm users only, 2.18 GB, 解開後 2.86 GB) / NX2007_documentation.7z for @nfu , 使用時執行 start_static.py 後, 以瀏覽器 http://localhost:7443 開啟, 或直接在 http://c1.cycu.org:88 開啟. 線上 NX2007 EN Documentation . Coppeliasim 所使用的版本則為 4.3.0 rev12: 下載 CoppeliaSim 4.3.0 rev12.7z (for @gm users only) / 下載 CoppeliaSim 4.3.0 rev12.7z for @nfu 本學期的電腦輔助與實習課程, 零組件繪圖的部分將從 design day one (或 http://c1.cycu.org:88 ) 的練習開始. 其中包括觀看各英文教學影片.","tags":"cad2022","url":"./2022_fall_semester_week2.html"},{"title":"Replit 建立網站導引","text":"這裡將說明如何利用 Replit 與 cmsite 建立動態與靜態網頁. 在 Replit 上執行 cmsimde cmsite 動態網站可以在 Replit 環境執行, 以下為設定步驟: 建立 Replit 帳號 登入 Email 驗證 Replit 寄出的註冊確認電子郵件 利用 import repository, 以 cmsite 倉儲內容, 建立 repl 進入 .replit 檔案設定頁面, 將 main.py 設定為啟動程式 在 shell 介面執行 git submodule update --init --recursive, 取下 cmsite 倉儲中 cmsimde 子模組檔案 在 shell 介面執行 pip install flask flask_cors bs4 lxml pelican markdown gevent, 安裝 cmsimde 所需要的模組 按下 Run, 啟動 main.py 登入 cmsite 動態網站, 修改管理者密碼, 修改標題與內容後, 以 generate_pages 將動態網頁內容轉為靜態格式 利用 Replit 中的 Version Control 功能, 將改版資料推向遠端倉儲 將 main.py 設定為啟動程式畫面: 在 shell 介面安裝模組化面: 以下則是從註冊 Replit 帳號, 到執行 cmsimde_site 動態網站的示範影片: var winkVideoData_replit1 = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, }; Replit references: https://replit.com/site/teams-for-education https://www.cs.carleton.edu/faculty/dmusicant/blog/replit-during-spring-2020/ https://www.cs.carleton.edu/faculty/dmusicant/blog/replit-following-spring-2021/","tags":"Replit","url":"./replit_cmsimde_tutorial.html"},{"title":"免付費完結篇","text":"天下沒有白吃的午餐. 2017 年 OpenShift 就曾經終止過免付費雲端應用服務, 2022 年GDrive 也才剛終止教育單位無限空間, 上個月 , 終於輪到 Heroku. 不過就在此時, Replit 即將在雲端應用程式服務界, 取而代之. Heroku 的宣布 Starting October 26, 2022, we will begin deleting inactive accounts and associated storage for accounts that have been inactive for over a year. Starting November 28, 2022, we plan to stop offering free product plans and plan to start shutting down free dynos and data services. Heroku 進入所謂 next chapter 之後, 希望持續使用免費雲端應用程式服務的用戶, 可以轉往 https://blog.replit.com/heroku-alternatives . 註冊 Replit 帳號 首先以 scrum1 與 cadlab 註冊帳號後, 將 cmsimde_site 透過 https://replit.com/heroku 轉換服務. 在 https://docs.replit.com/hosting/deploying-http-servers 的協助下, 應該就可以設法執行動態網頁或靜態網頁. Replit 簡介 根據 https://docs.replit.com/ : Replit is a platform for creating and sharing software. You can write your code and host it all in the same place. Replit is also a place to learn how to code, so we have some awesome built-in educational features as well. Replit can do it all. It can replace your: code editor (e.g. VS Code, Sublime Text, IntelliJ IDEA) development environment (e.g. your operating system, and build tools like npm or pip) cloud provider (e.g. AWS, Netlify) team collaboration tools (e.g. Google Docs, GitHub) teaching tools (e.g. Canva, Moodle, Blackboard) learning tools (e.g. Codecademy, Coursera, Udemy, Udacity) 免費帳號可建立不限數量的倉儲, 但只提供 500 MB 容量, 以及 500 MB 的記憶體, 加上 0.2-0.5 vCPUs, 因此大概只夠讓使用者測試了解 Replit 的使用流程以及配置方法. 希望利用 Replit 配置靜態網頁者, 可以參考 https://docs.replit.com/hosting/hosting-web-pages . 以 Replit 建立靜態網頁 選擇以 import from github 的方式建立 repl. 選擇從 https://github.com/mdecycu/cmsimde_site import 檔案 language 選擇 html, css 與 javascript 類別 將 repl 名稱從 cmsimte_site 改為 scrum1 (即與 account 名稱相同) 隨即可以在 https://scrum1.repl.co 看到靜態網頁 Replit Flask 範例 Flask 基本範例 from flask import Flask app = Flask('app') @app.route('/') def hello_world(): return 'Hello, World!' app.run(host='0.0.0.0', port=8080) Flask 以 wsgi 執行 from flask import Flask from gevent.pywsgi import WSGIServer app = Flask('app') @app.route('/') def hello_world(): return 'Hello, World!' #app.run(host='0.0.0.0', port=8080) http_server = WSGIServer(('0.0.0.0', 8080), app) http_server.serve_forever() Flask, wsgi 並壓縮資料 from gevent import monkey monkey.patch_all() from flask import Flask from gevent.pywsgi import WSGIServer from flask_compress import Compress app = Flask('app') compress = Compress() compress.init_app(app) @app.route('/') def hello_world(): return 'Hello, World!' #app.run(host='0.0.0.0', port=8080) http_server = WSGIServer(('0.0.0.0', 8080), app) http_server.serve_forever() Get from Google from flask import Flask, request from flask_cors import CORS import requests app = Flask(__name__) CORS(app) @app.route('/get_from_google') @app.route('/') def studlist(): r = requests.get(\"https://google.com\") return r.text app.run(host=\"0.0.0.0\", debug=True) Flask 與資料庫 from flask import * from flask_cors import CORS from replit import db app = Flask(__name__) cors = CORS(app) app.config['CORS_HEADERS'] = 'Content-Type' @app.route(\"/set/ / /\") def set(name, data): print(name + \" = \" + data) db[name] = data return \"\" @app.route(\"/get/ /\") def get(name): return db[name] app.run(host=\"0.0.0.0\", debug=True) nfulist 搬遷 https://github.com/mdecourse/nfulist 原先配置在 Heroku, 目前已經無法正常運作, 因此必須設法搬到 Replit. 理論上, 在 Replit 可以將程式寫為: from flask import Flask, request from flask_cors import CORS import requests import bs4 #import ssl app = Flask(__name__) CORS(app) @app.route('/studlist') @app.route('/') def studlist(): semester = request.args.get('semester') courseno = request.args.get('courseno') column = request.args.get('column') if semester == None: semester = '1091' if courseno == None: courseno = '0762' headers = {'X-Requested-With': 'XMLHttpRequest'} url = 'https://qry.nfu.edu.tw/studlist.php?selyr=1091&seqno=0762' try: result = requests.get(url, verify=False, timeout=3) except: return \"Connection refused\" soup = bs4.BeautifulSoup(result.text, 'lxml') table = soup.find('table', {'class': 'tbcls'}) data = [] rows = table.find_all('tr') for row in rows: cols = row.find_all('td') cols = [ele.text.strip() for ele in cols] data.append([ele for ele in cols if ele]) # Get rid of empty values output = \"\" for i in data[2:]: #print(i[0]) if column == \"True\": output +=i[0] + \" \" else: output +=i[0] + \"\\n\" return output #return str(pselyr) + \" + \" +str(pseqno) # 即使在近端仍希望以 https 模式下執行 #context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2) #context.load_cert_chain('localhost.crt', 'localhost.key') app.run(host=\"0.0.0.0\", debug=True) 但是 qry.nfu.edu.tw 主機先前可以透過 Heroku 遠端連線, 但是卻拒絕 Replit 虛擬主機的連線取值, 因此 nfulist 網際程式必須另外配置在工作站室中的 Server 或另外再找合用的雲端應用程式伺服器. 在近端執行的 nfulist 程式碼為 ( nfulist_local_8080.py ): import os from flask import Flask, request from flask_cors import CORS import requests import bs4 #import ssl # cpa: http://localhost:8080/?semester=1111&courseno=0747&column=True # cpb: http://localhost:8080/?semester=1111&courseno=0761&column=True # cada: http://localhost:8080/?semester=1111&courseno=0773&column=True # cadb: http://localhost:8080/?semester=1111&courseno=0786&column=True app = Flask(__name__) CORS(app) @app.route('/studlist') @app.route('/') def studlist(): semester = request.args.get('semester') courseno = request.args.get('courseno') column = request.args.get('column') if semester == None: semester = '1091' if courseno == None: courseno = '0762' url = 'https://qry.nfu.edu.tw/studlist.php?selyr=' + semester+ '&seqno=' + courseno try: result = requests.get(url, timeout=3) except: return \"Connection refused\" return result.text soup = bs4.BeautifulSoup(result.text, 'lxml') table = soup.find('table', {'class': 'tbcls'}) data = [] rows = table.find_all('tr') for row in rows: cols = row.find_all('td') cols = [ele.text.strip() for ele in cols] data.append([ele for ele in cols if ele]) # Get rid of empty values output = \"\" for i in data[2:]: #print(i[0]) if column == \"True\": output +=i[0] + \" \" else: output +=i[0] + \"\\n\" return output #return str(pselyr) + \" + \" +str(pseqno) # 即使在近端仍希望以 https 模式下執行 #context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2) #context.load_cert_chain('localhost.crt', 'localhost.key') app.run(host=\"0.0.0.0\", port=8080, debug=True) 配置 cmsimde_site 在 Replit 配置 https://github.com/mdecycu/cmsimde_site 的隨選動態網站位於: https://cmsimdesite.nfulist.repl.co , 而常駐靜態網站則另外配置於 https://scrum1.repl.co . 由於這兩個 repl 中的檔案並沒能同步, 因此在 Replit 目前針對 repl 無法直接更改執行的 language 情況下, 配置 cmsimde 網際內容管理的方式如下. Replit 與 Github Pages 結合 Replit 雖然以雲端 IDE 自稱, 其實是一個使用者友善的雲端應用程式服務, 使用者在各種 language 設定下, 儘管目前只能選定一種執行模式, 但多重的應用服務, 可以藉著 Version Control 功能, 與 Github 倉儲結合, 能夠採下列流程, 部署 cmsimde 網際內容管理的動態與靜態網站內容. 基本的使用流程是: 將動態網站部署在 Replit , 且使用該動態網站內容建立對應的 Github 倉儲, 並且在 Github 端設定 Pages, 以便用來伺服與 Replit 動態網站同步的靜態網站. 結合兩者的前提是, cmsimde 網站的 .gitignore 必須事先修改為: # Byte-compiled __pycache__/ venv/ 表示在 Github Pages 端的倉儲, 並不需要 Replit 端的虛擬 Python 與設定檔案, 只要提供 cmsimde 的完整倉儲資料即可. 另外一個重點是: 雖然 cmsimde 所需要的 Python modules, 在利用 main.py 啟動 Replit 端的動態網站時, 會自動安裝, 但 lxml 模組卻不會隨之安裝. 因此必須手動進入 shell, 以 pip 安裝 lxml. pip install lxml 完成上述準備動作後, 接著修改 cmsimde 目錄下的 flaskapp.py, 處理 nocache.py 導入模組為: from .nocache import nocache 或者 cmsimde 子模組中的程式內容不變, 但必須將 cmsimde/nocache.py 複製一份至根目錄. 最後再執行 main.py: from cmsimde import flaskapp flaskapp.app.run(host='0.0.0.0', port=8080) Replit 端的動態網站就可以啟動: https://c.scrum1.repl.co 只要再處理 Github Pages 端倉儲的同步, 就可以得到靜態網站: https://scrum-1.github.io/c 若資料直接先從 Github 倉儲進行改版, 則在 Replit 端的 Version Control, 可以利用 pull, 將改版內容取回合併.","tags":"Free","url":"./the_end_of_free_service.html"},{"title":"有關 Wink","text":"這裡將收集與 Wink 有關的資料內容. Wink 是一套製作電腦操作展示的 freeware. 從 3.0 版之後, 所製作的教學影片以 ffmpeg 存為 mp4 格式, 並透過 Javascript 在網頁上與使用者進行互動. Wink 下載 Wink 3.0 可直接從 https://www.debugmode.com/wink/ 下載. ffmpeg.exe 則可從 這裡 下載. 下載 wink3.01_with_ffmpeg.7z (for @gm users only) / 下載 wink3.01_with_ffmpeg.7z for @nfu 每一個 wink 影片嵌入網頁時, 在同一頁面下的多個影片檔案, 都要有獨一的 data-varname 變數名稱, 在 cmsimde 架構下: data-dirname 動態網頁 - 使用 /static 靜態網頁 - 使用 ./../cmsimde/static 然後動態網頁 mp4 video 標註 src - 使用 /downloads/影片名稱.mp4 靜態網頁 mp4 video 標註 src - 使用 ./../downloads/影片名稱.mp4 在 Blog 架構下, 則一律先將 .mp4 檔案 acp (git add, git commit and git push) 至 Github 倉儲後, 再使用靜態網頁連結 .mp4 與 data-dirname 設定. 假如 Wink 影片內容為單一程式視窗, 其導入影片寬高尺寸可使用 800 x 600, 若影片操作範圍擴及整個操作系統畫面, 則建議導入影片寬高尺寸為 1008 x 630. 以下為兩個 Wink3 官方釋出的 Tutorial (已經全數刪除原先的 buttons, 並直接使用 html5 的 video controls): Tutorial1: var winkVideoData_tutorial1 = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, }; Tutorial 2: var winkVideoData_tutorial2 = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, }; 上述嵌入 Tutorial1 Wink3 mp4 影片的超文件內容如下: <script> var winkVideoData_tutorial1 = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, }; </script> </p> <!-- 接下來將 mp4 檔案從 downloads 目錄取出 --> <div class=\"winkVideoContainerClass\"><video autoplay=\"autoplay\" class=\"winkVideoClass\" controls=\"controls\" data-dirname=\"./../cmsimde/static\" data-varname=\"winkVideoData_tutorial1\" height=\"600\" muted=\"true\" width=\"800\"> <source src=\"./../downloads/wink_tutorial/tutorial1.mp4\" type=\"video/mp4\"/></video> </div> <br \\>","tags":"Wink","url":"./about-wink.html"},{"title":"有關 Github Classroom","text":"這裡將收集與 Github Classroom 有關的資料內容. Github Classroom 登入 Github 帳號, 並連線至 https://classroom.github.com/ 後, 選擇 Sign in and Get Started, 就可以加入 Github Classroom: https://github.com/education/classroom . 授權讓 classroom 程式管理 organization 帳號下的所有倉儲, 其中最重要的功能就是, 可以由管理者管控是否 enable invite link, 讓取得連結的學員參與作業與專案倉儲管理, 並且可以透過 organization 中的 Member privileges 設定讓使用者建立 Github Pages, 但限制其刪除 organization 下作業倉儲的權限.. 加入 Github classroom 後, 將跳出相關說明: A classroom is a space where you can create assignments, collaborate with teaching assistants, and invite students in a single course. 由於 GitHub Classroom uses organization accounts to manage permissions, administration, and security for classrooms. You can create a Classroom in any organization you own. 意即, 當 Github 使用者加入 Github Classroom 之後, 就可以透過該帳號下的 organization 來新增 assignments 或協同 project, 當該 orgainzation 的管理者透過 Github Classroom 設定 assignment 之後, 該 assignment 就會產生一組 invite link 網址, 且與管理者所選定的倉儲作為 template 之後, 任何 Github 用戶只要連結到該 assignment 對應的網址, 並且同意加入後, 就可以在該 assignment 權限設定下讓用戶對倉儲擁有管理權. 假設該作業倉儲名稱為 site, 且使用者帳號名稱為 scrum-2, 則納入該 assignment 後, 就會在 organization 名稱下建立一個名稱為 site-scrum-2 的倉儲, 而先前所使用的 template 若為 cmsite, 則該選定接受 assignment 的使用者就可以全權管理該作業倉儲. 一旦學員將倉儲設定 Github Pages 對應分支後, 該作業網址將為: https://organization_名稱.github.io/site-scrum-2 invite link 時效 當所有修課學員都參與指定作業後, 可以進入 assignment 設定, 取消 invite link. 學員作業倉儲權限 當課程中止, 由於學員僅具備管理作業倉儲改版與 Github Pages 設定權限, 因此可以永久保留該學員所繳交的作業倉儲內容. Github Classroom 功能 https://github.com/education/classroom 採用 Ruby 編寫, 是一套輔助教學的 Web-based 程式, 其功能如下: 利用管理者的 organization 當作 Github 帳號, 以 invite link 讓學員自行建立 assignment 或 協同 project 倉儲. assignment 倉儲的 template 可由管理者指定, 且學員對 assignment 倉儲所具備的管理權限, 可由管理者事前統一設定. 管理者可以控制學員所建立的 assignment 倉儲, 令其無法 delete, 因此課堂結束後管理者仍可完整保留學員的課程倉儲. 當管理者賦予學員對 assignment 倉儲擁有 admin 權限後, 學員可自行啟用倉儲的 Github Pages 功能, 利用倉儲內容建立課程網站.","tags":"Github","url":"./about-classroom.html"},{"title":"有關 NX","text":"這裡將收集與 NX 有關的資料內容. Siemens NX 在 2022.09.01 釋出最新版本為 NX2206.4020, 幾乎同步釋出的 NX2027 最新版本則為 build 3401. cd2022 電腦輔助設計與實習將使用 NX2027.3401 可攜版本. Recent Opened Files 啟動 NX 時將 HOME 以及 UGII_TMP_DIR 設定至 Temp 子目錄後, Recent Opened Files 資料會存入 Temp 目錄, 當 NX 啟動後, 會將資料轉存至 電腦\\HKEY_CURRENT_USER\\SOFTWARE\\Unigraphics Solutions\\NX\\2027\\General\\Parts\\Recent, 若希望刪除此類資料, 則必須在重新啟動 NX 之前, 分別刪除 Temp 目錄下的所有檔案, 並以 regedit 進入將 Recent 項目下的 Native 機碼刪除. 以下為啟動 NX 時所設定的環境變數: set HOME=%cd%\\Temp set UGII_TMP_DIR=%cd%\\Temp\\ NX 繪圖與組立 基本的 NX2027.3401 繪圖與組立, 只需要下列目錄: DESIGNSPACEEXPLORER : 7.31 KB DESIGN_TOOLS : 275.8 MB DIAGRAMCORE : 5.81 MB DIAGRAMMING : 64.65 MB DRAFTING : 123.65 MB DXFDWG : 206.79 MB IGES : 5.2 MB INSTALL : 55.55 KB MECHATRONICS : 212.81 MB NXASSEMBLY : 120.98 MB NXBIN : 5.07 GB NXPARTS : 53.76 MB STEP203UG : 1.28 MB STEP214UG : 1.27 MB temp : 0B TRANSLATORS : 157.87 MB UGFLEXLM : 29.4 MB UGII : 677.93 MB UGMANAGER : 117.29 MB UGOPEN : 425.32 MB UGOPENPP : 567.28 KB UNFOLD : 71.92 KB total: 7.49 GB Siemens Support Center 從 https://support.sw.siemens.com/en-US/ 下載檔案後, 可以利用 certutil 工具驗證檔案. 驗證下載檔案: 使用工具: https://docs.microsoft.com/zh-tw/windows-server/administration/windows-commands/certutil 指令: certutil -hashfile SiemensNX-2027.3401_wntx64.zip SHA512 SHA512 hash: f180a6c97b9599af0bc6068d344eeb8ea065f79648f64fea9c782fd41e00e430e04aad85c0d09705071c60ea9493c9e75f39e8bf0f22660c3dcb6cbc7819274a Portable NX 在 Windows 10 配置可攜 NX2027.3401 程式, 需要: https://github.com/Bioruebe/UniExtract2 https://github.com/wixtoolset/wix3/releases/tag/wix3112rtm 等兩項工具, UniExtract2 用來解開 SiemensNX-2027_wntx64\\nx\\SiemensNX.msi, 以及 .msi, 而 wix 則用來解開 SiemensNX-2027_wntx64\\nx\\VC_redist.x64.exe, 指令為: wix311-binaries\\dark.exe vc_redist.x64.exe -x x64-extracted 表示要在 x64-extracted 目錄中取得 x64-extracted\\AttachedContainer\\packages\\vcRuntimeMinimum_amd64\\vc_runtimeMinimum_x64.msi 之後, 再利用 UniExtract2 解開所需的 dll 檔案後, 再放入 NXBIN 目錄. 製作 Portable NX2207 的步驟請參考以下影片(以 NX1980 為例): 解開 SiemensNX.msi 合計得到 151803 個檔案, 而將 VC_redist.x64.exe 解開後的 52 個 dll 檔案放入 NXBIN 目錄中. var winkVideoData = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, }; 完成 NX2027.3401 可攜系統製作後, 各目錄檔案容量如下: AUTOMATED_TESTING : 1.52 MB AUTOMATION_DESIGNER : 254.08 MB CAPITALINTEGRATION : 2.04 MB CATIAV5 : 784.01 KB CLOUDDM : 31.07 KB CMM_INSPECTION : 143.31 MB DESIGNSPACEEXPLORER : 7.31 KB DESIGN_TOOLS : 275.8 MB DIAGRAMCORE : 5.81 MB DIAGRAMMING : 64.65 MB DRAFTING : 123.65 MB DXFDWG : 206.79 MB IGES : 5.2 MB INSTALL : 55.55 KB LOCALIZATION : 1.09 GB MACH : 1.96 GB MANUFACTURING_PLANNING : 141.66 MB MBD : 54.05 MB MECH : 793.28 MB MECHATRONICS : 212.81 MB MENDIXREPORTING : 1.04 MB MOLDCOOLING : 12.28 KB MOLDWIZARD : 226.71 MB MPA : 1.5 MB NXAECDESIGN : 15.48 KB NXASSEMBLY : 120.98 MB NXBIN : 5.04 GB NXCABLEROUTER : 190.45 KB NXCAE_EXTRAS : 2.36 GB NXCOATINGS : 645.3 KB NXCREO : 6.17 MB NXHUMAN : 247.51 MB NXJOIN : 16.38 MB NXNASTRAN : 2.93 GB NXPARTS : 53.76 MB NXPLOT : 151.34 MB NXPROE : 6.17 MB NXREPORTS : 9.42 MB NXSHIP : 359.0 MB NXSTRUCTUREDESIGN : 106.47 MB NXVR : 441.53 MB NX_VSA : 13.88 MB OCCUPANTSAFETY : 514.74 MB POSTBUILD : 37.65 MB PSTUDIO : 35.5 MB PVTRANS : 102.46 KB REL_INFO : 36.92 KB ROUTING : 315.47 MB RULE : 316.7 KB SIMULATION : 4.19 GB STAGE_MODEL : 3.53 MB STAMPING_TOOLS : 77.06 MB STEP203UG : 1.28 MB STEP214UG : 1.27 MB TDP : 237.62 MB TOOLING_BASE : 970.0 KB TRANSLATORS : 157.87 MB UGALLIANCE : 82.9 KB UGAUTOMOTIVE : 99.41 MB UGCATIA : 6.53 MB UGFLEXLM : 29.4 MB UGFPCD : 35.19 KB UGII : 677.93 MB UGIMW : 8.45 MB UGMANAGER : 117.29 MB UGOPEN : 425.32 MB UGOPENPP : 567.28 KB UGPCBX : 3.42 MB UGPCBXCHANGE : 90.23 MB UGPHOTO : 2.98 GB UGSTRUCTURES : 735.35 MB UGSTUDIO : 14.03 MB UGTIPS : 278.35 MB UGTO2D : 911.38 KB UGWEB : 9.08 MB UGWELD : 2.07 MB UNFOLD : 71.92 KB VDA : 25.44 KB VDV : 13.11 KB total: 28.29 GB 請注意: 新版 NX 所建立的零組件無法由舊版的 NX 開啟. 下載 NX12.0.2.9_lite_cad2022.7z (for @gm users only, 1.20 GB, 解開後 6.24 GB) / 下載 NX12.0.2.9_lite_cad2022 for @nfu ) 下載 NX2027.3401_lite_cad2022.7z (for @gm users only, 1.97 GB, 解開後 7.49 GB) / 下載 NX2027.3401_lite_cad2022.7z for @nfu 下載 NX2027.3401_cad2022.7z (for @gm users only, 8.02 GB, 解開後 28.32 GB) / 下載 NX2027.3401_cad2022.7z for @nfu 下載 NX2007_documentation.7z (for @gm users only, 2.18 GB, 解開後 2.86 GB) / NX2007_documentation.7z for @nfu , 使用時執行 start_static.py 後, 以瀏覽器 http://localhost:7443 開啟, 或直接在 http://c1.cycu.org:88 開啟. NX2007 Documentation 2022.09 https://support.sw.siemens.com/en-US/ 只提供 NX2206 與 NX2007 的 Documentation, 這裡將採用 NX2007 的英文手冊. 下載 NX2007_documentation.7z (for @gm users only, 2.18 GB, 解開後 2.86 GB), 使用時執行 start_static.py 後, 以瀏覽器 http://localhost:7443 開啟. 也可以透過 http://c1.cycu.org:88 查看內容. 線上 [NX2007 EN Documentation] 滑鼠 LMB - 滑鼠左鍵, 一般元件選擇, 可以連續使用滑鼠左鍵選擇多個元件 Shitf + LMB - 可以去除利用滑鼠左鍵已經選擇的元件 RMB - 滑鼠右鍵, 在視圖空白按住滑鼠右鍵, 可以帶出相關 menu MMB - 滑鼠中鍵, 單擊表示 confirm 確認, 按住中鍵移動則可以旋轉觀測視圖 (rotate), 前後滑動中鍵則可放大縮小觀測視圖 (zoom in or out) MMB + RMB - 同時按住滑鼠中鍵與右鍵後移動, 可以平移觀測視圖 (pan), 相同功能也可以同時按住 Shift 與滑鼠中鍵後移動滑鼠, 以執行 pan 動作 ESC - 取消 F4 - 帶出上一個執行功能 F6 - Zoom, 以滑鼠左鍵在視圖中選擇放大的區域 F7 - Rotate, 進入此功能後, 可以使用任一滑鼠鍵移動, 執行旋轉視圖功能 F8 - Snap view, 轉到與目前視圖最接近的正向視圖 Ctrl + f - Fit Ctrl + l - Layer Settings Layers NX 提供 256 個圖層 (Layers) layers objects 1 - 20 solids 21 - 40 sketches 41 - 60 curves 61 - 80 reference elements 81 - 100 faces 101 - 120 PMI Ctrl + l - Layer Settings","tags":"NX","url":"./about-nx.html"},{"title":"cp2022_w1","text":"計算機程式課程第一週, 只有 1b 有課, 1a 因為中秋節放假. cadlab 網路設定 目前電腦輔助設計室 (cadlab) 中絕大部分的電腦都只有一個磁區 (假如有三個磁區的電腦是上一代的舊電腦), 使用的操作系統是 Windows 10, 因為系上有四門課程在電腦輔助設計室上課時, 採用的是純 IPv6 網路連線, 因此各位學員在接觸到計算機程式課程時, 必須學會設定電腦系統的網路連線. IPv4 與 IPv6 IPv4 與 IPv6 是兩種不相容的網路協定. 目前除了計算機程式課程, 還有網際內容管理、電腦輔助設計與實習以及協同產品設計實習等課程, 上課時都將電腦輔助設計室的連外網路直接與系上主幹連接. 目的是希望擴大每一台電腦的網路頻寬, 可以無需透過 NAT 轉址後再連接到系上. 但是這樣做, 所要付出的代價是, 首先, 每一台電腦都直接以 IPv6 外部網路位址與網際網路相通, 若此時電腦中的 IPv4 也同時開啟的話, 安裝在操作系統中的某些軟體會以為已經取得 IPv4 的外部網路位址 (其實並沒有, 因此系上已經沒有額外的外部 IPv4 網路位址), 而啟動網路攻擊. 因而導致操作系統所安裝的防毒軟體作動, 關閉電腦的所有對外網路連線. 結論是: 當電腦輔助設計室網路線直接連到外網主幹時, 要設法關閉 IPv4 網路連線, 否則無法使用網路. 其次, IPv6 網路協定雖然已經逐漸普及, 但目前仍有許多網站只支援 IPv4 網路協定, 因此在純 IPv6 網路設定下, 若要連接至某些只支援 IPv4 的電腦或網站, 必須透過代理主機 (Proxy Server, 這裡所使用的代理主機執行 Squid ). 學習議題 為什麼會有 IPv4 與 IPv6 兩種網路協定並存? 上計算機程式課程時, 當使用瀏覽器與執行 git 指令時, 該如何正確設定網路協定? 線上學習 Brython 當你完成電腦輔助設計室中的 網路設定 後, 就可以利用瀏覽器連線到 這裡 , 直接在線上學習 Brython . 學員課程網頁 cp2022 課程中的 cp 為 computer programming 的縮寫, 每一位學員各自建立 Github 帳號後, 將在 https://ethercalc.net/ 中登錄用於課程的 Github 帳號. 之後將配合 Github Classroom 建立學員課程網頁. 此一網頁倉儲分為靜態與動態等兩個部分, 靜態網頁是配合 Github Pages, 直接由 Github.com 提供對應網址, 而動態網頁則可在近端用於網站內容編輯改版, 也可以在 Windows 或 Ubuntu 操作系統中進行配置, 成為可多人協同維護的網際內容管理系統. 完成配置後的學員課程網頁, 將位於組織 (organization) 名稱為 mdecp2022 的帳號下, 且倉儲名稱將為: site-個人帳號名稱 (site 為 assignment 名稱). 至於個人 Github 帳號與學號的對應關聯則將登錄於 https://github.com/mdecycu/studlist/tree/main/2022fall 目錄中的班級對應檔案. 建立個人課程網頁示範: 有關筆記型電腦 綜一館八樓的電腦輔助設計室所配置的 PC, 雖然裝有還原卡, 但只要配合 USB 隨身碟與可攜套件, 應該足以應付 cp2022 計算機程式課程所需. 所以一般並不建議大一就購買筆記型電腦, 而是先善用系上所提供的 PC. 至於課外使用時段, 請參考系上電腦教室借用規定辦理, 通常週四與週五晚間未排課時段可以外借. 至於符合機械設計工程系需求的筆記型電腦, 一般建議 i7 等級以上, 16 GB 記憶體, 並配置中階以上獨立顯卡. Windows 操作系統則建議使用專業 (Professional) 以上版本. 校外電腦連接部分, 則需要每學年申請 VPN 使用授權, 下載學校購買的軟體或電子書, 只要設定校內 Proxy 即可, 但若要連網認證 SolidWorks 或 Matlab, 則需透過校內 VPN 連網. Python Learning https://coderslegacy.com/python/learning-the-basics/ https://coderslegacy.com/python/python-intermediate/ https://coderslegacy.com/python/python-advanced/ Coding with Python and Repl.it: https://i.ritzastatic.com/codewithreplit/e-books/coding-with-replit-export.pdf Learn Python the right way: https://learnpythontherightway.com/#read https://www.freecodecamp.org/news/how-to-use-replit/ Python curriculum: https://hackpacific.gitbooks.io/pythonium/content/ https://www.codementor.io/@garethdwyer/introduction-to-machine-learning-with-python-and-repl-it-rln7ywkhc","tags":"cp2022","url":"./cp2022-w1.html"},{"title":"有關 TCExam","text":"這裡將收集與 TCExam 有關的資料內容. 虛擬主機上的 TCExam 相關程式檔案放在 c:\\tcexam, 管理者帳號設為 tcexam. 啟動 exam.網域.名稱, 牽涉 nginx, php, pgsql 以及 tcexam 程式原始碼. nginx 主要負責將 http 跳轉至 https, 並且透過 fastcgi 啟動 php 解譯器的執行. 而 nginx 的 server 設定範例如下: server { listen 98 ssl; listen [::]:98 ssl; root c:/tmp/TCExam; server_name exam.網域.名稱; ssl_certificate C:/pj2022/stunnel/config/fullchain.pem; ssl_certificate_key C:/pj2022/stunnel/config/privkey.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; location /{ index index.html index.php; } location ~ \\.php$ { fastcgi_pass 127.0.0.1:9123; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } pgsql 以手動 start.bat 啟動, 設定檔案如下: @echo off set /p DATA=<PGDATA.txt cd %~dp0 bin\\postgres -V bin\\pg_ctl -D %DATA% -l logfile.txt start 其中的 PGDATA.txt 內容為 .\\data, 表示資料庫內容存在 .\\data 目錄中. 一旦考試結束後, 以 stop.bat 關閉 pgsql: @echo off set /p DATA=<PGDATA.txt cd %~dp0 bin\\pg_ctl -D %DATA% -l logfile.txt stop TCExam 原始碼 由於目前所啟動的線上 TCExam 採用 2022.06.9 釋出的 PHP 8.1.7 版, 而 https://github.com/tecnickcom/tcexam 最近修改日期為 2021.08.05, 因此直接從 TCExam github 網站 clone 下來的原始碼無法在最新版的 PHP 解譯環境中執行. 因此啟動修改 TCExam, 令其可以在 PHP 8.1.7 中執行, 且 pdf 轉檔的部分, 也自行建立中文字型, 以便正確將考試內容轉為中英並存的格式. 目前尚未完成的設定為 send mail 的部分. 總結上述說明, 要啟動 TCExam 考試系統, 必須確認 nginx 已經啟動, 然後手動執行 pgsql 目錄下的 start.bat, 並且注意 c:\\certbot 目錄下有關 https 數位簽章每 90 天必須設法手動或自動更新. CYCU TCExam 主機 目前 exam dot cycu dot org 採用 10ff:1:0::1 設定, 使用 8GB 虛擬主機測試是否合用. 目前透過 nginx 管制, 只允許系上 IPv6 網段連線. Python and PostgreSQL pip install psycopg2 peewee import psycopg2 conn = psycopg2.connect(host='localhost', user='postgres', password='postgres') conn.cursor().execute('CREATE DATABASE mydatabase') conn.close() from peewee import * db = PostgresqlDatabase('mydatabase', host='localhost', port=5432, user='postgres', password='postgres') class MyUser (Model): name=TextField() city=TextField(constraints=[SQL(\"DEFAULT 'Mumbai'\")]) age=IntegerField() class Meta: database=db db_table='MyUser' db.connect() db.create_tables([MyUser]) Windows TCExam nginx 只允許特定 IPv6 網段連線, 且將 http 用戶跳轉至 https 設定: server { listen [::]:80 default ipv6only=on; server_name domain.cycu.org; #return 301 https://$server_name$request_uri; allow 2001:288:6004:xx::0/32; deny all; return 302 https://domain.cycu.org; #location /{ #root C:/tcexam_dir/downloads; #auth_basic \"For Authorized Users Only!\"; #auth_basic_user_file C:/tcexam_dir/nginx-1.20.1/.htpasswd; #} } nginx 執行 php 解譯設定: server { listen [::]:443 default ssl ipv6only=on; root C:/tcexam_dir/tcexam; server_name domain.cycu.org; ssl_certificate C:/tcexam_dir/fullchain.pem; ssl_certificate_key C:/tcexam_dir/privkey.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; allow 2001:288:6004:xx::0/32; deny all; location /{ index index.html index.php; } location ~ \\.php$ { fastcgi_pass 127.0.0.1:9123; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } fastcgi 在 port 9123 啟動的 batch file: @ECHO OFF ECHO Starting PHP FastCGI... set PATH=C:\\PHP8.1.7;%PATH% c:\\PHP8.1.7\\RunHiddenConsole.exe C:\\PHP8.1.7\\php-cgi.exe -b 127.0.0.1:9123 若採用 nssm 建立服務, 則透過下列設定建立: nssm install php 建立 php 服務. nssm edit php 則用來編輯服務. Path: C:\\tcexam_dir\\php8.1.7\\php-cgi.exe Startup Directory: C:\\tcexam_dir\\php8.1.7 Arguments: -b 127.0.0.1:9123 在 TCExam 準備線上試卷 使用說明: https://tcexam.org/docs/first_test/ 以管理者帳號登入, 進入 admin 頁面. Group 代表開課班級, 在此分別建立 cp2022_四設一甲, cp2022_四設一乙, cad2022_四設二甲與 cad2022_四設二乙 等四個開課班級 Group. 當使用者自行建立考試帳號時, 必須選擇所屬班級 Group, 若同時選修兩個班級的課程, 必須同時選擇多個 Group. 建立題庫時, 以 Module 來區分測驗試題的模組類別, 例如: 可以針對開設課程\"計算機程式\"名稱建立試題模組, 也可以針對主題建立 Module. 目前建立 cp2022, cad2022 與 network_setting 等三個試題模組. 進入試題模組 (考試題目的類別與範圍) 後, 可以再將試題細分 Topic, 例如 network_setting 模組就包含與 cadlab 有關的 Topic, 而 cp2022 試題模組則依照週次加以界定 Topic, 目前的主題訂為 w1-w3, 希望根據上課各週的進度與內容命題. 管理者登入後, 選擇 public 即進入一般用戶介面. 以下題庫範例: Group (代表開課班級) - Module (試題的最大分類) - Topic (試題的次主題分類) cp2022_四設一甲 - cp2022 - w1-w3 只允許系上網段可以考試, 外部電腦必須設定代理主機後才可參與考試: authorized IP's: 2001:288:6004:17:: basic points: 每一個題目得分, 若總題數為 10 題, 則 basic points 為 10 分, 總分為 100 分. partial score for MCMA: 打勾, 表示針對 Multiple Choice Multiple Answer 允許部分給分. Let'sEncrypt renew: 開啟管理者模式下的 cmd, 然後執行 \"C:\\Program Files (x86)\\Certbot\\bin\\certbot\" renew exam.cycu.org 之 https 數位簽章 due day: 2022.12.27","tags":"tcexam","url":"./about-tcexam.html"},{"title":"Windows 常用指令","text":"根據使用情境將常用的 Windows 指令加以整理. 密碼最長使用期限 Windows 10 密碼最長使用期限 內定為 42 天, 假如此一設定對使用者造成困擾, 可以從系統管理者執行的 cmd 中, 輸入 secpol.msc 開啟 本機安全性設定 , 開啟\"帳戶原則\"中的\"密碼原則\", 然後將\"密碼最長使用期限\"從內定的 42 天改為 0, 表示密碼永不過期. 以 net user 建立帳號 在 Windows 建立新帳號, 例如: 帳號名稱為 username: 開啟管理者權限的 cmd, 輸入: net user username /add 帳號建立後, 進入控制台 - 使用者帳戶區, 變更帳號屬性並新增密碼. Windows 10 教育版認證 校內網段: 利用 win10_kms.bat , 以管理者權限執行, 即可完成認證. 校外網段: 利用 VPN 上網, 之後利用 win10_kms.bat , 以管理者權限執行, 即可完成認證.","tags":"windows","url":"./useful-windows-commands.html"},{"title":"Git 常用指令","text":"根據使用情境將常用的 git 指令加以整理. Git 簡介 Git 是一套分散式版次管理工具, 可在各種電腦操作系統中使用, 其目的是用來管理資料改版過程中的所有細節, 最常被用來管理程式套件的開發流程. 能夠配合 Git 使用常見的 Web based 服務有 Github, Gitlab 與 Bitbucket. 由於利用電腦輔助各種產品設計開發的過程, 不僅牽涉許多文字與數位資料, 而且通常在不同時段, 會與許多不同專業的人士進行協同設計. 過程中若沒有完善的分散版次管理系統, 比較可能產生資料紛亂, 難以追蹤問題, 且團隊成員間針對協同資料間的權利與義務不容易有效釐清. 以下列出使用 Git 分散式版次管理的優點: 各開發者可以同步對同一文件或程式進行改版, 改版時無需上網 所有提交的改版內容均會存檔, 一旦納入管理的資料不會丟失, 也不會查不出資料被誰改寫 系統中明確儲存各階段各檔案的改版歷程 上列所謂同步開發的意思是, 只要各團隊成員了解專案的目標, 以及每次改版的動機, 就可以各自在同一時間, 直接對倉儲進行改版, 等到各成員分別將改版內容提交推送至遠端倉儲時, 若各改版內容產生衝突, 就可以依照實際需求進行處理後合併. Git 基本概念 以下 Git 專有名詞說明翻譯自 這裡 : Snapshots (快照) 快照是 git 追踪資料歷程的方式 快照主要是記錄所有文件在特定時間點的狀態 使用者可以決定何時拍快照以及拍那些文件資料 使用者能夠擷取先前所拍的任何快照 Commits (提交) 對資料拍快照的動作稱為提交 提交可以是動詞, 也可以是名詞, 例如: 提交這個程式, 或者已經完成幾次提交 基本上改版專案就是由每次的提交所組成 每一個提交都包含三種資料: 檔案的更動內容、與上一個提交的參照資料 (即所謂 parent commit)、一組 hash code (SHA-1 hashes). 其中 hash code 長得像這樣: f2d2ec5069fc6776c80b3ad6b7cbde3cade4e Repositories (儲存庫或倉儲) 可以簡寫為 repo 倉儲指所有檔案與檔案改版歷程 檔案改版歷程包含所有的提交 倉儲資料可以存放在近端或遠端 (例如: Github 或 Gitlab) 從遠端將倉儲內容取下的動作稱為 clone clone 倉儲的功能, 讓多人可以協同對同一倉儲改版 從遠端將倉儲之外的提交內容取下的動作稱為 pulling 改版內容 將近端的改版資料納入遠端倉儲的動作稱為 push 改版內容 Branches (分支) git 中的所有提交都存在某個分支上 一個倉儲可以有許多的分支 Github 目前的主要分支稱為 main 在不影響主分支內容的情況下, 可以針對特定提交切出分支進行修改 從特定提交切出分支的示意圖如下: HEAD HEAD 通常指 A reference to the most recent commit. Merging (合併) 分支合併示意圖如下: 如何提交? 在近端電腦上的資料版本稱為 Working Directory (工作目錄) 準備將已經修改完的資料納入特定提交的動作稱為 Staging (暫存) 將修改後的檔案放入暫存檔的指令為 git add, 可以利用 git add file.txt 暫存單一檔案或 git add . 暫存所有已經修改的檔案 改版檔案進入暫存區之後, 可利用 git commit -m 加上提交字串完成提交, 意即對這些檔案拍快照 (Snapshots) git add . 之後執行 git commit -m \"提交說明訊息\" 的流程示意圖如下: Rebasing、Revert and Cherry picking Rebase (資料取自 https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase ) What is git rebase? From a content perspective, rebasing is changing the base of your branch from one commit to another making it appear as if you'd created your branch from a different commit. Internally, Git accomplishes this by creating new commits and applying them to the specified base. 以下為 git rebase 示意圖: Revert: https://www.atlassian.com/git/tutorials/undoing-changes/git-revert Git cherry pick: https://www.atlassian.com/git/tutorials/cherry-pick remote add git remote add 的使用情境是希望將某一個倉儲的完整歷程資料, 改存至另一個倉儲. 假設原來的 cad2021_final 倉儲位於 mdecourse 帳號下, 現在想要將此倉儲的完整歷程資料, 轉存至 mdecycu 帳號下. 先前準備: 要先在近端電腦設定好 mdecourse 與 mdecycu 對 git 的 SSH 公私鑰簽章設定 . 且 mdecourse 對應的 putty session 為 github.com, 而 mdecycu 對應的 putty session 為 mdecycu. 步驟一: 登入 github.com mdecycu 帳號, 建立一個空的 cad2021_final 倉儲, 也就是連 README.md 都先不加入的完全空的倉儲. 步驟二: 將 cad2021_final 從 mdecycu 帳號下, git clone 至近端電腦. git clone --recurse-submodules git@github.com:mdecourse/cad2021_final.git 因為 cad2021_final 倉儲在 mdecourse 帳號下設為 private, 因此需要透過 putty session github.com, 利用近端的 puttygen 所建立的 .ppk private key 與 github 上 OpenSSL 格式的 public 對應下, 才能夠透過 ssh 協定取下 cad2021_final 倉儲. 步驟三: cd 至 cad2021_final 倉儲目錄, 以 git remote add 設定代號, 並對應至 mdecycu 帳號下的同名倉儲. git remote add mdecycu git@mdecycu:mdecycu/cad2021_final.git 其中的 git remote add 為指令, 表示要加入一個遠端的連結代號, 而此代號名稱為 mdecycu, 隨後的 git@ 表示要利用 ssh 協定, 以 git 作為登入帳號, @ 後面的 mdecycu 為近端 putty 的 session 名稱, 而 :mdecycu 中的 mdecycu 則是 github 系統下的 mdecycu 帳號用戶名稱, /cad2021_final.git 則為先前已經建立的空倉儲. 步驟四: 將 cad2021_final 倉儲內容, 以 git push 推送到 mdecycu 帳號下. git push mdecycu recurse-submodules 當使用 git clone 倉儲時, 之所以要宣告 --recurse-submodules 選項命令, 是針對該倉儲的所有子模組, 包括子模組下的所有子模組, 也要同時取下. 假如在第一時間沒能取下子模組, 之後可以利用 git submodule update --init --recursive 將所有子模組內容取下. submodule add git submodule add 隨後要加入 URL 指向某一倉儲, 表示要將該倉儲設為子模組, 然後指令還要再加上該子模組連結的對應代號. git submodule add https://github.com/mdecycu/cmsimde.git cmsimde 表示要將 cmsimde 倉儲設為子模組, 且放入 cmsimde 目錄中. Git 參考資料 https://git-scm.com/book/zh-tw/v2 https://www.tutorialspoint.com/git/git_tutorial.pdf https://people.irisa.fr/Anthony.Baire/git/git-for-beginners-handout.pdf https://indico.cern.ch/event/724719/contributions/2981043/attachments/1638054/2754736/Git_tutorial.pdf https://hipert.unimore.it/people/paolob/pub/Calcolo_Parallelo/Slides/Git_Tutorial.pdf","tags":"git","url":"./useful-git-commands.html"},{"title":"有關 Fossil SCM","text":"Fossil SCM 是一套 Software Configuration Management 套件, 專門用於 SQLite 的原始碼管理. Fossil SCM 是一套冷門的系統, 感覺好像沒有太多單位或團體使用, 只是就分散式版次管理系統的角度來看, 其實是一套小而美且功能齊全的 SCM 系統, 接下來將對 Fossil SCM 進行初步介紹. fossil init 起始一個 Fossil SCM 倉儲之前需要先從 https://fossil-scm.org/home/uv/download.html 下載相應的檔案, 與 Portablegit 相比, Fossil SCM 工具無論在 Windows, Linux 或 Mac 操作系統, 都只有一個檔案, 且大小只有約 9MB. 而起始 Fossil SCM 倉儲的指令與 Git 相同: fossil init 只不過 Fossil SCM 在倉儲 clone 之後的檔案為一個壓縮檔案, 通常以 .fossil 作為副檔名, 其實這是一個 SQLite 資料庫檔案. 當使用者 clone Fossil SCM 倉儲至近端之後, 必須透過 fossil open 將最新的版本內容展開, 一般會建議, 擺放 .fossil 檔案的目錄中, 建立 working director 目錄, 建議命名為 wd, 然後在 wd 目錄之中, 再根據各倉儲檔案的名稱建立位於 wd 目錄下的子目錄, 而各 .fossil 倉儲的內容則在各自的 \"wd\\倉儲名稱\" 目錄下展開. 假如要將遠端的倉儲 clone 至遠端, 若採 https 協定, 其命令列語法為: fossil clone https://user_name@fossil.kmol.info/repository repository.fossil 表示要將位於 fossil.kmol.info 主機上的 repository 倉儲, 以 https 協定 clone 至近端且存為 repository.fossil 以一位於近端檔案架構的 repository.fossil 本身會帶有管理者的密碼設定, 而此一管理者帳號下對應的 local password 與 remote passwors 分屬於兩個不同的 repository.fossil, 當使用者要將近端改版資料推向遠端時, 依據的是遠端的管理者 passwors, 而近端的管理者密碼則在近端倉儲以 fossil web 進行網際啟動時之用. 換言之, 各個 Fossil SCM 倉儲壓縮檔案內所儲存的管理者帳號密碼, 主針對下游啟動服務時採用. 至於在工作目錄下倉儲資料檔案中的改版資料, 一旦新增提交推送後, 不僅會將版本更新資料註記在近端對應的 .fossil 檔案中, 也會推向遠端對應的 .fossil 倉儲檔案. Fossil SCM project documentation: https://www.fossil-scm.org/home/doc/trunk/www/embeddeddoc.wiki Fossil SCM unversioned content: https://www.fossil-scm.org/home/doc/trunk/www/unvers.wiki 在 Fossil SCM 倉儲中, 所謂的 unversioned content 指在改版紀錄中沒有保留改版資料的檔案, 倉儲中的 unversioned 內容只保留最新的版本, 且可以透過網際 /uvlist 列出無改版歷程的檔案列表, 並能透過網際 /uv/檔案名稱 進行下載. Fossil SCM 中的帳號必須具備 y capabilities 的權限才能 fossil uv sync -v 對倉儲中先前所加入的無版本檔案送到倉儲資料中. Fossil SCM 中的帳號最高管理者必須具備 s capabilities (setup 權限). Fossil SCM 倉儲改版時若刪除檔案, 則可以透過 fossil addremove 納入改版內容. 將 uversioned_file_name 納入或移除倉儲中成為無版本管理內容: fossil uv add unversioned_file_name fossil uv delete unversioned_file_name fossil uv sync -v 其他參考資料: https://fossil-scm.org/home/help?cmd=unversioned Fossil SCM 使用案例 Fossil SCM 與 Github 整合 Fossil SCM on Ubuntu","tags":"fossil-scm","url":"./about-fossil-scm.html"},{"title":"有關 ethercalc","text":"ethercalc 是一個網頁同步試算表. 有關 ethercalc 若 ethercalc 與 redis 合用, sheet 資料將會存入 /var/lib/redis/dump.rdb, 此一檔案儲存設定位於 /etc/redis/redis.conf 中的 dbfilename dump.rdb 使用者若要以 root 身分檢視 /var/lib/redis/dump.rdb 可以透過 sudo -s 以 root 身分執行命令. 若以 /etc/init.d/redis-server stop 關閉 redis, 然後執行 ethercalc, sheet 資料將會存在執行命令目錄下的 dump 目錄中. 在結合 redis 使用下的 ethercalc, 若希望 reset /var/lib/redis/dump.rdb 中的資料: sudo -s /etc/init.d/redis-server stop rm /var/lib/redis/dump.rdb /etc/init.d/redis-server start ethercalc 則 /var/lib/redis/dump.rdb 中為空資料.","tags":"ethercalc","url":"./about-ethercalc.html"},{"title":"編譯 Solvespace","text":"這裡將利用 MSYS2 編譯 Solvespace . 上列影片採用 MSYS2 編譯 Solvespace 原始碼. MSYS2 套件中名稱帶有 mingw-w64-x86_64 表示用於 MinGW 64 bit 操作系統 更新系統核心組件: pacman -Syu 安裝基本 C/C++ 編譯與開發工具: pacman -S mingw-w64-x86_64-toolchain 安裝 CMake: pacman -S mingw-w64-x86_64-cmake 編譯之前必須 rename Y:\\msys64\\usr\\bin\\sh.exe 接著就是 build solvespace.exe 以 git clone --recurse-submodules https://github.com/solvespace/solvespace.git 取下原始碼與子模組. 接下來進入倉儲後執行編譯: cd solvespace mkdir build cd build cmake .. -G \"MinGW Makefiles\" -DCMAKE_BUILD_TYPE=Release mingw32-make cd bin solvespace.exe 即可執行. 編譯結束後, 之所以可以直接執行 solvespace.exe 是由於先前已經在啟動可攜程式系統時設定 set path_msys2=%Disk%:\\msys64_20210419\\mingw64\\bin; 且將 path_msys2 納入 path 命令搜尋路徑中, 因此可以直接以命令列執行 solvespace.exe, 但是若要讓 solvespace.exe 獨立執行, 則需要 libwinpthread-1.dll to execute solvespace.exe 編譯 Range3 為了 compile Range3 , MSYS2 除了mingw-w64-x86_64-toolchain 還必須加裝: pacman -Sy mingw-w64-x86_64-qt5 pacman -Sy mingw-w64-x86_64-qt5-static pacman -Sy mingw-w64-x86_64-ffmpeg 接著編譯 Range3 : start Y:\\msys64\\mingw64.exe cd /y/tmp/range3 ./scripts/build.sh --clean && ./scripts/create_package.sh 而為了讓 svg 格式的 icons 能夠正確顯示, 必須納入 Qt5Svg.dll","tags":"compilation","url":"./compile-solvespace.html"},{"title":"編譯 CoppeliaSim 4.3.0 rev12","text":"CoppeliaSim 採用 C++ 與 Qt 編寫, 安裝系統則利用 QSetup 建立. 這裡希望編譯的是 CoppeliaSim 原始碼中的 CoppeliaSimLib 第 4.3.0 rev12 版, 是由 448 個 .cpp 編譯連結而成 coppeliaSim.dll, 檔案大小約為 9538 KB, 是 CoppeliaSim 套件中最重要的核心程式庫 . config.pri CoppeliaSim 自 4.2.0 版之後, 所使用的 Lua 從 5.1 升級為 5.3 , 配合設定的 config.pri 也必須修改如下: # location of boost headers: BOOST_INCLUDEPATH = \"Y:/msys64_20210419/mingw64/include/boost\" # location of lua headers: LUA_INCLUDEPATH = \"Y:/lua-5.3.5/src\" # lua libraries to link: LUA_LIBS = \"y:/lua-5.3.5/src/liblua.a\" # qscintilla location: QSCINTILLA_DIR = \"y:/QScintilla_gpl-2.11.2\" # qscintilla headers: QSCINTILLA_INCLUDEPATH = \"$${QSCINTILLA_DIR}/include\" \"$${QSCINTILLA_DIR}/Qt4Qt5\" # qscintilla libraries to link: QSCINTILLA_LIBS = \"$${QSCINTILLA_DIR}/libqscintilla2_qt5.dll.a\" # Make sure if a config.pri is found one level above, that it will be used instead of this one: exists(../config.pri) { include(../config.pri) } 由上列 config.pri 設定檔案可以得知, 編譯 CoppeliaSimLib 之前, 必須要先編譯 lua-5.3.5 與 QScintilla_gpl-2.11.2, 分別取得對應的程式庫之後, 再編譯 CoppeliaSimLib. 編譯 Lua 5.3.5 Y:\\lua-5.3.5>mingw32-make mingw 可以建立 y:/lua-5.3.5/src/liblua.a 編譯 QScintilla Location: Y:\\QScintilla_gpl-2.11.2 Compile: cd Qt4Qt5 qmake -o Makefile qscintilla.pro mingw32-make to get libqscintilla2_qt5.dll.a under release directory 編譯 CoppeliaSimLib config.pri 設定修改完成後, 執行 C:\\acc_430_12\\CoppeliaSimLib>qmake -o Makefile coppeliaSimLib.pro 接著執行 C:\\acc_430_12\\CoppeliaSimLib>mingw32-make -f Makefile.Release 編譯結束後, 可以在 Release 目錄中建立 coppeliaSim.dll, 這是 CoppeliaSim 的主要動態連結程式庫. 下載可攜編譯系統: compile_copsim_cd2022.7z (for @gm users only) 下載已經完成 CoppeliaSimLib 編譯的檔案: acc_430_12_compile_Lib.7z (for @gm users only) / 下載 acc_430_12_compile_Lib.7z for @nfu 下載啟動 coppeliasim.exe 所需的 dlls 檔案: dlls_for_coppeliasimlib_430_12.7z (for @gm users only) / 下載 dlls_for_coppeliasimlib_430_12.7z for @nfu 編譯 coppeliaSimClientApplication coppeliaSimClientApplication 是呼叫 CoppeliaSimLib 動態連結程式庫的客戶端應用程式. 編譯時必須位於 programming 目錄中: C:\\acc_430_12\\programming>git clone --recurse-submodules https://github.com/CoppeliaRobotics/coppeliaSimClientApplication.git Cloning into 'coppeliaSimClientApplication'... remote: Enumerating objects: 170, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (5/5), done. Receiving objects: 86% (145/170)sed 4 (delta 1), pack-reused 164eceiving objects: 82% (140/1 Receiving objects: 100% (170/170), 32.92 KiB | 2.99 MiB/s, done. Resolving deltas: 100% (100/100), done. C:\\acc_430_12\\programming>cd coppeliasimclientapplication C:\\acc_430_12\\programming\\coppeliaSimClientApplication>git checkout coppeliasim-v4.3.0-rev12 Note: switching to 'coppeliasim-v4.3.0-rev12'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -c with the switch command. Example: git switch -c Or undo this operation with: git switch - Turn off this advice by setting config variable advice.detachedHead to false HEAD is now at 306a6c1 updated copyright C:\\acc_430_12\\programming\\coppeliaSimClientApplication> 將 C:\\acc_430_12\\programming\\coppeliaSimClientApplication\\config.pri 修改為: # lua libraries to link: LUA_LIBS = \"y:/lua-5.3.5/src/liblua.a\" # location of lua headers: LUA_INCLUDEPATH = \"Y:/lua-5.3.5/src\" exists(../config.pri) { include(../config.pri) } 而在建立 coppeliaSim.exe 之前, 需要再編輯 coppeliaSim_resource.rc 檔案, 下載 coppeliaSim.ico, 並且開啟 coppeliaSim.pro 中第 42 行 RC_ICONS += coppeliaSim.ico 設定, 以便將 coppeliaSim.ico 圖像編譯後放入 coppeliaSim.exe, coppeliaSim_resource.rc 設定內容如下: #include IDI_ICON1 ICON DISCARDABLE \"C:/acc_430_12/programming/coppeliaSimClientApplication/coppeliaSim.ico\" VS_VERSION_INFO VERSIONINFO FILEVERSION 0,0,0,0 PRODUCTVERSION 0,0,0,0 FILEFLAGSMASK 0x3fL #ifdef _DEBUG FILEFLAGS VS_FF_DEBUG #else FILEFLAGS 0x0L #endif FILEOS VOS__WINDOWS32 FILETYPE VFT_DLL FILESUBTYPE 0x0L BEGIN BLOCK \"StringFileInfo\" BEGIN BLOCK \"040904b0\" BEGIN VALUE \"CompanyName\", \"\\0\" VALUE \"FileDescription\", \"\\0\" VALUE \"FileVersion\", \"0.0.0.0\\0\" VALUE \"LegalCopyright\", \"\\0\" VALUE \"OriginalFilename\", \"coppeliaSim.exe\\0\" VALUE \"ProductName\", \"coppeliaSim\\0\" VALUE \"ProductVersion\", \"0.0.0.0\\0\" END END BLOCK \"VarFileInfo\" BEGIN VALUE \"Translation\", 0x0409, 1200 END END /* End of Version info */ 接下來就可以利用 qmake 建立 Makefile.Release, 並利用 mingw32-make 建立 coppeliaSim.exe C:\\acc_430_12\\programming\\coppeliaSimClientApplication>qmake -o Makefile coppeliaSim.pro C:\\acc_430_12\\programming\\coppeliaSimClientApplication>mingw32-make -f Makefile.Release 可以在 release 目錄中取得 coppeliaSim.exe 編譯 simExtDynamics C:\\acc_430_12\\programming\\simExtDynamics\\build>cmake .. -G \"MinGW Makefiles\" -DCMAKE_BUILD_TYPE=Release 再執行: Y:\\tmp\\cop410\\programming\\simExtUI\\build>mingw32-make","tags":"compilation","url":"./compile-coppeliasim-4.3.0-rev12.html"},{"title":"電腦輔助設計室系統更新","text":"今天收到通知, 電腦輔助設計室下週要重新更新套件, 管理員問我說: 內容需要更新嗎? 我的回答是: 不用, 只要 Windows 操作系統能正常運作就行, 所有上課的套件都使用可攜模式. Hybrid 模式 雖然記不得是從何時開始在上課採用可攜套件模式, 但 2004 導入 NX3 時就已經採用 Portable 架構, 將程式存入隨身碟, 以 start.bat 啟動, 以 stop.bat 關閉, 所有與個人工作有關的資料與設定都可隨身帶走, 就好像擁有一台虛擬的筆電一樣, 唯一的缺點就是 USB 隨身碟的讀取速度沒有目前 Solid State 硬碟快, 因此從上學期電腦更新後, 就一直採用 Hybrid 的模式啟動套件. 2022 Fall 將所使用的 Hybrid 套件可以從 drive.7z 下載, 其中包含 start_ipv6.bat: @echo off REM 將目前隨身碟所在目錄設為變數 Disk set Disk=%cd%\\data REM 將SSD 上的 data 目錄設為 Local REM for cadlab set Local=C:\\2021_cadlab_portable\\data REM for c1 REM set Local=C:\\compile_copsim_cd2022\\data set HomePath=%Disk%\\home_ipv6 set HomeDrive=%Disk%\\home_ipv6 set Home=%Disk%\\home_ipv6 set USERPROFILE=%Disk%\\home_ipv6 REM 將系統 Python 程式的 io 設為 utf-8 set PYTHONIOENCODING=\"utf-8\" set PYTHONPATH=%Local%\\Python395\\DLLs;%Local%\\Python395\\Lib;%Local%\\Python395\\Lib\\site-packages; set PYTHONHOME=%Local%\\Python395 REM 使用 putty 設定 git ssh 連線 set GIT_SSH=%Disk%\\putty\\plink.exe REM 設定跟 Python 有關的命令搜尋路徑 set path_python=%Local%\\Python395;%Local%\\Python395\\Scripts; set path_portablegit=%Local%\\portablegit_2.31.1\\bin; set path_tcc=%Disk%\\tcc; path=%Disk%;%path_python%;%path_portablegit%;%path_tcc%;%path%; reg.exe import %Disk%\\2022_cdb.reg; start /MIN cmd.exe start /MIN cmd.exe start /MIN cmd.exe start /MIN cmd.exe start /MIN %Disk%\\wScite\\SciTE.exe start /MIN %Disk%\\wScite\\SciTE.exe Exit 而 stop.bat 則為: @echo off taskkill /IM python.exe /F taskkill /IM pythonw.exe /F taskkill /IM scite.exe /F REM 關閉 cmd 指令視窗 taskkill /IM cmd.exe /F EXIT 隨身攜帶的 git 倉儲 由於電腦輔助設計室中的電腦安裝了防寫系統, 因此使用者為了利用 Github 維護個人的倉儲, 除了使用個人的筆電, 最方便的還是隨身攜帶一個 USB 硬碟, 除了帶有常用的可攜的套件外, 還可在任何一台 Windwos 電腦中維護自己的 git 倉儲, 當然前提是, 可能要自帶合用的 portablegit 與 Python, 或者就連 NX2206 與 Coppeliasim 加上 MSYS2 都自己隨身帶著.","tags":"cadlab","url":"./renew-cad-lab-software.html"},{"title":"建立可攜 Python 系統","text":"這裡所謂的可攜 Python 系統, 是指能夠放入 USB 隨身碟中的 Python 解譯器. 整個過程分為三個部分. 包括 Python 核心程式, pip 以及安裝常用模組等過程. 動機 由於電腦輔助設計室中的電腦配置防寫系統, 大約每半年才更新一次, 為了及時配合不同課程所需,除了使用電腦操作系統中所安裝的 Python 外, 通常建議學員自行建立可直接放入 USB 隨身碟啟動的可攜 Python 解譯系統. 使用可攜 Python 解譯系統的好處是, 可以在任何的 64 位元 Windows 操作系統中使用相同配置的 Python 解譯器. 且可同時將 portable git 與 scite 納入可攜系統, 採可攜的方式執行程式編寫, 並維護電腦輔助設計流程中所建立 github 倉儲內容. 建立步驟 核心程式 已知從 https://www.python.org/ftp/python/ 可以下載各版本的 Python .msi 安裝檔案, 且所下載的 .msi 可以直接以 msiexec.exe 解開內容, 而不需要經過操作系統的套件安裝流程. 由於以下 Python 程式可以利用現有舊版的 Python 解譯器執行, 下載並解開最新版的 Python 可攜解譯器, 因此只要進入 cmd 命令視窗, 選擇所要配置 Portable Python 的目錄, 即可直接執行後完成第一階段的 Python 核心程式的配置. 這裡以 Python 3.10.6 為例, 下載並解開所需的 Python 核心程式內容: import urllib.request import os # basic files for Python installation py_list = [\"core\", \"dev\", \"exe\", \"lib\", \"tcltk\", \"tools\"] # Python version version = \"3.10.6\" # location for Portable Python path = \"c:\\\\tmp\\\\Python310\" # Python msi download URL ftp = \"https://www.python.org/ftp/python/\" + version + \"/amd64/\" extract_path = path + \"\\\\extract\" # create directory try: os.mkdir(path) except: # path exists pass # get Python installation msi files and extract into target dir for i in py_list: filename = i + \".msi\" url = ftp + filename # download basic python msi file urllib.request.urlretrieve(url, path+ \"\\\\\"+ filename) os.system(\"msiexec.exe /a \" + path + \"\\\\\" + i + \".msi /qb targetdir=\" + extract_path) # delete msi file os.remove(extract_path + \"\\\\\" + i + \".msi\") 執行結束後, path (在上述範例 path 為 \"c:/tmp/Python310\") 目錄中的 extract 子目錄即為可攜 Python 解譯器檔案. 安裝 pip 從 https://bootstrap.pypa.io/get-pip.py 可以下載 get-pip.py 檔案, 利用前面完成的 Python 核心程式可以在可攜 Python 程式的架構下安裝 pip 工具, 但必須先讓可攜的核心程式得以運作, 這時需要安排 start.bat 與 stop.bat 安裝 pip 時, 先以 cmd 進入命令列視窗, 然後更換目錄至 get-pip.py 所在目錄後, 以 python get-pip.py 進行安裝. Microsoft Windows [版本 10.0.19042.1706] (c) Microsoft Corporation. 著作權所有，並保留一切權利。 C:\\tmp\\portable_python_3.10.6>cd tmp C:\\tmp\\portable_python_3.10.6\\tmp>python get-pip.py Collecting pip Downloading pip-22.2.2-py3-none-any.whl (2.0 MB) ---------------------------------------- 2.0/2.0 MB 1.5 MB/s eta 0:00:00 Collecting setuptools Downloading setuptools-65.2.0-py3-none-any.whl (1.2 MB) ---------------------------------------- 1.2/1.2 MB 2.7 MB/s eta 0:00:00 Collecting wheel Downloading wheel-0.37.1-py2.py3-none-any.whl (35 kB) Installing collected packages: wheel, setuptools, pip Successfully installed pip-22.2.2 setuptools-65.2.0 wheel-0.37.1 可攜 Python 安裝 pip 後, 就可以利用 pip list 列出目前所安裝的模組, 並接著安裝 cmsimde 所需模組. C:\\tmp\\portable_python_3.10.6\\tmp>pip list Package Version ---------- ------- pip 22.2.2 setuptools 65.2.0 wheel 0.37.1 C:\\tmp\\portable_python_3.10.6\\tmp>pip install flask flask_cors bs4 lxml pelican markdown leo pyopenssl 以下為用來啟動可攜 Python 的批次檔案: start.bat @echo off set PATH=%cd% set HomePath=%cd%\\home_ipv6 set HomeDrive=%cd%\\home_ipv6 set Home=%cd%\\home_ipv6 set USERPROFILE=%cd%\\home_ipv6 REM 將系統 Python 程式的 io 設為 utf-8 set PYTHONIOENCODING=\"utf-8\" set PYTHONPATH=%cd%\\Python310\\DLLs;%cd%\\Python310\\Lib;%cd%\\Python310\\Lib\\site-packages; set PYTHONHOME=%cd%\\Python310 REM for putty set GIT_SSH=%cd%\\putty\\plink.exe REM 設定跟 Python 有關的命令搜尋路徑 set path_python=%cd%\\Python310;%cd%\\Python310\\Scripts; REM 設定跟Git 有關的命令搜尋路徑 set path_git=%cd%\\portablegit_2.31.1\\bin; set path_tcc=%cd%\\tcc; REM for execute scite directly set path_scite=%cd%\\wScite502\\; path=%cd%;%path_python%;%path_git%;%path_tcc%;%path_scite%;%path%; start /MIN cmd.exe start /MIN cmd.exe start /MIN cmd.exe start /MIN cmd.exe start /MIN %cd%\\wScite502\\SciTE.exe start /MIN %cd%\\wScite502\\SciTE.exe Exit 以下為關閉可攜 Python 的批次檔: stop.bat @echo off taskkill /IM python.exe /F taskkill /IM pythonw.exe /F taskkill /IM scite.exe /F taskkill /IM cmd.exe /F EXIT 安裝模組 pip install flask flask_cors bs4 lxml pelican markdown leo pyopenssl 上述配置 pip 與模組 安裝詳細過程紀錄 . 下載 portable_python_3.10.6.7z (for @gm users only) / 下載 portable_python_3.10.6.7z for @nfu","tags":"cp2022","url":"./Create-a-portable-python-system.html"},{"title":"可攜 CoppeliaSim 4.3.0 rev12","text":"CoppeliaSim 的安裝套件採用 QSetup 製作, 即便在安裝過程可從 %temp% 中的暫存目錄 (例如: AppData\\Local\\Temp\\SETUP_2639) 取得其 setup.exe 所解開的檔案, 但仍無法直接 extract 出完整的可攜 CoppeliaSim 目錄. Portable CoppeliaSim 因此這裡所謂的可攜 CoppeliaSim , 其實就是從操作系統完成安裝的目錄中取出資料, 然後加上存入操作系統中的 redistributable dll 檔案製作而成. 其中的 vcRedist/vc2019redist_x64.exe 需要利用 Wix 解出 .msi 之後, 再利用 UniExtract2 解出所需要的 .dll, 並將所有的 .dll 檔案放入可攜 CoppeliaSim 的根目錄中. 解開 vc2019redist_x64.exe 的指令: wix311-binaries\\dark.exe vc2019redist_x64.exe -x extracted 表示要在 extracted 目錄中取得 extracted\\AttachedContainer\\packages\\vcRuntimeMinimum_amd64\\vc_runtimeMinimum_x64.msi 之後, 再利用 UniExtract2 解開所需的 dll 檔案, 最後再放入 CoppeliaSim 根目錄. 啟動時直接執行 coppeliaSim.exe 即可. simscene XML CoppeliaSim 從 4.0.0 版 開始, 提供 XML 檔案格式 的輸出入, 此功能允許使用者透過 ASCII 檔案格式建構 CoppeliaSim 的 場景 . 其中與機電產品開發過程中的電腦輔助設計架構最直接關聯的就是, 使用者可以直接透過程式方法, 將設計零件以 STL 格式輸出後, 套接在使用者所建構的機電資 場景 中. 意即: 使用者可以直接從 MCAD 套件中將組立檔案轉進具有 joints 、 Camera 、 Vision sensors 、 Force sensors 、 Proximity sensors 與控制 Scripts 的模擬環境, 而無需全部採手動轉檔方式, 在 CoppeliaSim 圖形介面中進行組立、設定參數或配接各項模擬元件樹狀架構. 當使用者從 CoppeliaSim 將 場景 存為 exhaustive sinscent XML 檔案格式 後, 可以利用下列 Python 程式讀出其中的標註 (總數超過 326 個), 之後再設法利用 Leo Editor 的 import-xml-tags data 設定解讀所有 tags 內容, 並以階層式架構呈現 : # from https://stackoverflow.com/questions/29596584/getting-a-list-of-xml-tags-in-file-using-xml-etree-elementtree import xml.etree.ElementTree as ET def leo_print(x): try: print(x) except: g.es(x) # load and parse the file xmlTree = ET.parse('two_link_slvs_shaft_simple.simscene.xml') elemList = [] for elem in xmlTree.iter(): elemList.append(elem.tag) # now I remove duplicities - by convertion to set and back to list elemList = list(set(elemList)) # Just printing out the result try: print(elemList) except: # echo string g.es(elemList) for i in elemList: leo_print(i) 下載 CoppeliaSimEdu_4.3.0_rev12.7z (for @gm users only) / 下載 CoppeliaSimEdu_4.3.0_rev12.7z for @nfu","tags":"cad2022","url":"./portable-CoppeliaSim-4.3.0-rev12.html"},{"title":"2022 Fall CP 課程","text":"2022 Fall 計算機程式的課程進度將放在 Weblog, 並且使用 mdecycu At cycu 登記 disqus. 所有與課程相關的問題, 都希望在各週 Weblog 下方的 disqus 詢答. 課程評分 cp2022 課程評分項目請參考: syllabus 命令提示字元 cmd (Command Line) 指令, 是 Windows 命令 中的一種. 常用的命令提示字元視窗中的指令包括: echo , dir , cd , ping , set , rem , start , path , reg , exit , taskkill , powershell 網路環境設定 由於希望能夠讓電腦輔助設計室中使用純 IPv6 網路設定上網, 開機啟動後, 可採管理員模式執行下列 batch file 進行 網路環境設定 : 因為在執行過程中, 需要利用 Powershell 命令 關閉 IPv4 網路協定, 並開啟 IPv6 網路協定, 需要以管理員模式執行才能順利完成. 1_ipv6_network_setup.bat 通常放在隨身碟最外部, 且三個檔案放在同一目錄. REM Get-ExecutionPolicy -List REM Set-ExecutionPolicy RemoteSigned echo \"disable ipv4 and setup proxy for ipv6\" SET CurrentDir=%~dp0 %windir%\\system32\\reg.exe import %CurrentDir%1_2022_cadlab_network_setup.reg REM powershell -noexit -executionpolicy bypass -File %CurrentDir%1_disable_ipv4.ps1 powershell -executionpolicy bypass -File %CurrentDir%1_disable_ipv4.ps1 exit 執行時, 需要 1_2022_cadlab_network_setup.reg 與 1_disable_ipv4.ps1 兩個檔案: 1_2022_cadlab_network_setup.reg 主要是關閉自動偵測 proxy server , 且手動設定代理主機. Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings] ; disable AutoDetect \"AutoDetect\"=dword:00000000 \"MigrateProxy\"=dword:00000001 ; enable Proxy \"ProxyEnable\"=dword:00000001 \"ProxyHttp1.1\"=dword:00000000 \"ProxyServer\"=\"http://[2001:288:6004:17::42]:3128\" \"ProxyOverride\"=\"localhost;\" 執行 1_2022_cadlab_network_setup.reg, 只需要點擊滑鼠左鍵兩次就可以執行. 1_disable_ipv4.ps1 為 Powershell 命令 , 主要將所有網路卡上的 IPv4 網路設定取消 (因為現階段所安裝的某套件會啟動網路攻擊, 透過 IPv4 網路協定嘗試與外部網站連結取得後門權限). 以下 Powershell 命令 會自動關閉 IPv4 網路協定, 然後開啟 IPv6 網路協定: Disable-NetAdapterBinding -Name \"*\" -ComponentID ms_tcpip Enable-NetAdapterBinding -Name \"*\" -ComponentID ms_tcpip6 上述相關設定檔案: cadlab_network_setup.zip W1 教學影片 var winkVideoData_w1_1 = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, }; 建立 Github 帳號 請尚未建立 Github 帳號的學員, 至 https://github.com/join 申請帳號. 課程評分項目將包含利用 Github Classroom 建立的倉儲與網站內容 (透過 invite link). 2022fall Github 帳號與學號對照的倉儲位於 https://github.com/mdecycu/studlist/tree/main/2022fall , w2 起將利用 https://ethercalc.net/ 在線由各學員自行輸入, 之後若 Github 更動, 則可以透過 Pull Requests 提出修改請求. 建立 Onedrive 帳號 請尚未建立 Onedrive 帳號的學員登入 @nfu 帳號後, 至 https://www.microsoft.com/zh-tw/education/products/office , 以 @nfu 帳號申請 Onedrive 5TB 儲存權限. 課程中所提供的檔案, 需要登入以 @nfu 註冊的 Onedrive 帳號後, 才能下載. 利用 Github 建立網頁 只要在 Github 倉儲中放入 HTML , css 與 Javascript , 並且設定 Github Pages 對應的分支, Github 就會給定 Github_帳號.github.io/倉儲名稱 作為網址 (各學員課程網址將為: https://mdecp2022.github.io/site-學員_Github_帳號), 以 WWW 伺服器 serve 使用者所提供的網頁內容. 除了配置在 Github Classroom 的課程倉儲與網頁外, 學員也可以在登入 Github 後, 利用 https://github.com/mdecycu/cmsite 作為 template , 使用 https://pages.github.com/ 建立個人網頁, 並利用網頁 (https://Github_帳號.github.io) 建立個人簡歷 ( Curriculum Vitae ) 網站. 維護 Github 上的網頁 在近端將動態網頁轉為靜態網頁後, acp 至 Github 倉儲. Computer 簡介 以下資料取自: https://mde.tw/content/Computer.html A computer is a digital electronic machine that can be programmed to carry out sequences of arithmetic or logical operations (computation) automatically. Modern computers can perform generic sets of operations known as programs. These programs enable computers to perform a wide range of tasks. A computer system is a \"complete\" computer that includes the hardware, operating system (main software), and peripheral equipment needed and used for \"full\" operation. This term may also refer to a group of computers that are linked and function together, such as a computer network or computer cluster. A broad range of industrial and consumer products use computers as control systems. Simple special-purpose devices like microwave ovens and remote controls are included, as are factory devices like industrial robots and computer-aided design, as well as general-purpose devices like personal computers and mobile devices like smartphones. Computers power the Internet, which links billions of other computers and users. Early computers were meant to be used only for calculations. Simple manual instruments like the abacus have aided people in doing calculations since ancient times. Early in the Industrial Revolution, some mechanical devices were built to automate long tedious tasks, such as guiding patterns for looms. More sophisticated electrical machines did specialized analog calculations in the early 20th century. The first digital electronic calculating machines were developed during World War II. The first semiconductor transistors in the late 1940s were followed by the silicon-based MOSFET (MOS transistor) and monolithic integrated circuit (IC) chip technologies in the late 1950s, leading to the microprocessor and the microcomputer revolution in the 1970s. The speed, power and versatility of computers have been increasing dramatically ever since then, with transistor counts increasing at a rapid pace (as predicted by Moore's law), leading to the Digital Revolution during the late 20th to early 21st centuries. Conventionally, a modern computer consists of at least one processing element, typically a central processing unit (CPU) in the form of a microprocessor, along with some type of computer memory, typically semiconductor memory chips. The processing element carries out arithmetic and logical operations, and a sequencing and control unit can change the order of operations in response to stored information. Peripheral devices include input devices (keyboards, mice, joystick, etc.), output devices (monitor screens, printers, etc.), and input/output devices that perform both functions (e.g., the 2000s-era touchscreen). Peripheral devices allow information to be retrieved from an external source and they enable the result of operations to be saved and retrieved. Program 簡介 以下資料取自: https://mde.tw/content/Program.html A computer program is a sequence or set of instructions in a programming language for a computer to execute. Computer programs are one component of software, which also includes documentation and other intangible components. A computer program in its human-readable form is called source code. Source code needs another computer program to execute because computers can only execute their native machine instructions. Therefore, source code may be translated to machine instructions using the language's compiler. (Machine language programs are translated using an assembler.) The resulting file is called an executable. Alternatively, source code may execute within the language's interpreter. If the executable is requested for execution, then the operating system loads it into memory and starts a process. The central processing unit will soon switch to this process so it can fetch, decode, and then execute each machine instruction. If the source code is requested for execution, then the operating system loads the corresponding interpreter into memory and starts a process. The interpreter then loads the source code into memory to translate and execute each statement. Running the source code is slower than running an executable. Moreover, the interpreter must be installed on the computer. Python 簡介 以下資料取自: https://en.wikipedia.org/wiki/Python_(programming_language) , 充分了解上述內容後, 可進入 https://mde.tw/content/Python.html 開始練習如何根據需求編寫 Python 程式. Python is a high-level, interpreted, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation. Python is dynamically-typed and garbage-collected. It supports multiple programming paradigms, including structured (particularly procedural), object-oriented and functional programming. It is often described as a \"batteries included\" language due to its comprehensive standard library. Guido van Rossum began working on Python in the late 1980s as a successor to the ABC programming language and first released it in 1991 as Python 0.9.0. Python 2.0 was released in 2000 and introduced new features such as list comprehensions, cycle-detecting garbage collection, reference counting, and Unicode support. Python 3.0, released in 2008, was a major revision that is not completely backward-compatible with earlier versions. Python 2 was discontinued with version 2.7.18 in 2020. Python consistently ranks as one of the most popular programming languages.","tags":"cp2022","url":"./2022-Fall-Intro-to-computer-programming.html"},{"title":"2022 Fall CAD 課程","text":"2022 Fall 電腦輔助設計與實習的教學主要介紹 NX 與 CoppeliaSim 在機械設計流程中的應用. 課程評分 cad2022 課程評分項目請參考: syllabus 課程目標 利用 MCAD (Mechanical Computer Aided Design) 與 Robotic Simulator 建立一個未來能結合 影像辨識 與 深度強化學習 探索用之 數位平台 . 建立 Github 帳號 請尚未建立 Github 帳號的學員, 至 https://github.com/join 申請帳號. 課程評分項目將包含利用 Github Classroom 建立的倉儲與網站內容 (透過 invite link). 2022fall Github 帳號與學號對照的倉儲位於 https://github.com/mdecycu/studlist/tree/main/2022fall , w2 起將利用 https://ethercalc.net/ 在線由各學員自行輸入 (透過 https://wcms.repl.co 告知連結), 之後若 Github 更動, 則可以透過 Pull Requests 提出修改請求. cad2022 課程中各學員的課程網址將為: https://mdecad2022.github.io/site-學員_Github_帳號 建立 Onedrive 帳號 請尚未建立 Onedrive 帳號的學員登入 @nfu 帳號後, 至 https://www.microsoft.com/zh-tw/education/products/office , 以 @nfu 帳號申請 Onedrive 5TB 儲存權限. 課程中所提供的檔案, 需要登入以 @nfu 註冊的 Onedrive 帳號後, 才能下載. 上述操作流程參考影片如下: var winkVideoData_w2_1 = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, }; 利用 Replit 執行課程倉儲的動態網頁伺服器, 從 Github 倉儲 import 後, 可編輯動態網頁內容, 轉為靜態後, acp 回 Github Pages, 就可以對靜態網站改版: var winkVideoData_w2_2 = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, }; 設計繪圖 以 NX2027.3401 或 NX12 建立 Foosball Table 零組件. 但新版 NX 所建立的零組件無法由舊版的 NX 開啟. 下載 NX12.0.2.9_lite_cad2022.7z (for @gm users only, 1.20 GB, 解開後 6.24 GB) / 下載 NX12.0.2.9_lite_cad2022 for @nfu ) 下載 NX2027.3401_lite_cad2022.7z (for @gm users only, 1.97 GB, 解開後 7.49 GB) / 下載 NX2027.3401_lite_cad2022.7z for @nfu 下載 NX2027.3401_cad2022.7z (for @gm users only, 8.02 GB, 解開後 28.32 GB) / 下載 NX2027.3401_cad2022.7z for @nfu 下載 NX2007_documentation.7z (for @gm users only, 2.18 GB, 解開後 2.86 GB), 使用時執行 start_static.py 後, 以瀏覽器 http://localhost:7443 開啟, 或直接在 http://c1.cycu.org:88 開啟. / 下載 線上 NX2007 EN Documentation NX 零組件練習 請參考 Design Day One 資料, 並根據以 STEP 242 格式轉入 NX2027 之 Drill Press 零組件檔案 ( Drill Press 零組件檔案 for @nfu ) 各零件尺寸, 重新繪製各零組件, 過程請以 Wink3 影片錄製繪圖步驟並加入說明文字內容. 以 Onshape 建立 Foosball Table 零組件 , Foosball Table . 以 Solvespace (含套件編譯) 建立 Foosball Table 零組件. Siemens NX for beginners – in a nutshell (in German) Extra Materials Siemens NX for advanced users - in a nutshell (in German) Extra Materials W1 教學影片 var winkVideoData_w1_1 = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, }; 機電模擬 Robotic Simulator 部分將利用 CoppeliaSim 4.3.0 rev12 建立 Foosball Table 模擬場景. 下載 CoppeliaSim 4.3.0 rev12.7z (for @gm users only) / 下載 CoppeliaSim 4.3.0 rev12.7z for @nfu CoppeliaSim 使用者手冊: https://mde.tw/pjcopsim CoppeliaSim Overview CoppeliaSim Tutorials Import and Export Joints Build a clean model Simulation Design dynamic simulations Writing code Web-browser based frontend 控制方法 Robotic player 組設計驅動機構並交由 Lua 或 Python 執行控制. Human player 組則直接由鍵盤或搖桿執行控制. 可行機構分析 Robotic player 平移與旋踢機構設計. Actuation 機構設計. 送球循環機構設計. 網誌類別 Category: Cad2022 類別代表與 2022 Fall 電腦輔助設計實習相關進度的內容 Tutorial 類別代表與課程有關的教學示範 Misc 類別代表雜項內容 標籤 Tags: 標籤則可以分為: 課程簡介或 w1, w2 等各週的相關教學內容. 除了課程週次 Tags 之外, 也可以將文章分為 NX, Solvespace, Onshape, CoppeliaSim, Brython or Python, Leo Editor 與 Fossil SCM 等專門介紹 Tags. 單篇文章可以加入多個 Tags 以逗點隔開. 其他的文章則放入 Misc 類別. 解開 redist_x64.exe C:\\CoppeliaSimEdu_4.3.0_rev12\\vcRedist>c:\\wix311\\dark.exe vc_2019redist_x64.exe -x test Use UniExtract to extract the .msi","tags":"cad2022","url":"./2022-Fall-computer-aided-design-and-practices.html"}]};