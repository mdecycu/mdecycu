var tipuesearch = {"pages": [{'title': 'cp2022', 'text': '2022 Fall \n Introduction to Computer Programming (計算機程式) \n 線上 Python 教學: \n https://www.youtube.com/c/Freecodecamp/search?query=python \n 程式語言學習順序建議: \n Brython  (Javascript, html5, css) ->  CPython  ->  C /C++->  Rust \n Brython - 在網頁 (with Gist) 上編寫程式 \n CPython - Server 端的 Python 程式 (Flask) \n C/C++ - Server 端的硬體控制與數值分析程式 \n Rust - 專注效能、安全與同步並發程式開發 \n 2022_Absolute_Beginners_Guide_to_Python_Programming.pdf  (for @nfu users only) \n 2022_C_and_Python_Applications.pdf  (for @nfu users only) \n 2022_Python_Challenges.pdf  (for @nfu users only) \n 2022_Artificial_Intelligence_with_Python.pdf  (for @nfu users only) \n 2022_Programming_in_Two_Semesters.pdf  (for @nfu users only) \n 行事曆 \n 全頁檢視 \n \n \n \n \n \n Please enable JavaScript to view the  comments powered by Disqus.', 'tags': '', 'url': 'cp2022.html'}, {'title': 'cp-syllabus', 'text': '課程評分: \n w3 建立  TCExam  帳號, 進行模擬考試. \n w4 Exam1 (5%) \n w8 Exam2 (5%) \n w9 Exam3 (5%) \n w12 Exam4 (5%) \n w16 Exam5 (5%) \n w18 Exam6 (5%) \n Github Repository and Pages (70%) \n 個人簡歷與課程進度心得 \n 課程內容操作影片 ( Wink3 ) \n 期中程式專案 \n 期末程式專案 \n 課程內容: \n 學員利用網頁建立個人簡歷 ( Curriculum Vitae ) \n 建立 Github 帳號: \n https://education.github.com/ \n 建立 Onedrive 帳號 \n 請各學員至  https://www.microsoft.com/zh-tw/education/products/office , 以 @nfu 帳號申請 OneDrive 儲存權限. \n 利用 Github 建立網頁: \n https://pages.github.com/ \n 維護 Github 上的網頁: \n 在近端將動態網頁轉為靜態網頁後, acp 至 Github 倉儲. \n 利用  Github Actions  將已推送之動態網頁轉為靜態網頁並自動改版. \n 可攜程式系統與網路設定 \n 個人電腦, 筆電與隨身碟 \n 網頁上的 Pyrhon 程式 \n 程式環境配置 \n Python 基本語法 \n html, css 與 Javascript \n 靜態繪圖 \n 動態繪圖 \n ANSI C 程式 \n Tiny C compiler and C 基本語法 \n GCC and C 基本語法 \n CPython 程式 \n C and Python Applications  (2022) \n Hands-on Matplotlib  (2022) \n Reference: \n cp2021', 'tags': '', 'url': 'cp-syllabus.html'}, {'title': 'cmsimde', 'text': 'WCM (Web based Content Management) 網際內容管理課程主要在研究改進  cmsimde  的功能與應用. \n cmsimde  是一套 Web-based content management system, 也就是基於全球資訊網的內容管理系統. \n 研究  Nuxt.js 結合 Flask \n 由於全球資訊網頁中主要使用 html, css 與 javascript 控制網頁內容, 因此在利用  cmsimde  管理數位內容時, 必須同時對這三種語言有一定的認識. \n 有關 html (html5) 請參考: \n HTML5 Mastery \n 假如要在網頁中嵌入 2D 物件, 請參考: \n https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API \n 假如要在網頁中嵌入 3D 物件, 請參考: \n Beginning WebGL for HTML5 \n 有關 css 請參考: \n Modern CSS \n 有關 Javascript 請參考: \n Beginning Javascript \n 為了  cmsimde  靜態頁面功能表的簡潔性, 一般建議除了 Home 之外的 H1 標題, 不要超過 9 個. 若善用各分類的 H2 與 H3 子頁面分類至多 9 個子頁面, 9x9x9 合計可以容納 729 個頁面, 應該足以涵蓋中等網站的所有內容. \n https://github.com/mdecycu/cmsimde \n 目前的課程網站 cmsimde submodule 已經使用 mdecycu 帳號下的倉儲, 準備要將現有分別位於 \n get_page2, render_menu2, 以及 sitemap2 函式中, 如下圖所示: \n \n 的 class=\'container-fluid\' 改為 class=\'container\', 根據  bootstrap containers  頁面的說明, 能夠將現有散佈在頁面 100% 的內容, 取用各不同尺寸螢幕的局部大小: \n \n cmsimde Template: \n https://github.com/mdecycu/cmsite \n cmsimde submodule update: \n 使用 cmsimde 作為 submodule 的倉儲, 當發現 cmsimde 倉儲內容已經更新後, 若希望使用更新後的子模組內容, 則可以利用下列指令完成: \n REM 從倉儲更換目錄至 cmsimde\ncd cmsimde\nREM 利用 git 指令中的 pull, 從 origin 代號的網路連結, 取回 master 分支的內容, 在近端進行合併\ngit pull origin master\nREM 回到原始倉儲目錄\ncd ..\nREM 利用 acp.bat 中的 git add, git commit 與 git push 將更新資料送到遠端 github 倉儲中\nacp "update cmsimde submodule" \n Are we living in a smart city (University, College, Department, Class, Group)? \n 我們生活在智慧城市或場域 (大學, 學院, 科系, 班級, 團隊) 嗎? \n Handbook of Smart Cities \n CMSiMDE 引用 ASCII STL方法: \n 將 ascii.stl 檔案上傳至 downloads 目錄後, 利用 File List 功能, 後列出 ascii.stl, 以滑鼠點擊會出現顯示 stl 檔案的頁面, 導入頁面時, 以 iframe 標註之 src 對應至顯示 stl 檔案的 html 連結即可, 例如:\xa0 <iframe width="600" height="400" src=""></iframe> \n src 在動態網站中為 /static/viewstl.html?src=/downloads/spikeball.stl \n', 'tags': '', 'url': 'cmsimde.html'}, {'title': 'Portable Python', 'text': '何謂可攜式 Python 程式環境? \n Python 程式是如何執行的? \n 首先 Python 是一種解譯式 (Interpreted) 程式語言, 與 C 或 C++ 程式語言最大的差別是, C/C++ 程式碼通常必須透過編譯 (Compile) 與連結 (Link) 的過程, 將原始碼轉為可執行的格式 (在 Windows 操作系統為 .exe 檔案), 而 Python 程式寫好後, 可以直接利用解譯器執行, 使用者不需要手動執行程式碼的編譯, 而是由解譯器在執行前即時將程式碼轉換為可執行檔案. \n 在  geeksforgeeks 網站 , 以下列敘述說明 Python 程式如何執行: \n Python is an object-oriented programming language like Java. Python is called an interpreted language. Python uses code modules that are interchangeable instead of a single long list of instructions that was standard for functional programming languages. The standard implementation of python is called "cpython". It is the default and widely used implementation of Python. \n Python doesn’t convert its code into machine code, something that hardware can understand. It actually converts it into something called byte code. So within python, compilation happens, but it’s just not into a machine language. It is into byte code (.pyc or .pyo) and this byte code can’t be understood by the CPU. So we need an interpreter called the python virtual machine to execute the byte codes \n 針對 Python 程式的"編譯"過程, 則 說明如下 : \n The Python program is converted into byte code. Byte code is a fixed set of instructions that represent arithmetic, comparison, memory operations, etc. It can run on any operating system and hardware. The byte code instructions are created in the .pyc file. The .pyc file is not explicitly created as Python handles it internally but it can be viewed with the following command: \n Y:\\tmp\\python_ex>python -m py_compile hello.py \n -m and py_compile represent module and module name respectively. This module is responsible to generate .pyc file. The compiler creates a directory named \xa0__pycache__ where it stores the hello.cpython-39.pyc file (若採用 Python 3.9 版次的編譯器). \n 至於針對 Python 程式的"解譯"執行過程, 則 說明如下 : \n The next step involves converting the byte code (.pyc file) into machine code. This step is necessary as the computer can understand only machine code (binary code). Python Virtual Machine (PVM) first understands the operating system and processor in the computer and then converts it into machine code. Further, these machine code instructions are executed by processor and the results are displayed. \n However, the interpreter inside the PVM translates the program line by line thereby consuming a lot of time. To overcome this, a compiler known as Just In Time (JIT) is added to PVM. JIT compiler improves the execution speed of the Python program. This compiler is not used in all Python environments like CPython which is standard Python software. \n To execute the hello.cpython-39.pyc we can use the following command: \n Y:\\tmp\\python_ex>python __pycache__\\hello.cpython-39.pyc \n 至於有關 python.exe 與 pythonw.exe 的差別, 則參見 這裡的說明 . 至於 SciTE 設定 python.properties 中, 使用 pythonw.exe -u 表示除了採非同步 (asynchronous) 執行模式外, 同時 force the stdout and stderr streams to be unbuffered; but has no effect on stdin. \n Python 解譯器的類別: \n 最早的 Python 解譯器以 C 程式語言編寫, 稱為  CPython , 以 Python 編寫的 Python 解譯器稱為  Pypy , 以 .NET 技術編寫的 Python 解譯器稱為  Ironpython , 以 Java 編寫的 Python 解譯器稱為  Jython , 以 Javascript 編寫的 Python 解譯器稱為  Brython . 以 Rust 編寫的 Python 解譯器稱為  RustPython . \n 建立可攜 Python 程式環境的目的: \n 一般在 Windows 10 中使用  CPython  都是透過操作系統安裝, 將  CPython  解譯器登錄在操作系統的  Registry  中. 只不過配置在操作系統的  CPython  解譯器若在使用過程中, 透過  pip  安裝額外的模組後, 當電腦輔助設計室中的電腦重新開機後, 操作系統將會因為安裝防寫套件而恢復原先所安裝無額外模組的狀態. \n 網際內容管理與協同產品設計實習課程為了 讓使用者可以隨身帶著  CPython  解譯器 , 因此繞過 Windows 10 操作系統的 Registry 登錄, 設法以批次檔案在虛擬的硬碟 (y:) 啟動  CPython  解譯環境. \n 此外, 配置在 USB 隨身碟的可攜  CPython  程式環境, 除了可執行一般 Python 程式外, 也可自行安裝所需模組, 並用於  cmsimde  動態與靜態網站編輯. \n 可攜程式環境中除  CPython , 還可配置  MSYS2  C/C++ 編譯系統. 針對  SciTE ,  Solvespace ,  Range3 ,  CoppeliaSim  等開源套件執行編譯. \n 如何建立可攜 Python 程式環境? \n 能放入 USB 隨身碟執行的 Python 程式環境包含兩個部分: \n (1) Python 解譯器系統檔案 \n (2) 可攜啟動設定批次檔 (例如:  start_ipv6.bat ) \n 要在 Windows 操作系統中, 取得各版本的 Python 解譯器系統檔案, 也有兩種方法: \n (1) 從官方網站下載安裝檔 (例如:  3.10.5 版 的  python-3.10.5-amd64.exe) , 手動安裝 Python, 取下安裝內容後, 解除安裝程式. \n (2) 利用  gen_portable_python.py , 從 Python 官方網站下載基本的 .msi 檔案 (例如  3.10.5 版 中的 core.msi, dev.msi, exe.msi, lib.msi, tcltk.msi 與 tools.msi), 然後利用  msiexec.exe  配合  targetdir  屬性解開各安裝檔. \n 以下將要結合  SciTE ,  Tiny C Compiler  與  Python 3.10.5 , 建立一個可攜版的 CPython 與  ANSI C  執行環境. \n \n 從  http://download.savannah.gnu.org/releases/tinycc/  下載\xa0 tcc-0.9.27-win64-bin.zip . \n 從  https://www.scintilla.org/SciTEDownload.html  下載  wscite521.zip . \n 利用 Python 3.9.5 (或先前的 Python3 舊版可攜程式) 執行  gen_portable_python.py  取得 Python310 解譯器系統檔案. \n 根據上述流程建立的基本 Python 與 ANSI C 可攜程式系統  Portable_py310_tcc.7z  (只能在系網路 下載, 此一 Python 解譯器只帶有基本模組且尚未安裝  get-pip.py ) \n 此一 Python 解譯器以 python  get-pip.py  安裝 pip 後, 再以 pip install flask flask_cors bs4 lxml pelican markdown leo pyopenssl 安裝  cmsimde 所需模組 後, 即可用於 wcm2022 動態與靜態系統的編輯. \n 此一 Python 解譯器再結合  Portablegit  與  PUTTY , 就可以支援以  SSH  執行 github 倉儲的 git push. \n \n 如何建立網際 Python 程式環境 (Brython)? \n 例如:  Brython  頁面. \n 從  portable_python_wcm2022.7z  下載的可攜程式環境有哪些功能? \n 請注意: 以下的 .7z 檔案下載, 只允許在系上網段上下載 . \n \n compile_copsim_cd2022.7z \xa0(file size: 5 GB, extracted size: 17.3 GB, 包含除了 NX1980 之外的所有課程相關可攜程式套件, 是專門為  cd2022  課程學員打造的套件). \n portable_python_wcm2022.7z  (file size: 513 MB, extracted size: 2.3 G, 這是專門為  wcm2022  課程打造的可攜程式套件, 適合選修學員下載後在任何 Windows 10 中以隨身碟啟動後操作) \n drive.7z  (file size: 2.6 MB, extracted size: 10 MB, 只包含 PUTTY, tcc, wscite 與 tmp 目錄, 採用 Hybrid 方式設定, 可與目前電腦輔助設計室中 SSD 硬碟所安裝的 Python 3.9.5 與  Portablegit  結合, 使用者只需自行設定啟動後的 home_ipv6 目錄與 home_ipv6/Desktop 目錄後即可以最輕薄便捷的方式將 SSH key 存入隨身碟, 並將個人與分組倉儲存入隨身碟啟動後的 tmp 目錄進行操作). \n \n 以下利用 Wink3 影片說明以 Hybrid 方式啟動的 USB 隨身碟如何建立? 以及使用上與完整 USB 隨身碟可攜程式系統的差別: \n Hybrid 可攜程式系統是只將必要檔案配置到 USB 隨身碟, 其餘檔案則使用已經存在電腦上的內容, 主要包含 Python 3.9.5 解譯程式 (863 MB) 與 Portblegit 2.31.1 (285 MB). \n Hybrid 可攜程式系統優點: \n \n 初始 USB 隨身碟只需複製 10.5 MB 的資料 (只自帶 PUTTY (4.3 MB), tcc (1.7 MB), tmp 與 wscite (4.3 MB)). \n 使用電腦 SSD 上所安裝的 Python 與 Portablegit, 執行速度會比一般 USB 隨身碟快. \n \n Hybrid 可攜程式系統缺點: \n \n 在未修改 Python Script 目錄中的 .exe 可執行檔之前, 必須透過 .py 執行, 例如: 命令列 中輸入 leo 並無法執行執行, 必須採用 import leo.core.runLeo;leo.core.runLeo.run() \n 若在裝有還原卡的電腦, 未修改 Python 系統模組路徑之前, 所安裝的額外模組無法放入 USB 隨身碟中. \n \n', 'tags': '', 'url': 'Portable Python.html'}, {'title': 'Token and SSH', 'text': 'Remote Desktop - Windows, Ubuntu, Mac \n Token: \n https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token \n Github token 是一串可以用來替代 Github 帳號與密碼功能的字串, 可在登入 Github 帳號後, 至  https://github.com/settings/tokens  設定. 每一個 token 都具備有效時間與權限範圍, 一般初學者可以只勾選 Token 的 repo 改版權限, 並選擇 30 天的有效時間. 之後再設法改用 SSH 對 Github 倉儲改版. \n 以下影片說明如何使用 Personal Access Token 執行 git push: \n \n \n \n SSH: \n https://docs.github.com/en/authentication/connecting-to-github-with-ssh \n Windows 10 環境中的 SSH 可以透過  https://www.putty.org/  執行設定. \n puttygen.exe 可用來建立 OpenSSL 格式的數位簽章, public key 送到使用者 Github 帳號下 settings 中的 SSH and GPG keys 區, 在隨身碟中則存放與 public key 成對的 Putty 格式 private key. \n 使用者在 Windows 10 使用 git + putty 時, 必須在啟動隨身系統時設定 GIT_SSH 變數 ( Git 環境變數 ) 至 putty 中的 plink.exe, 之後再利用 putty 設定連至 github.com 用的 session, 且在純 IPv6 環境中, 連至 github.com 的 session 除了必須指向隨身碟中的 private key 外, 還需要設定能同時支援 IPv6 與 IPv4 的 proxy server. \n 使用者希望透過 SSH 對 github 中的倉儲改版時, 必須使用  git@session_name:github_account/repository.git  連線. \n 有關 GIT_SSH 變數： \n GIT_SSH, if specified, is a program that is invoked instead of ssh when Git tries to connect to an SSH host. It is invoked like $GIT_SSH [username@]host [-p <port>] <command>. Note that this isn’t the easiest way to customize how ssh is invoked; it won’t support extra command-line parameters, so you’d have to write a wrapper script and set GIT_SSH to point to it. It’s probably easier just to use the ~/.ssh/config file for that. \n 以下影片說明如何在 Windows IPv6 環境下, 利用 PUTTY 以 SSH 協定執行 git push: \n \n \n \n \n', 'tags': '', 'url': 'Token and SSH.html'}, {'title': 'Bootstrap', 'text': 'cmsimde 頁面 layout 採用 Bootstrap 4.0 進行配置. \n https://getbootstrap.com/ \n cmsimde page: \n head banner \n search form \n page navigator \n page content \n pelican blog \n reveal \n Bootstrap editor: \n https://www.layoutit.com/ \n https://github.com/Vegetam/BootstrapPageGenerator \n Flask and Bootstrap: \n https://github.com/mbr/flask-bootstrap \n https://www.techwithtim.net/tutorials/flask/adding-bootstrap/ \n https://pythonhosted.org/Flask-Bootstrap/basic-usage.html \n https://github.com/MashSoftware/flask-bootstrap-ui \n https://github.com/hfilimonescu/flask-bs4', 'tags': '', 'url': 'Bootstrap.html'}, {'title': 'Bugs', 'text': '靜態網頁在 Brython 頁面無法執行關鍵字搜尋. \n', 'tags': '', 'url': 'Bugs.html'}, {'title': 'Frameworks', 'text': '目前 cmsimde 採用 Flask, 以下為其他相關 Frameworks: \n fastapi \n https://fastapi.tiangolo.com/ \n starlette \n https://www.starlette.io/', 'tags': '', 'url': 'Frameworks.html'}, {'title': 'Problem solving', 'text': 'Polya’s Problem Solving Techniques \n Game Design for Problem Solving with Python \n 問題一: \n https://mde.tw  網站的靜態網頁個數目前共有 79 頁, 其中, 只有  cp2022  與  cad2022  等兩個頁面置入  Disqus  討論版的程式連結. \n 已知納入動態網頁中的 Disqus 程式碼為  disqus_mdetw_scripts.txt , 請問若要在  https://mde.tw  各頁面中都加入此段程式碼, 該如何進行? \n 提示: \n 分別將 Disqus 程式碼, 在編輯階段納入頁面超文件內容? \n 了解  https://mde.tw  建立動態網頁與靜態網頁的架構, 以程式方法將 Disqus 程式碼加入所有頁面中? \n 直接透過程式方法, 讓  https://mde.tw  在產生動態與靜態網頁時, 自動附加特定的 Disqus 程式碼討論串? \n 問題二: \n 如何從學校教務主機取出有用資料? \n \n 1a 計算機程式修課學員名單  (取自教務主機) \n 1b 計算機程式修課學員名單  (取自教務主機) \n \n 問題三: \n 在機電產品開發過程中, 設計者該如何在各種成本 (costs) 約束條件中, 找到最佳的設計組合? \n Mechanical Design Optimization Using Advanced Optimization Techniques  (2012) \n \n', 'tags': '', 'url': 'Problem solving.html'}, {'title': 'Programming', 'text': 'Introduction to Programming Concepts with Case Studies in Python  (2012) \n Learn to Program with Python  (2016) \n Beginning Python  (2017) \n Learn to Program with Python 3  (2018) \n Python Graphics  (2018) \n PowerShell and Python Together  (2019) \n Foundation Dynamic Web Pages with Python  (2020) \n Algorithms on Trees and Graphs  (2021) \n Python Continuous Integration and Delivery  (2019) \n', 'tags': '', 'url': 'Programming.html'}, {'title': 'Computer', 'text': 'https://en.wikipedia.org/wiki/Computer \n', 'tags': '', 'url': 'Computer.html'}, {'title': 'Program', 'text': 'https://en.wikipedia.org/wiki/Computer_program \n', 'tags': '', 'url': 'Program.html'}, {'title': 'Python', 'text': 'https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers \xa0(整數 int(), 浮點數 float()) \n Strings \xa0(字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n', 'tags': '', 'url': 'Python.html'}, {'title': 'ANSIC', 'text': 'Based on  study.com : The C programming language was developed in the  Bell Labs  of AT&T by an employee called  Dennis Ritchie  between 1969 and 1973 while working on Unix operating system. He created this language using  ALGOL ,  BCPL , and  B  the languages that were used before C was created. He added many powerful features to C and used it to further develop the  UNIX  operating system.  American National Standards Institute  (ANSI) in 1983, formed a committee to provide a comprehensive definition to the C language and thus came into existence the new ANSI C language with better features. \n C Programming  (1999) \n Computer Programming in C for Beginners  (2020) \n // Our first program\n#include <stdio.h>\n#include <stdlib.h>\nint main()\n{\n    printf("Hello world!\\n");\n    return 0;\n} \n cp2022_ANSIC_w_tinyc_scite.7z  (for cp2022 @gm users only) /  cp2022_ANSIC_w_tinyc_scite.7z for @nfu \n // from https://stackoverflow.com/questions/6127503/shuffle-array-in-c\n#include <stdio.h> //for printf()\n#include <stdlib.h> //for srand() and rand()\n#include <time.h> //for time()\n#include <memory.h> //for memcpy()\n// 作業, 請計算各數值在各位數出現的總數, 是否依照亂數機率出現?\n// 作業, 請將此程式改用 Brython 編寫.\n\nvoid main ()\n{\n    int elesize = sizeof (int);\n    int i;\n    int j;\n    int r;\n    int num = 10;\n    int times = 50;\n    int src [num];\n    int tgt [num];\n    \n    srand ( (unsigned int) time (0) );\n    \n    for (j = 0; j < times; j++)\n    {\n        for (i = 0; i < num; src [i] = i++);\n        \n        for (i = num; i > 0; i --)\n        {\n            r = rand () % i;\n            memcpy (&tgt [num - i], &src [r], elesize);\n            memcpy (&src [r], &src [i - 1], elesize);\n        }\n        \n        for (i = 0; i < num; printf ("%d ", tgt [i++] ) );\n        printf("\\n");\n    }\n} \n 利用  Differential Evoluation  (差分進化演算法), 以  ANSI C  程式語言編寫適應方程式的最大化或最小化演算: \n volume_in_de_ex1.c \n 其他範例程式 \n 相同演算法, 以 CPython 解題: \n volume_in_de_ex1.py \n 相同演算法,  以 Brython 解題 . \n 此一採 固定表面積的紙盒體積最大化 運算範例,  volume_in_de_ex1.py  的原始作者為 李孟恭  ( https://github.com/kmollee/algorithm/blob/master/de.py ) \n 從  lw-oopc 的簡介  以及 升級版 lw-oopc 原始碼 中, 則可以進一步對 ANSI C 在嵌入式 (embedded) 系統上的應用有所了解. \n', 'tags': '', 'url': 'ANSIC.html'}, {'title': 'Rust', 'text': "Fornjot is an early-stage project to create a next-generation, code-first CAD application. \n https://www.fornjot.app/ \n Based on  Wikipedia : Rust is a multi-paradigm, general-purpose programming language. Rust emphasizes performance, type safety, and concurrency. Rust enforces memory safety—that is, that all references point to valid memory—without requiring the use of a garbage collector or reference counting present in other memory-safe languages.\xa0 To simultaneously enforce memory safety and prevent concurrent data races, Rust's borrow checker tracks the object lifetime and variable scope of all references in a program during compilation. Rust is popular for systems programming but also offers high-level features including functional programming constructs. Software developer  Graydon Hoare  ( comment  made on 2018.01.16) designed Rust while working at Mozilla Research in 2006.\xa0 Mozilla officially sponsored the project in 2009, and the designers refined the language while writing the Servo experimental browser engine and the Rust compiler. Rust's major influences include  SML ,  OCaml ,  C++ ,  Cyclone ,  Haskell , and  Erlang . Since the first stable release in January 2014, Rust has been adopted by companies including Amazon, Discord, Dropbox, Facebook (Meta), Google (Alphabet), and Microsoft. Rust has been noted for its growth as a newer language and has been the subject of academic programming languages research.\xa0 \n Beginning Rust  (2022) \n https://course.rs/about-book.html  (Rust 語言聖經) -  https://github.com/sunface/rust-course \n Rust: The Programming Language for Safety and Performance  ( local ) \n Even though this study was not comprehensive (and more work must be done in this area), it informs the programming and research communities on the promising features of Rust as the language of choice for the future. \n Rust is a systems programming language meant to supersede languages like C++. The main focus of Rust is (memory) safety, but it later began to target performance as well, adopting the C++ approach of zero cost abstraction. \n https://doc.rust-lang.org/book/ \n https://github.com/rust-lang/book \n https://github.com/cmsc388z/lectures \n https://www.ralfj.de/projects/rust-101/ \n https://github.com/rust-lang/mdBook \n https://github.com/rust-lang/miri \n https://github.com/lowenware/dotrix  (3D engine) \n", 'tags': '', 'url': 'Rust.html'}, {'title': 'Carbon', 'text': 'Carbon 語言 是 Google 開發希望能夠取代 C++ 的程式語言. \n https://github.com/carbon-language/carbon-lang \n https://github.com/carbon-language/carbon-lang/blob/trunk/README.md \n https://tipseason.com/carbon-language-tutorial-syntax/ \n https://blog.logrocket.com/exploring-carbon-new-superset-c-plus-plus/', 'tags': '', 'url': 'Carbon.html'}, {'title': 'TCExam', 'text': 'https://tcexam.org/ \n PHP 8 Solutions  (2022) \n https://netcorecloud.com/tutorials/send-an-email-via-gmail-smtp-server-using-php/ \n https://phppot.com/php/send-email-in-php-using-gmail-smtp/ \n https://myaccount.google.com/security \n Google has decided to begin phasing out Less Secure Apps from May 30th, 2022. Google Workspace and Google Cloud Identity users won’t be affected right away, but support for Less Secure Apps will still be phased out for those users at a later date. \n turn on two factor authentication for your Google account \n https://phppot.com/php/sending-email-using-phpmailer-with-gmail-xoauth2/ \n https://stackoverflow.com/questions/22335574/phpmailer-send-email-using-gmail-oauth2 \n PHPMailer with Oauth2 \xa0\xa0\xa0 \n', 'tags': '', 'url': 'TCExam.html'}, {'title': 'sendmail', 'text': 'https://tcexam.org/  線上考試系統允許使用者自行建立帳號, 並選擇參與特定 Group (即與帳號對應的課程, 若同時選擇多個 CYCU 所開設的線上考試課程, 則必須在建立帳號時參與多個 Groups). \n 當使用者忘記註冊時所選用的密碼時, 原系統允許使用者透過所登錄的 email 收信, 以便重新設定密碼. \n 但此一 sendmail 必須由 php 程式配合 php.ini 進行設定. 先前 Gmail 帳號允許使用較低權限的設定進行 sendmail, 但此功能已經從一般 Gmail 帳號中移除. 而目前仍保留降低 Gmail 權限的功能僅限 Workspace 的用戶 (即先前的 GSuite 用戶), 但隨後 Google 也已經宣布將逐一移除此項功能. \n 因應 Google 此項變更, 預計在 2022 Fall 或仍可使用 Google Workspace 下的帳號進行送信 (例如: mde.nfu.edu.tw 或 eng.nfu.edu.tw), 但最終還是必須透過 Gmail API 進行程式化的 sendmail. \n \n', 'tags': '', 'url': 'sendmail.html'}, {'title': 'Three.js', 'text': 'https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene \n https://riptutorial.com/Download/three-js.pdf \n https://github.com/josdirksen/learning-threejs-third \n https://www.jotform.com/blog/20-exceptional-three-js-experiments-98740/ \n \n \n  先定義 id 為 threejs 的 canvas  \n \n  從 downloads 目錄下導入 three.min.js 程式庫  \n \n \n \n  以下直接利用 three.js 在 id 為 threejs 的 canvas 上建立 3D 場景  \n \n \n \n \n', 'tags': '', 'url': 'Three.js.html'}, {'title': 'ffmepg', 'text': 'FFmpeg 手冊:  http://ffmpeg.org/ffmpeg.html \n 擷取 mp4 片段檔案 \n 從 origin.mp4 影片中的第一秒開始, 切出 15 分鐘的影片, 存為 new.mp4 \n ffmpeg -i origin.mp4 -ss 00:00:01 -t 00:15:00 -async 1 new.mp4 \n 刪除影片中的聲音資料 \n ffmpeg -i origin.mp4 -c copy -an new.mp4 \n 合併 mp4 檔案 \n 建立 allmp4.txt 內容為 file \'/path/to/1.mp4\' file \'/path/to/2.mp4\' file \'/path/to/3.mp4\' \n 將 1.mp4, 2.mp4 與 3.mp4 合併為 new.mp4 \n ffmpeg -f concat -i allmp4.txt -c copy new.mp4 \n 影片中加入字幕 \n 利用  http://www.aegisub.org/  可攜版本工具加入字幕 \n 直接將 input.srt 字幕資料 burn 入 input.mp4 \n ffmpeg -i input.mp4 -vf subtitles=input.srt output.mp4 \n 影片畫面中座標 x=5, y=950 位置中加入圖檔 \n \n ffmpeg -i input.mp4 -i kmol_102x30_color.png -filter_complex "overlay=5:950" output.mp4 \n 其他圖形化工具: \n http://www.aegisub.org/ \xa0(Font: SimSun, Size: 40, Bold, Primary, Color (255, 200, 5)) \n http://www.avidemux.org/nightly/win64_support/ \xa0(建立使用 2.6.21 版本, 可與 aegisub 配合使用) \n https://www.openshot.org/ \xa0(必須分段輸入字幕, 無法與 aegisub 配合使用)', 'tags': '', 'url': 'ffmepg.html'}, {'title': 'Pandoc', 'text': 'https://pandoc.org/ \n cmsimde -> LaTex -> Github Actions -> PDF \n https://github.com/mdecycu/4072pj1 \n https://github.com/mdecycu/pj4082 \n https://stackoverflow.com/questions/52396579/can-i-convert-github-pages-with-jekyll-to-pdf \n https://github.com/topics/html-to-pdf \n https://github.com/chiamingyen/sphinxBook', 'tags': '', 'url': 'Pandoc.html'}, {'title': 'VSCode', 'text': 'EBooks: \n Visual Studio Code Distilled  (2021) \n Optimizing Visual Studio Code for Python Development  (2021) \n Portable mode of Visual Studio Code: \n https://code.visualstudio.com/docs/editor/portable  (338 MB) \n Download .zip file and add a data directory to enable the Portable mode of VSCode. \n Leo for VSCode: \n https://marketplace.visualstudio.com/items?itemName=boltex.leointeg \n', 'tags': '', 'url': 'VSCode.html'}, {'title': 'Powershell', 'text': 'PowerShell and Python Together  (2019) \n PowerShell for Beginner  (2021) \n PowerShell Fast Track  (2022) \n https://www.servertribe.com/difference-between-cmd-vs-powershell-vs-bash/ \n https://stackoverflow.com/questions/44032838/are-all-cmd-commands-available-within-powershell \n', 'tags': '', 'url': 'Powershell.html'}, {'title': 'Blockchain', 'text': 'Blockchain Technology \n', 'tags': '', 'url': 'Blockchain.html'}, {'title': 'Brython', 'text': '\n local and cloud server collaborative design \n \n PC Client 內容 \n \n Win Server 內容 \n Brython at Google Groups \n 請利用 Chrome 或 Edges 開啟  https://sim.firialabs.com/ , 研究一下此類程式是如何建構的? \n https://microsoft.github.io/monaco-editor/ \xa0 \n License:  https://sim.firialabs.com/static/js/2.5a0286f3.chunk.js.LICENSE.txt \n https://github.com/facebook/react \n https://github.com/jonschlinkert/repeat-string \n https://lodash.com/ \n https://github.com/cssinjs/jss \n https://github.com/PrismJS/prism \n https://gist.github.com/FezVrasta/76f51d521cc42099a78ca46be593ba90 \n The Python Workbook  (2014) - 程式練習題 \n Introduction to Python for Kids  (2021) - Turtle graphics \n ROC 國旗規格   PROC 國旗規格   USA 國旗規格 \n Gist Brython scripts \n Cango \n turtle.py \n turtle_graphics.pdf  ( source ) \n turtle_graphics_2.pdf  ( source ) \n turtle_graphics_3.pdf  ( source ) \n https://github.com/mdecycu/Gesture-Controlled-Snake-Game \n \n \n \n \n  for ggame  \n \n \n \n \n \n \n \n \n  Cango 程式庫  \n \n \n \n \n \n \n \n \n  for Konva 程式庫  \n \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n add 1 to 100 p261 ROC flag PROC flag USA flag Draw Grid Random Rect Rect Walk Rect U Walk Rect rev U Walk 單節貪食蛇 5 個紅點方塊 Snake BSnake auto_guess ball bezier big_lotto brython_kw bunny cango_spur cango_spur1 cango_three_gears clear clock convert_temp deepmerge display_stl draw ex1 ex2 ex3 ex4 fibo fourbar guess_a_number hw1_1 hw1_2 Keycode knova1 merge3 power_lotto spur spur_w_form stl_binary_ascii stl_writer Tetris Auto Tetris turtle1 turtle2 turtle3 turtle4 turtle5 turtle6 turtle7 turtle8 twl_link_ik webcam websocket ycqsort \n  ######################  editor1 開始 ######################  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div 作為切入位置  \n  這裡的畫布 id 為 brython_div  \n \n  graphics-column is for ggame  \n \n  ######################  editor1 結束 ######################  \n  以下可以開始利用 editor1 的設定編寫對應 Brython 程式  \n \n  以上為內建程式, 頁面可透過 ?src=gist_url 執行  \n  add 1 to 100 開始  \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Unitconvert', 'text': '攝氏與華氏溫度單位換算程式編寫: \n \n 請在個人網頁上的 H1 標題為大寫 HW 頁面中增加一個 H2 標題小寫 w12 的頁面, 並將攝氏與華氏溫度單位轉換的公式列入. \n 請利用 https://www.diagrams.net 繪製一個攝氏與華氏溫度轉換的程式設計流程圖, 完成後將流程圖轉為 .png 格式後嵌入 w12 頁面中. \n 請根據程式設計流程圖, 在 w12 頁面中直接加入一個 Brython 程式, 使能在頁面中印出今天的日期、時間與該時間點的攝氏及華氏溫度. 例如: 今天是 2022 年 11 月 24 日, 現在時間 10:35, 攝氏溫度為 29 度, 華氏為 84.2 度. \n 接下來請利用 Brython 程式語法中的 input() 在 w12 頁面中讓使用者按下"溫度換算"按鈕後, 跳出讓使用者輸入攝氏溫度值, 讓溫度單位轉換程式運算後, 可以同時列出使用者所輸入的攝氏與華氏溫度值. \n \n input() 取得的資料型別為字串 \n # Brython 的 input() 可以接受輸入提示字串, 跳出瀏覽器輸入表單後, 將輸入內容以字串取回\nuser_input_temp = input("請輸入攝氏溫度值:")\n# 接著列出 user_input_temp 變數的資料型別\nprint(type(user_input_temp)) \n 從上面的範例, 可知 Brython input() 取回使用者的輸入值之後, 傳回的變數資料型別為 str, 也就是字串, 即便使用者輸入 30 整數, 但就程式而言, 取回 30 之後, 會將這個變數視為字串, 因此隨後的程式運算, 應該要將此變數轉為浮點數 (floating number), 因為使用者可能會輸入帶有小數點的資料. 要將字串轉為浮點數, 可以使用 float() 函式. \xa0 當然, 使用者也可能會輸入不是數值的資料, 所以之後若要讓溫度轉換程式能更加人性化, 或者防呆, 就必須在瀏覽器前端 (反應較即時) 或伺服器後端 (若在前端取值後, 再設法將資料傳回後端電腦處理, 則反應較為耗時, 但可收集使用者在瀏覽器前端的所有輸入及操作行為數據). \xa0 接下來要將字串轉為浮點數: \n input(), float() 與 type() 的用法 \n \'\'\'\nf = c*9/5 + 32\nc = (f-32)*5/9\n\'\'\'\nc = input("請輸入攝氏溫度值")\nc = float(c)\nprint(c, type(c)) \n 利用數學運算將攝氏轉為華氏 \n \'\'\'\nf = c*9/5 + 32\nc = (f-32)*5/9\n\'\'\'\nc = input("請輸入攝氏溫度值")\nc = float(c)\n#print(c, type(c))\nf = c*9/5 + 32\nprint(c, f) \n 溫度轉換程式練習至此, 都只是在動態或靜態網站已經配置好 Brython 執行環境的頁面中執行, 接下來我們將要直接在 w12 頁面中配置 Brython 環境, 並且在其中列出使用者透過 input() 函式的輸入資料: \n 動態網頁中的 Brython 環境設置 \n <h3>w12</h3>\n<!-- \n在動態網站頁面中啟用 Brython 執行環境的用法, 請注意動態網站執行所在路徑\n-->\n<script src="./../cmsimde/static/brython.js"></script>\n<script src="./../cmsimde/static/brython_stdlib.js"></script>\n<!-- 啟動 Brython -->\n<p>\n<script>// <![CDATA[\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'/downloads/py/\']});\n}\n// ]]></script>\n<!-- 以下事先在頁面中加入 id="brython_div" 的 div 標註\n之後可利用 Brython 的 document 模組與此 html 標註對應\n--></p>\n<div id="brython_div"></div>\n<p>\n<script type="text/python">// <![CDATA[\nfrom browser import html, document\n# Brython 的 input() 可以接受輸入提示字串, 跳出瀏覽器輸入表單後, 將輸入內容以字串取回\nuser_input_temp = input("請輸入攝氏溫度值:")\n# 接著列出 user_input_temp 變數的資料型別\n# 但是在頁面中 Brython 的 print() 將會顯示在 log 而非頁面\nprint(type(user_input_temp))\n# 這裡定義一個 brython_div 變數, 透過 document[] 與頁面中 id="brython_div" 的位置對應\nbrython_div = document["brython_div"]\n# 看能不能直接將變數值字串列在標註 id 為 "brython_div" 的頁面位置\nbrython_div <= user_input_temp\n# 之後若要列出 html, 則需要透過 Brython 的 html 模組\n// ]]></script>\n</p> \n 上面在動態網頁中的 w12 超文件網頁, 只要連結就會直接跳出取值表單的設計, 並不是很人性化, 因為使用者連結至 w12 可能只想看看該頁面內, 不一定希望執行取值或溫度轉換, 因此必須設法製作一個按鈕, 讓使用者按下按鈕之後才執行特定的程式內容. \xa0 因此將 w12 頁面改為 w12-1 頁面, 以 html 建立一個帶有 id 的 button 標註, 並在原有的 Brython 程式段中設定一個按鈕與表單取值程式的綁定 (bind), 只有當使用者按下按鈕時, 才會根據綁定設計, 呼叫表單取值. \n 設計超文件按鈕與特定函式綁定 \n <h3>w12-1</h3>\n<!-- \n在動態網站頁面中啟用 Brython 執行環境的用法, 請注意動態網站執行所在路徑\n-->\n<script src="./../cmsimde/static/brython.js"></script>\n<script src="./../cmsimde/static/brython_stdlib.js"></script>\n<!-- 啟動 Brython -->\n<p>\n<script>// <![CDATA[\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'/downloads/py/\']});\n}\n// ]]></script>\n<!-- 以下事先在頁面中加入 id="brython_div" 的 div 標註\n之後可利用 Brython 的 document 模組與此 html 標註對應\n--></p>\n<!-- 利用 html 建立一個 id="btn1" 的按鈕 -->\n<p><button id="btn1">取使用者輸入</button></p>\n<div id="brython_div"></div>\n<p>\n<script type="text/python">// <![CDATA[\nfrom browser import html, document\n# Brython 的 input() 可以接受輸入提示字串, 跳出瀏覽器輸入表單後, 將輸入內容以字串取回\n#user_input_temp = input("請輸入攝氏溫度值:")\n# 接著列出 user_input_temp 變數的資料型別\n# 但是在頁面中 Brython 的 print() 將會顯示在 log 而非頁面\n#print(type(user_input_temp))\n# 這裡定義一個 brython_div 變數, 透過 document[] 與頁面中 id="brython_div" 的位置對應\nbrython_div = document["brython_div"]\n# 看能不能直接將變數值字串列在標註 id 為 "brython_div" 的頁面位置\n#brython_div <= user_input_temp\n# 之後若要列出 html, 則需要透過 Brython 的 html 模組\n# 接下來要設法按下按鈕之後才執行取使用者 input 的流程\n# 首先 comment 掉前面的 input() 與 print(), 同時蓋掉輸出, 並利用事件導向設計一個函式\ndef get_input(env):\n    user_input_temp = input("請輸入攝氏溫度值:")\n    brython_div <= user_input_temp\n# 透過 Brython browser 模組中的 document 物件將 id="btn1" 的物件中的 bind() 方法\n# 讓使用者 click 後會經由瀏覽器中的 event 通知執行 get_input 函式\ndocument["btn1"].bind(\'click\', get_input)\n// ]]></script>\n</p> \n 程式設計到這裡, 不知道有沒有同學想起來, 截至目前所寫的程式都是在瀏覽器前端, 使用者可以透過瀏覽器跳出的表單輸入攝氏溫度值, 然後要求 Brython 程式進行運算轉換, 但是若想要將使用者輸入的值儲存起來, 或者利用使用者輸入的溫度值, 用來設定位於遠端 (Server 端) 的一台冷氣, 該如何將前端表單輸入內容, 送到伺服器端? \xa0 以下將採用 AJAX 將 Brython 表單程式所取得的溫度數值, 以 GET 方式送到伺服器: \n Brython 以 AJAX 將資料送到 Flask \n <h3>w12-2</h3>\n<!-- \n在動態網站頁面中啟用 Brython 執行環境的用法, 請注意動態網站執行所在路徑\n-->\n<script src="./../cmsimde/static/brython.js"></script>\n<script src="./../cmsimde/static/brython_stdlib.js"></script>\n<!-- 啟動 Brython -->\n<p>\n<script>// <![CDATA[\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'/downloads/py/\']});\n}\n// ]]></script>\n<!-- 以下事先在頁面中加入 id="brython_div" 的 div 標註\n之後可利用 Brython 的 document 模組與此 html 標註對應\n--></p>\n<!-- 利用 html 建立一個 id="btn1" 的按鈕 -->\n<p><button id="btn1">取使用者輸入</button></p>\n<div id="brython_div"></div>\n<p>\n<script type="text/python">// <![CDATA[\nfrom browser import html, document, ajax\n# Brython 的 input() 可以接受輸入提示字串, 跳出瀏覽器輸入表單後, 將輸入內容以字串取回\n#user_input_temp = input("請輸入攝氏溫度值:")\n# 接著列出 user_input_temp 變數的資料型別\n# 但是在頁面中 Brython 的 print() 將會顯示在 log 而非頁面\n#print(type(user_input_temp))\n# 這裡定義一個 brython_div 變數, 透過 document[] 與頁面中 id="brython_div" 的位置對應\nbrython_div = document["brython_div"]\n# 看能不能直接將變數值字串列在標註 id 為 "brython_div" 的頁面位置\n#brython_div <= user_input_temp\n# 之後若要列出 html, 則需要透過 Brython 的 html 模組\n# 接下來要設法按下按鈕之後才執行取使用者 input 的流程\n# 首先 comment 掉前面的 input() 與 print(), 同時蓋掉輸出, 並利用事件導向設計一個函式\ndef complete(request):\n    pass\ndef get_input(env):\n    user_input_temp = input("請輸入攝氏溫度值:")\n    url = "http://127.0.0.1:8080/?temp=" + user_input_temp\n    ajax.get(url, oncomplete=complete)\n    brython_div <= "已經透過 AJAX 採 GET 將溫度輸入值送到 server"\n    brython_div <= html.BR()\n    brython_div <= user_input_temp\n    brython_div <= html.BR()\n# 透過 Brython browser 模組中的 document 物件將 id="btn1" 的物件中的 bind() 方法\n# 讓使用者 click 後會經由瀏覽器中的 event 通知執行 get_input 函式\ndocument["btn1"].bind(\'click\', get_input)\n// ]]></script>\n</p>\n<!--\n以下為 Flask 伺服器端的程式碼\nfrom flask import Flask, request \nfrom flask_cors import CORS\n  \napp = Flask(__name__)\nCORS(app)\n@app.route(\'/\', methods=[\'GET\'])\ndef index():\n    # 利用 Flask request 取得 GET 模式下的 temp 變數值\n    # 若 temp 無值, 則內定為 "30"\n    temp = request.args.get(\'temp\', default="30")\n    # 當使用者在瀏覽器執行 Brython 程式時, 可以利用 GET 將 temp 變數值傳給 server 端的 Flask Python 程式\n    # 若瀏覽器前端採 form 表單取值, 則 Flask 可以 request.form.get() 取值\n    return "已經取得 temp: " + str(temp)\n  \nif __name__ == \'__main__\':\n    app.run(host=\'127.0.0.1\', port=8080, debug=True)\n--> \n 使用者若希望測試在 w12-2 網頁中點擊按鈕, 輸入溫度值, 然後透過 AJAX 傳值, 必須在近端 (可以利用 SCiTE) 先啟動以下的 localhost Server 程式: \n 與 Brython 前端互動的 Flask 伺服器程式 \n from flask import Flask, request \nfrom flask_cors import CORS\n  \napp = Flask(__name__)\nCORS(app)\n@app.route(\'/\', methods=[\'GET\'])\ndef index():\n    # 利用 Flask request 取得 GET 模式下的 temp 變數值\n    # 若 temp 無值, 則內定為 "30"\n    temp = request.args.get(\'temp\', default="30")\n    # 當使用者在瀏覽器執行 Brython 程式時, 可以利用 GET 將 temp 變數值傳給 server 端的 Flask Python 程式\n    # 若瀏覽器前端採 form 表單取值, 則 Flask 可以 request.form.get() 取值\n    return "已經取得 temp: " + str(temp)\n  \nif __name__ == \'__main__\':\n    app.run(host=\'127.0.0.1\', port=8080, debug=True) \n 程式設計到這裡, 若 Brython 中使用者輸入的數值, 是用來設定遠端的 NX2027 零件尺寸或其他設計分析用的數據, 則 Server 端的程式只要再透過 NXOpen Python API 與 NX2027 CAD/CAE/CAM 套件進行互動即可, 無論是零件設計、工程分析或輔助製造都可以利用上述架構, 透過網路結合瀏覽器前端程式與伺服器後端的各種軟硬體進行整合. \n', 'tags': '', 'url': 'Unitconvert.html'}, {'title': 'Game', 'text': 'Advanced Game Design with HTML5 and JavaScript  (2015)', 'tags': '', 'url': 'Game.html'}, {'title': 'Simulator', 'text': 'CodeSpace Development Environment (firialabs.com) \n https://groups.google.com/g/brython/c/0kA4pM1YirE \n', 'tags': '', 'url': 'Simulator.html'}, {'title': 'Algorithms', 'text': 'Python Algorithms  (2010) \n Python Algorithms Second Edition  (2014) \n', 'tags': '', 'url': 'Algorithms.html'}, {'title': 'CPython', 'text': 'Based on  Wikipedia : Python is a high-level, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation. Python is dynamically-typed and garbage-collected. It supports multiple programming paradigms, including structured (particularly procedural), object-oriented and functional programming. It is often described as a "batteries included" language due to its comprehensive standard library. Guido van Rossum  began working on Python in the late 1980s as a successor to the  ABC  programming language and first released it in 1991 as Python 0.9.0. Python 2.0 was released in 2000 and introduced new features such as list comprehensions, cycle-detecting garbage collection, reference counting, and Unicode support. Python 3.0, released in 2008, was a major revision that is not completely backward-compatible with earlier versions. Python 2 was discontinued with version 2.7.18 in 2020. \n 比對兩份資料, 列出差異: \n 數列應用 \n for 重複迴圈 \n 以 utf-8 編碼讀出檔案內容 \n splitlines() 函式逐行將檔案內容放入數列 \n if 判斷式應用 \n # 兩份資料所在目錄字串\nstudlist_path = "Y:/studlist/2022spring/"\nscore_path = "Y:/score/2022/spring/"\n# score 區檔案套稿字串\nscore_file_temp = "_stud_list.txt"\n# 班級代號數列\nclasses = ["1a", "2a", "2b", "5j"]\n\n# 利用 for 迴圈, 逐班進行處理\nfor i in classes:\n    # read data from studlist\n    # 以 utf-8 編碼開啟檔案\n    with open(studlist_path + i + ".txt", encoding="utf-8") as f:\n        studlist_data = f.read().splitlines()\n    #print(studlist_data)\n    with open(score_path + i + "/" + i + score_file_temp, encoding="utf-8") as f:\n        score_list_data = f.read().splitlines()\n    #print(score_list_data)\n    for i in studlist_data:\n        stud_num = i.split("\\t")[0]\n        #print(stud_num)\n        # 列出已經不在評分名單中的學號\n        if stud_num not in score_list_data:\n            print(stud_num) \n MS Teams assignment downloaded directory rename: \n os 模組的 walk() 應用 \n next() 應用 \n 讀取檔案內容 \n splitlines() 將各行資料納入數列 \n dictionary 資料結構應用 \n for 重複迴圈應用 \n try 與 except 應用 \n os 模組的 rename() 應用 \n import os\n\n\'\'\'\nMS Teams student submitted assignment files can be downloaded through SharePoint App, but directory named as student name,\nwe may use this program to rename directory into student number\n\'\'\'\n# from https://stackoverflow.com/questions/141291/how-to-list-only-top-level-directories-in-python\n# rename directory: os.rename(source,destination)\nstud_name_list = next(os.walk(\'./cd2022_student\'))[1]\n#print(stud_name_list)\n# read data from wcm2022_5j_stud_name_email.txt\n# firstname \\t lastname \\t email\nwith open("cd2022_stud_name_email.txt", encoding="utf-8") as f:\n    data = f.read().splitlines()\n# set stud_name and stud_num into dict\nstud_dict = {}\n# skip the first line\nfor i in data[1:]:\n    line = i.split("\\t")\n    firstname = line[0]\n    lastname = line[1]\n    # get student number from email\n    stud_num = line[2].split("@")[0]\n    stud_dict[lastname+firstname] = stud_num\nprint(stud_dict)\ndir_pre = \'./cd2022_student/\'\n# loop stud_name_list and rename into stud_num\nfor i in stud_name_list:\n    try:\n        os.rename(dir_pre+i, dir_pre+stud_dict[i])\n        print("rename ", i, " into ", stud_dict[i])\n    except:\n        print(i, "no data")\n \n Use old Python to create new portable Python: \n gen_portable_python.py \n import urllib.request\nimport os\n\n# basic files for Python installation\npy_list = ["core", "dev", "exe", "lib", "tcltk", "tools"]\n# Python version\nversion = "3.10.6"\n# location for Portable Python\npath = "c:\\\\tmp\\\\Python310"\n# Python msi download URL\nftp = "https://www.python.org/ftp/python/" + version + "/amd64/"\nextract_path = path + "\\\\extract"\n# create directory\ntry:\n    os.mkdir(path)\nexcept:\n    # path exists\n    pass\n# get Python installation msi files and extract into target dir\nfor i in py_list:\n    filename = i + ".msi"\n    url = ftp + filename\n    # download basic python msi file\n    urllib.request.urlretrieve(url, path+ "\\\\"+ filename)\n    os.system("msiexec.exe /a " + path + "\\\\" + i + ".msi /qb targetdir=" + extract_path)\n    # delete msi file\n    os.remove(extract_path + "\\\\" + i + ".msi") \n search cmd to open command line window. \n cd to c:\\tmp where gen_portable_python.py located. \n c:\\tmp>c:\\old_python_path\\python gen_portable_python.py \n', 'tags': '', 'url': 'CPython.html'}, {'title': 'PDF', 'text': '從單機程式到全球資訊網服務: \n Essential Computer Science  是 2021 年出版的電子書, 在校園裡可以直接下載 pdf 檔案, 以下 CPython 程式套用  PyPDF2  模組, 可以分割或合併 pdf 檔案. \n # pip install PyPDF2\nfrom PyPDF2 import PdfFileWriter, PdfFileReader\nimport os\n\ndef SplitPdf(pdfFileName, newFileName, fromPage, toPage):\n\n    """Action to split user uploaded files\n    """\n\n    pdfReader = PdfFileReader(open(pdfFileName, "rb"))\n    information = [(newFileName, fromPage, toPage)]\n    pdf_writer = PdfFileWriter()\n    pdf_writer.addPage(pdfReader.getPage(1))\n    for i in range(13, 18):\n        pdf_writer.addPage(pdfReader.getPage(i))\n    \n    for page in range(len(information)):\n        start = information[page][1]\n        end = information[page][2]\n        while start<=end:\n            pdf_writer.addPage(pdfReader.getPage(start-1))\n            start+=1\n        if not os.path.exists("./"):\n            os.makedirs(savepath)\n        output_filename = \'{}_{}_page_{}.pdf\'.format(information[page][0], information[page][1], information[page][2])\n        with open(output_filename,\'wb\') as out:\n            pdf_writer.write(out)\n\n    outstring = "已經將 " + pdfFileName + " 中的第 " + str(fromPage) + " 到第 " + str(toPage) + "頁, 存為 " + output_filename\n\n    return outstring\n\ndef CombinePdf(pdfFileNames, newFileName):\n\n    """Action to split user uploaded files\n    """\n    \n    # pdfFileNames is []\n    pdf_write_object = PdfFileWriter()\n\n    filenameString = ""\n    \n    for filename in pdfFileNames:\n        pdf_read_object = PdfFileReader(open(filename, "rb"))\n        filenameString += filename + ", "\n        for page in range(pdf_read_object.numPages):\n            pdf_write_object.addPage(pdf_read_object.getPage(page))\n     \n    final_file_object = open(newFileName + ".pdf", \'wb\')\n    pdf_write_object.write(final_file_object)\n    final_file_object.close()\n\n    outstring = "已經將 " + filenameString+ " 合併為: "+ newFileName + ".pdf"\n\n    return outstring\n \npdfFileName = "2021_Book_EssentialComputerScience.pdf"\nnewFileName = "cp2022_textbook_part1.pdf"\nfromPage = 21\ntoPage = 98\nSplitPdf(pdfFileName, newFileName, fromPage, toPage)\nprint("done") \n 上列程式只能在單機執行, 假如再套用  Flask  全球資訊網框架. 就可以將單機程式配置在 server 上, 讓參與協同產品設計的成員可以在任何地方透過瀏覽器使用分割與合併 pdf 檔案的功能. \n cp2022_CPython_pypdf2_Flask_project1.7z  (for cp2022 @gm users only) /  cp2022_CPython_pypdf2_Flask_project1.7z for @nfu \n \n', 'tags': '', 'url': 'PDF.html'}, {'title': 'RoboDK', 'text': 'https://robodk.com/ \n https://robodk.com/doc/en/Basic-Guide.html   \n https://github.com/RoboDK/RoboDK-API/tree/master/Python   \n https://www.making.unsw.edu.au/learn/robodk-learn-module/   \n Install-RoboDK-64-v5.2.2.exe ( 5.2.2 ) \n Install-RoboDK-64-v5.5.1.exe ( 5.5.1 ) \n robodk_python_api_example.7z \n pick_and_place.py \n # KMOLab Portable RoboDK pick and place\nfrom robolink import *    # API to communicate with robodk\nfrom robodk import *      # robodk robotics toolbox\n\n# Setup global parameters\nBALL_DIAMETER = 100 # diameter of one ball\nAPPROACH = 100      # approach distance to grab each part, in mm\nnTCPs = 6           # number of TCP\'s in the tool\n\n#----------------------------------------------\n# Function definitions\n\ndef box_calc(BALLS_SIDE=4, BALLS_MAX=None):\n    """Calculate a list of points (ball center) as if the balls were stored in a box"""\n    if BALLS_MAX is None: BALLS_MAX = BALLS_SIDE**3\n    xyz_list = []\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE):\n            for j in range(BALLS_SIDE):\n                xyz_list = xyz_list + [[(i+0.5)*BALL_DIAMETER, (j+0.5)*BALL_DIAMETER, (h+0.5)*BALL_DIAMETER]]\n                if len(xyz_list) >= BALLS_MAX:\n                    return xyz_list\n    return xyz_list\n\ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n\ndef balls_setup(frame, positions):\n    """Place a list of balls in a reference frame. The reference object (ball) must have been previously copied to the clipboard."""\n    nballs = len(positions)\n    step = 1.0/(nballs - 1)\n    for i in range(nballs):\n        newball = frame.Paste()\n        newball.setName(\'ball \' + str(i)) #set item name\n        newball.setPose(transl(positions[i])) #set item position with respect to parent\n        newball.setVisible(True, False) #make item visible but hide the reference frame\n        newball.Recolor([1-step*i, step*i, 0.2, 1]) #set RGBA color\n\ndef cleanup_balls(parentnodes):\n    """Delete all child items whose name starts with \\"ball\\", from the provided list of parent items."""\n    todelete = []\n    for item in parentnodes:\n        todelete = todelete + item.Childs()\n\n    for item in todelete:\n        if item.Name().startswith(\'ball\'):\n            item.Delete()\n\ndef TCP_On(toolitem, tcp_id):\n    """Attach the closest object to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""\n    toolitem.AttachClosest()\n    toolitem.RDK().RunMessage(\'Set air valve %i on\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_On(%i)\' % (tcp_id+1));\n        \ndef TCP_Off(toolitem, tcp_id, itemleave=0):\n    """Detaches the closest object attached to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""\n    toolitem.DetachAll(itemleave)\n    toolitem.RDK().RunMessage(\'Set air valve %i off\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_Off(%i)\' % (tcp_id+1));\n\n\n#----------------------------------------------------------\n# The program starts here:\n\n# Any interaction with RoboDK must be done through RDK:\nRDK = Robolink()\n\n# Turn off automatic rendering (faster)\nRDK.Render(False)\n\n#RDK.Set_Simulation_Speed(500); # set the simulation speed\n\n# Gather required items from the station tree\nrobot = RDK.Item(\'Fanuc M-710iC/50\')\nrobot_tools = robot.Childs()\n#robottool = RDK.Item(\'MainTool\')\nframe1 = RDK.Item(\'Table 1\')\nframe2 = RDK.Item(\'Table 2\')\n\n# Copy a ball as an object (same as CTRL+C)\nballref = RDK.Item(\'reference ball\')\nballref.Copy()\n\n# Run a pre-defined station program (in RoboDK) to replace the two tables\nprog_reset = RDK.Item(\'Replace objects\')\nprog_reset.RunProgram()\n\n# Call custom procedure to remove old objects\ncleanup_balls([frame1, frame2])\n\n# Make a list of positions to place the objects\nframe1_list = pyramid_calc(4)\nframe2_list = pyramid_calc(4)\n\n# Programmatically place the objects with a custom-made procedure\nballs_setup(frame1, frame1_list)\n\n# Delete previously generated tools\nfor tool in robot_tools:\n    if tool.Name().startswith(\'TCP\'):\n        tool.Delete()\n        \n# Calculate tool frames for the suction cup tool of 6 suction cups\nTCP_list = []\nfor i in range(nTCPs):\n    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)\n    TCPi = robot.AddTool(TCPi_pose, \'TCP %i\' % (i+1))\n    TCP_list.append(TCPi)\n\nTCP_0 = TCP_list[0]\n\n# Turn on automatic rendering\nRDK.Render(True)\n\n# Move balls    \nrobot.setPoseTool(TCP_list[0])\nnballs_frame1 = len(frame1_list)\nnballs_frame2 = len(frame2_list)\nidTake = nballs_frame1 - 1\nidLeave = 0\nidTCP = 0\ntarget_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)\n\nwhile idTake >= 0:\n    # ------------------------------------------------------------------\n    # first priority: grab as many balls as possible\n    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -> nTCPs)\n    ntake = min(nTCPs, idTake + 1)\n\n    # approach to frame 1\n    robot.setPoseFrame(frame1)\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.MoveJ(target_app_frame)\n\n    # grab ntake balls from frame 1\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted\n        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idTake = idTake - 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_On(TCPi, i)\n        robot.MoveL(target_app)\n \n    # ------------------------------------------------------------------\n    # second priority: unload the tool     \n    # approach to frame 2 and place the tool balls into table 2\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ(target_app_frame)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.setPoseFrame(frame2)    \n    robot.MoveJ(target_app_frame)\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        if idLeave > nballs_frame2-1:\n            raise Exception("No room left to place objects in Table 2")\n        \n        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted\n        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idLeave = idLeave + 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_Off(TCPi, i, frame2)\n        robot.MoveL(target_app)\n\n    robot.MoveJ(target_app_frame)\n\n# Move home when the robot finishes\nrobot.MoveJ([0,0,0,0,10,-200])\n \n', 'tags': '', 'url': 'RoboDK.html'}, {'title': 'CAD', 'text': 'SolidWorks:  https://www.solidworks.com/ \n AutoDesk Inventor:  https://www.autodesk.com/products/inventor \n Siemens NX:  https://www.plm.automation.siemens.com/global/en/products/nx/ \n PTC Onshape:  https://www.ptc.com/en/products/onshape \n Solvespace:  https://solvespace.com \n https://github.com/solvespace/solvespace', 'tags': '', 'url': 'CAD.html'}, {'title': 'Python for SW', 'text': 'http://wcm.cycu.org:88/github/cad2020/content/HW1_SW.html \n import pythoncom\nimport win32com.client\nimport win32api\nimport os\n \nos.system("taskkill /IM sldworks.exe /F")\nos.system("taskkill /IM sldworks_fs.exe /F")\n \n\'\'\'\nAbout DispatchEx and Dispatch Methods:\nhttps://stackoverflow.com/questions/18648933/using-pywin32-what-is-the-difference-between-dispatch-and-dispatchex\nSource code:\nhttp://pywin32.hg.sourceforge.net/hgweb/pywin32/pywin32/file/0db1b26904d5/com/win32com/src/PyIDispatch.cpp\nDoc:\nhttps://docs.microsoft.com/en-us/dotnet/standard/native-interop/com-callable-wrapper\n \nIDispatch: Provides a mechanism for late binding to type.\nIDispatchEx:\n    Interface supplied by the runtime if the class implements IExpando. The IDispatchEx interface is an extension of the IDispatch interface that, unlike IDispatch, enables enumeration, addition, deletion, and case-sensitive calling of members.\n\'\'\'\napp = win32com.client.DispatchEx("SldWorks.Application")\n#app=win32com.client.Dispatch("SldWorks.Application")\n \n# define var to convert variables\ndef var(type, value):\n    # type needs to be string\n    # use builtin getattr() to return pythoncom.type\n    pytype = getattr(pythoncom, type)\n    return win32com.client.VARIANT(pytype, value)\n \n# for two-type variable convert\n# is there any three-type variant?\ndef var2(type1, type2, value):\n    pytype1 = getattr(pythoncom, type1)\n    pytype2 = getattr(pythoncom, type2)\n    return win32com.client.VARIANT(pytype1|pytype2, value)\n     \ndef part(app, fileName, sketchName, dimName, newDim, newFileName):\n    arg1 = var("VT_I4", 1)\n    # GetMassProperties( ((3, 1), (16387, 3)))\n    #arg1 = win32com.client.VARIANT(pythoncom.VT_I4, 1)\n    arg2 = var("VT_I4", -1)\n \n    # 0. need the most important obj app\n    #app=win32com.client.Dispatch("SldWorks.Application")\n    # use relative directory to open part\n    # 1. open part file, need the path of the part file (need the file name)\n    #doc=app.OpenDoc(".\\\\block2.SLDPRT", 1)\n    doc=app.OpenDoc(os.path.join(os.getcwd(), fileName), 1)\n    # save part as binary stl\n    # can we save part as ASCII stl as well?\n    #doc.SaveAs2(".\\\\block2.stl", 0, True, False)\n    # the parameter VARIANT list for SelectByID2\n    # can we automate the VARIANT conversion?\n    # 2. use the sketch to select the SKETCH (need the sketch name)\n    #SelectByID2((8, 1), (8, 1), (5, 1), (5, 1), (5, 1), (11, 1), (3, 1), (9, 1), (3, 1))\n    #arg3 = var("VT_BSTR", "Sketch1")\n    arg3 = var("VT_BSTR", sketchName)\n    arg4 = var("VT_BSTR", "SKETCH")\n    arg5 = var("VT_R8", 0)\n    arg6 = var("VT_R8", 0)\n    arg7 = var("VT_R8", 0)\n    arg8 = var("VT_BOOL", False)\n    arg9 = var("VT_I4", 0)\n    arg10 = var("VT_DISPATCH", None)\n    arg11 = var("VT_I4", 0)\n    # select Sketch1 first\n    status = doc.Extension.SelectByID2(arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)\n    # select DIMENSION to to modify\n    # 3. use the dimension name @ sketch name @ part file name\n    # to select the DIMENSION to modify\n    #arg12 = var("VT_BSTR", "Width@Sketch1@block2.SLDPRT")\n    arg12 = var("VT_BSTR", dimName+"@"+sketchName+"@"+fileName)\n    arg13 = var("VT_BSTR", "DIMENSION")\n    status = doc.Extension.SelectByID2(arg12, arg13, arg5, arg6, arg7, arg8, arg9, arg10, arg11)\n    #Dim swDimension As SldWorks.Dimension\n    # 4. to bring out the parameter to modify, need the dimension name and \n    # sketch name\n    #swDimension = doc.Parameter("Width@Sketch1")\n    swDimension = doc.Parameter(dimName+"@"+sketchName)\n    # the dimension unit is in meter\n    # 5. need the new value of the parameter\n    #swDimension.SystemValue = 0.50\n    swDimension.SystemValue = newDim\n    # 6. do the final house keeping process, clear selection and rebuild the part\n    sel = doc.ClearSelection2 \n    sel = True\n    status = doc.EditRebuild()\n    arg31 = var("VT_I4", 1)\n    arg32 = var2("VT_I4", "VT_BYREF", 3)\n    # 7. get the volume of the new part\n    volumn = doc.Extension.GetMassProperties(arg31, arg32)\n    #print(volumn[3]*1E9, "mm*3")\n    # 8. save the new part (need the new part file name)\n    #doc.SaveAs2(".\\\\block3.SLDPRT", 0, True, False)\n    doc.SaveAs2(os.path.join(os.getcwd(), "html/" + newFileName + ".SLDPRT"), 0, True, False)\n    # save jpg of part\n    doc.EditRebuild()\n    arg33 = var("VT_BSTR", "Isometric")\n    doc.ShowNamedView(arg33)\n    doc.ViewZoomtofit2()\n    doc.SaveAs3(os.path.join(os.getcwd(), "html/" + newFileName + ".jpg"), 0, 0)\n    # mm*3\n    return str(round(volumn[3]*1E9, 3)) + " mm*3"\nhtml = "以下零件採 SolidWorks 2017 SP 2.0 教育版繪製:<br /><br /><table border=\'1\' cellpadding=\'5\'><tr><th>Number</th><th>Part</th><th>Jpg</th><th>Width</th><th>Volume</th></tr>"\nindex = 0\nfor i in range(1, 11):\n    dim = i*0.002\n    blockVolume = part(app, "31_step.SLDPRT", "Sketch1", "Width", dim, "31_" + str(i))\n    print("31_" + str(i) + ".SLDPRT, dim= " + str(round(dim, 3)) +", volume= " + blockVolume)\n    index += 1\n    newFileName = "31_" + str(i)\n    html += \'\'\'<tr>\n    <td>\'\'\' + str(index) +\'\'\'</td>\n    <td><a href="./../downloads/sw_macro/html/\'\'\' + newFileName + \'\'\'.SLDPRT">\'\'\' + newFileName + \'\'\'.SLDPRT</a></td>\n    <td><img width="300" src="./../downloads/sw_macro/html/\'\'\' + newFileName + \'\'\'.jpg"></img></td>\n    <td>\'\'\' + str(round(dim*1000, 2)) + \'\'\' mm </td>\n    <td>\'\'\' + blockVolume + \'\'\'</td>\n    </tr>\n    \'\'\'\nhtml += "</table>"\n# save part.html\nwith open("./html/part.html", "w", encoding="utf-8") as f:\n     f.write(html)\n      \n\'\'\'\nfor assembly\n        swModelDocExt.SelectByID2("", "EDGE", -0.439825991092107, 7.07350481263802E-02, 0.40982045578545, true, 2, null, 0);\n        swModelDocExt.SelectByID2("", "EDGE", -0.219003008311574, 0.073085842475507, 0.549481823985616, true, 4, null, 0);\n        swModelDocExt.SelectByID2("Part-3@AssemModel", "COMPONENT", 0, 0, 0, true, 1, null, 0);\n        swFeature = (Feature)swFeatureManager.FeatureLinearPattern2(3, 40 / 1000, 0, 0, false, true, "NULL", "NULL", false);\n        assemblyModel.ClearSelection2(true);\n\'\'\'\nos.system("taskkill /IM sldworks.exe /F")\nos.system("taskkill /IM sldworks_fs.exe /F")\n# now the SolidWorks is embedding \n \n', 'tags': '', 'url': 'Python for SW.html'}, {'title': 'Python for INV', 'text': '針對 HW1 使用 AutoDesk Inventor 2019 教育版繪零件圖者, 可以利用下列 Python 程式修改零件參數, 取零件影像圖並計算零件體積: \n import pythoncom\nimport win32com.client\nimport win32api\nimport os\n \n# Open Inventor\ninvApp = win32com.client.Dispatch("Inventor.Application")\n#print(invApp)\ninvApp.Visible = True\n \ninvApp.SilentOperation = True\n \n# Set location of assembly\npartName = \'C:/tmp/Part1.ipt\'\n \n# Open the model\noDoc = invApp.Documents.Open(partName)\n# use UserParameters to access the user parameters\n#oUserParams = oDoc.ComponentDefinition.Parameters.UserParameters\n#oNewParam = oUserParams.AddByExpression("x", "9", "mm")\n# use Item() to get the model parameter named "d0"\nd0 = oDoc.ComponentDefinition.Parameters.Item("d0")\n# Expression can add dimension unit\n#d0.Expression = "2 cm"\n# Value use the default system unit: cm\nd0.Value = 2\n# use Update() method to get the new part volume\noDoc.Update()\n# fit the active view and save the part image\ninvApp.ActiveView.Fit(True)\noDoc.SaveAs("C:/tmp/Part1.png", True)\nprint(oDoc.ComponentDefinition.MassProperties.Volume)\n#invApp.Quit() \n \n', 'tags': '', 'url': 'Python for INV.html'}, {'title': 'Python for NX', 'text': '針對 HW1 使用 NX12.0.2 教育版繪零件圖者, 可以利用下列 Python 程式修改零件參數, 取零件影像圖並計算零件體積: \n 參考零件:  block.prt \n NX12 NXOpen Python API Reference \n # nx_open_part.py\n# 導入 NXOpen\nimport NXOpen\nimport NXOpen.UF\nimport NXOpen.Gateway\n   \ndef main():\n    # 取得目前開啟的工作階段\n    theSession = NXOpen.Session.GetSession()\n    theUfSession = NXOpen.UF.UFSession.GetUFSession()\n      \n    # 建立 ListingWindow\n    listWin= theSession.ListingWindow\n    # 開啟零件檔案\n    basePart1 = theSession.Parts.OpenBaseDisplay("c:/tmp/block.prt")\n    workPart = theSession.Parts.Work\n    unit1 = workPart.UnitCollection.FindObject("MilliMeter")\n    # height\n    p7 = workPart.Expressions.FindObject("p7")\n    # width\n    p8 = workPart.Expressions.FindObject("p8")\n    # length\n    p9 = workPart.Expressions.FindObject("p9")\n    workPart.Expressions.EditWithUnits(p7, unit1, "30")\n    workPart.Expressions.EditWithUnits(p8, unit1, "60")\n    workPart.Expressions.EditWithUnits(p9, unit1, "90")\n    theSession.UpdateManager.DoUpdate(0)\n    #saveStatus1 = workPart.SaveAs("c:/tmp/block_new.prt")\n    #saveStatus1.Dispose()\n    # initialize list to hold bodies\n    theBodyTags = []\n   \n    for x in workPart.Bodies:\n        if x.IsSolidBody:\n            theBodyTags.append(x.Tag)\n      \n    # 準備輸出 ASCII 格式 STL 零件檔案\n    sTLCreator1 = theSession.DexManager.CreateStlCreator()\n    sTLCreator1.AutoNormalGen = True\n    sTLCreator1.ChordalTol = 0.08\n    sTLCreator1.AdjacencyTol = 0.08\n    sTLCreator1.OutputFile = "C:\\\\tmp\\\\block_ascii.stl"\n    # Binary STL: NXOpen.STLCreatorOutputTypeEnum.Binary\n    sTLCreator1.OutputType = NXOpen.STLCreatorOutputTypeEnum.Text\n    # 已知 body1 命名\n    body1 = workPart.Bodies.FindObject("EXTRUDE(2)")\n    added1 = sTLCreator1.ExportSelectionBlock.Add(body1)\n    nXObject1 = sTLCreator1.Commit()\n    sTLCreator1.Destroy()\n  \n    # 開啟所建立的 ListingWindow\n    listWin.Open()\n    listWin.WriteLine("number of solid bodies: " + str(len(theBodyTags)))\n   \n    (massProps, Stats) = theUfSession.Modeling.AskMassProps3d(theBodyTags, len(theBodyTags), 1, 4, .03, 1, [0.99,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])\n    listWin.WriteLine("units: kg, mm")\n    listWin.WriteLine("surface area: " + str(massProps[0]))\n    listWin.WriteLine("volume: " + str(massProps[1]*1E9))\n    # 在 ListingWindow 中寫入字串\n    listWin.WriteLine("Hello, NXOpen")\n    listWin.Close()\n     \n    # 將零件檔案 fit 之後, export 出 png 檔案\n    theUI = NXOpen.UI.GetUI()\n    imageExportBuilder1 = theUI.CreateImageExportBuilder()\n \n    custombackgroundcolor1 = [None] * 3\n    custombackgroundcolor1[0] = 1.0\n    custombackgroundcolor1[1] = 1.0\n    custombackgroundcolor1[2] = 1.0\n \n    imageExportBuilder1.SetCustomBackgroundColor(custombackgroundcolor1)\n    imageExportBuilder1.FileFormat = NXOpen.Gateway.ImageExportBuilder.FileFormats.Png\n    imageExportBuilder1.FileName = "c:\\\\tmp\\\\block.png"\n \n    imageExportBuilder1.BackgroundOption = NXOpen.Gateway.ImageExportBuilder.BackgroundOptions.Original\n \n    imageExportBuilder1.EnhanceEdges = False\n    imageExportBuilder1.RegionMode = False\n    # fit view 後 commit export png\n    workPart.ModelingViews.WorkView.Fit()\n    nXObject6 = imageExportBuilder1.Commit()\n \n    imageExportBuilder1.Destroy()\n      \nif __name__ == "__main__":\n    main() \n \n', 'tags': '', 'url': 'Python for NX.html'}, {'title': 'CAE', 'text': 'Mechatronic control system design and simulation: \n Coppeliasim: \n https://www.coppeliarobotics.com/ \n https://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm \n https://www.coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm \n https://github.com/CoppeliaRobotics \n Webots: \n https://cyberbotics.com/ \n https://github.com/cyberbotics/webots \n FEM: \n sfepy: \n https://sfepy.org/doc-devel \n https://github.com/sfepy/sfepy \n https://sfepy.org/doc-devel/examples/gallery.html \n Netgen/NGSolve: \n https://www.math.uzh.ch/compmath/fileadmin/user/stas/compmath/Abschlussarbeiten/Arnold_Noam/myManual.pdf \n https://ngsolve.org/ \n https://github.com/NGSolve/ngsolve \n https://github.com/NGSolve/netgen \n \n', 'tags': '', 'url': 'CAE.html'}, {'title': 'BS4', 'text': 'Website Scraping with Python  (2018) \n https://github.com/mdecycu/nfulist \n', 'tags': '', 'url': 'BS4.html'}, {'title': 'PostgreSQL', 'text': 'https://docs.postgresql.tw/ \n PostgreSQL 可以以一般使用者進行安裝，它並不需要系統管理者（root）的權限才能安裝。 \n Get Started with PostgreSQL \n Beginning Database with PostgreSQL  (2005) \n PostgreSQL Configuration  (2020) \n PostgreSQL Query Optimization  (2021) \n Beginning PostgreSQL on the Cloud  (2018)', 'tags': '', 'url': 'PostgreSQL.html'}, {'title': 'PyQt', 'text': 'Beginning PyQt \n Introducing Qt6', 'tags': '', 'url': 'PyQt.html'}, {'title': 'MS Graph', 'text': 'Microsoft Graph client library for Python \n https://github.com/microsoftgraph/msgraph-sdk-python-core \n MS Teams: \n Microsoft Teams is the ultimate hub for teamwork and intelligent communications. Built on the strength and scale of Microsoft 365 with over 120 million users, Microsoft Teams delivers chat-based collaboration, meetings, calling, and enterprise voice features. \n MS Graph: \n Microsoft Graph makes it easy to create large numbers of teams and populate them with users and channels, by automating the creation and management of teams, channels, tabs, and apps. Microsoft Graph also lets you find and archive the teams you are no longer using. This is the same API that the Microsoft Teams Admin Center and Teams PowerShell cmdlets are built on. \n \n More MS Teams related video: \n https://www.youtube.com/c/Microsoft365Developer/search?query=Teams \n 安裝模組: \n pip install msgraph-core azure-identity \n Target: \n MS Graph SDK for MS Teams: \n https://docs.microsoft.com/en-us/graph/teams-concept-overview \n Login:\xa0 \n https://developer.microsoft.com/en-us/microsoft-365/dev-program \n', 'tags': '', 'url': 'MS Graph.html'}, {'title': 'MS Teams', 'text': 'Granting access via Azure AD App-Only | Microsoft Docs \n Azure Access Control (ACS), a service of Azure Active Directory (Azure AD), has been retired on November 7, 2018. This retirement does not impact the SharePoint Add-in model, which uses the  https://accounts.accesscontrol.windows.net  hostname (which is not impacted by this retirement). For more information, see  Impact of Azure Access Control retirement for SharePoint Add-ins . \n Download MS Teams Student submitted files: \n \n Login to Onedrive. \n From App Launcher, select SharePoint -> My sites. \n Search for the specific class -> Site contents -> Student Work -> Submitted Files, click Download to download all submitted files or use Ctrl to select multiple students and click Download to download associated files. \n \n', 'tags': '', 'url': 'MS Teams.html'}, {'title': 'cad2022', 'text': '2022 Fall \n Computer aided Design and Practices 電腦輔助設計實習 \n 行事曆 \n 全頁檢視 \n \n \n \n \n \n Please enable JavaScript to view the  comments powered by Disqus.', 'tags': '', 'url': 'cad2022.html'}, {'title': 'cad-syllabus', 'text': '課程評分: \n w3 建立  TCExam  帳號, 進行模擬考試. \n w4 Exam1 (5%) \n w8 Exam2 (5%) \n w9 Exam3 (5%) \n w12 Exam4 (5%) \n w16 Exam5 (5%) \n w18 Exam6 (5%) \n Github Repository and Pages (70%) \n 個人簡歷與課程進度心得 \n 課程內容操作影片 ( Wink3 ) \n 期中設計專案 \n 期末設計專案 \n 課程內容: \n Design a Foosball Table: \n 期中設計專案: \n 請在個人網頁中, 建立一個 Foosball 頁面, 以 MCAD 套件建立所需的所有零組件檔案: \n How To Make a Desktop Foosball Table \n Foosball Table with 3d printing \n The Study of Semi-Automated Football Table \n https://2019wcm.blogspot.com/2019/04/table-foosball.html \n 評分項目 ( Github Pages ,  pdf ,  reveal ,  pelican ): \n 專案摘要 \n 專案目錄 \n 設計簡介與目標 \n 相關文獻探討 \n 專利: \n Game Apparatus  (1939)     Simulated Hockey Game  (1950)     Table soccer or football game structure  (1973)     Table soccer or football game structure \xa0(1975)     Rod Bearing for Table Soccer\xa0 or Fussball Game Structure  (1983)     Sectional Rod Bearing for Fussball Game Structure  (1991)     Table Soccer or Fussball Game Playing Ball  (1991)     Table Soccer Game Bumper Structure  (1991)     Table Soccer Playing Figure  (1994)     Soccer Table  (1994)     Convertible Game Table  (1997)     Bracing Structure of Rotary Rod  (2000)     Structure of a Soccer Game Table  (2001)     Player Structure in a Fooz Ball Game  (2002)     Retractable Rotating Rod for Football Table  (2002)     Double Sided Soccer Man  (2010)     Support Device for Slidable Shafts of Table Soccer Games  (2012) \n 課程報告: \n https://mdecadp2018.github.io/site-40623128 \n https://mdecadp2018.github.io/site-40623130 \n https://mdecadp2018.github.io/site-40623224 \n https://mdecadp2018.github.io/site-40623242 \n 大學部專題: \n The Study of Semi-Automated Football Table \n 研究報告: \n foosball keyword searching on IEEE \n Development Of Robotic Foosball As A Versatile Platform For Robotics Research and Contests  (2003) \n Kiro  (2006) \n Space Foosball: Coupling Tangible Interfaces with a Real-time Game Physics Engine  (2009) \n Automated Foosball Table  (2013) \n https://2019wcm.blogspot.com/search/label/foosball \n https://www.ximea.com/en/corporate-news/foosball-table-robot-camera \n Foosball tracking  (2012) \n Foose  (2012) \n https://cduck.me/2015/robotic-foosball-table/  (2015) \n https://www.siliconrepublic.com/machines/chess-go-and-now-foosball-ai-is-coming-for-you  (2016) \n https://www.thestar.com/news/insight/2016/05/12/can-a-computer-beat-you-at-foosball-yes-yes-it-can.html  (2016) \n Low latency vision-based control for robotics  (2018) \n KIcker  (2021) \n https://youtu.be/Hu7LFrP43tA \n https://forum.allaboutcircuits.com/threads/automated-foosball-hardware-advice-for-crazy-speeds.137860/ \n 設計方法與工具 ( Solvespace ,  Onshape , NX 分屬三種不同類型的 MCAD 套件) \n 可自行編譯延伸的 MCAD ( Solvespace ,  Web version ,  CADtron ) 套件 \n 可直接在雲端上執行的 MCAD ( Onshape ) 套件 \n 可放入 USB 連網啟動的高階 MCAD ( NX2206 revB ) 套件 \n https://me5763.github.io/lab/ \n NX Tips Video \n 設計結果 \n 設計討論 \n 附錄 \n 期末設計專案: \n 請根據期中專案所完成的設計零組件, 轉入  CoppeliaSim 4.3.0 rev3  以上版本後, 透過網路連線, 建立可讓 Human 與 Human 對打, Human 與 Computer 對打, 以及 Computer 與 Computer 對打的 Foosball 線上遊戲. \n https://www.coppeliarobotics.com/ \n https://forum.coppeliarobotics.com/ \n https://mde.tw/pjcopsim \n https://github.com/CoppeliaRobotics \n 評分項目: \n 專案摘要 \n 專案目錄 \n 設計簡介與目標 \n 相關文獻探討 \n CoppeliaSim Overview \n CoppeliaSim Tutorials \n 設計方法與工具 \n 自行編譯 CoppeliaSim:  https://github.com/CoppeliaRobotics \n Building a Clean Model \n Joints \n Kinematics \n Desiging Dynamic Simulations \n Writing Code \n RemoteAPI \n Web-browser based Front-end \n 設計結果 \n 設計討論 \n 附錄 \n 期末簡報 \n', 'tags': '', 'url': 'cad-syllabus.html'}, {'title': 'ME', 'text': 'https://www.sg-lib.org/ \n https://github.com/timlueth/SG-Lib-Matlab-Toolbox \n https://github.com/jan-mue/geometer \n https://github.com/Dessia-tech/volmdlr \n A Method for the Automatic Design of Mechanisms on the Example of a Four-Bar Linkage.pdf  (for @gm users only) /  for @nfu users \n Basics of Robotics  (1999) \n Fundamentals of Robotic Mechanical Systems  (2014) \n Gears in Design, Production and Education  (2021) \n Theory of Applied Robotics Kinematics Dynamics and Control  (2022) \n Modular Robots: Theory and Practice  (2022) \n Intro to Robotics \n The Basics of Robotics \n https://www.therobotreport.com/10-most-automated-countries-wordlwide-in-2020/ \n https://wokwi.com/ \n https://pimylifeup.com/raspberry-pi-virtualbox/', 'tags': '', 'url': 'ME.html'}, {'title': 'Trends', 'text': 'The Work of the Future 2020 \n Future of Jobs Report 2020 \n 根據上列 report, Key findings: \n The pace of technology adoption is expected to remain unabated and may accelerate in some areas. The adoption of  cloud computing ,  big data and e-commerce  remain high priorities for business leaders, following a trend established in previous years. However, there has also been a significant rise in  interest for encryption ,  non-humanoid robots  and  artificial intelligence . \n Automation, in tandem with the COVID-19 recession, is creating a \'double-disruption\' scenario for workers. In addition to the current disruption from the pandemic-induced lockdowns and economic contraction, technological adoption by companies will transform tasks, jobs and skills by 2025. Forty-three percent of businesses surveyed indicate that they are set to  reduce their workforce  due to technology integration, 41% plan to expand their use of contractors for task-specialized work, and 34% plan to expand their workforce due to technology integration. By 2025,  the time spent on current tasks at work by humans and machines will be equal . A significant share of companies also expect to make changes to locations, their value chains, and the size of their workforce due to factors beyond technology in the next five years. \n Although the number of jobs destroyed will be surpassed by the number of \'jobs of tomorrow\' created, in contrast to previous years, job creation is slowing while  job destruction accelerates . Employers expect that by 2025,  increasingly redundant roles will decline  from being 15.4% of the workforce to 9% (6.4% decline), and that  emerging professions  will grow from 7.8% to 13.5% (5.7% growth) of the total employee base of company respondents. Based on these figures, we estimate that by 2025, 85 million jobs may be displaced by  a shift in the division of labour between humans and machines , while 97 million new roles may emerge that are more adapted to the  new division of labour between humans, machines and algorithms . \n Skills gaps continue to be high  as in-demand skills across jobs change in the next five years. The top skills and skill groups which employers see as rising in prominence in the lead up to 2025 include groups such as  critical thinking and analysis  as well as  problem-solving , and skills in self-management such as  active learning ,  resilience ,  stress tolerance and flexibility . On average, companies estimate that around 40% of workers will require  reskilling of six months or less  and 94% of business leaders report that they expect employees to  pick up new skills on the job , a sharp uptake from 65% in 2018. \n The future of work  has already arrived  for a large majority of the  online white-collar workforce . Eighty-four percent of employers are set to  rapidly digitalize working processes , including a significant expansion of  remote work —with the potential to move 44% of their workforce to  operate remotely . To address concerns about productivity and well-being, about one-third of all employers expect to also take steps to create a sense of  community, connection and belonging among employees through digital tools , and to tackle the well-being challenges posed by the shift to remote work. \n In the absence of proactive efforts,  inequality  is likely to be exacerbated by the dual  impact of technology and the pandemic recession . Jobs held by lower wage workers, women and younger workers were more deeply impacted in the first phase of the economic contraction. Comparing the impact of the Global Financial Crisis of 2008 on  individuals with lower education levels  to the impact of the COVID-19 crisis, the impact today is far more significant and more likely to deepen existing inequalities. \n Online learning and training  is on the rise but looks different for those in employment and those who are unemployed. There has been a four-fold increase in the numbers of individuals seeking out opportunities for learning online through their own initiative, a five-fold increase in employer provision of online learning opportunities to their workers and a nine-fold enrolment increase for learners accessing online learning through government programmes. Those in employment are placing larger  emphasis on   personal development courses , which have seen 88% growth among that population. Those who are unemployed have placed greater emphasis on  learning digital skills  such as  data analysis ,  computer science  and  information technology . \n The window of opportunity to  reskill and upskill workers  has become shorter in the newly constrained labour market. This applies to workers who are likely to stay in their roles as well as those who risk losing their roles due to rising recession-related unemployment and can no longer expect to retrain at work. For those workers set to remain in their roles, the share of  core skills that will change  in the next five years is 40%, and 50% of all employees will need reskilling (up 4%). \n Despite the current  economic downturn , the large majority of employers recognize the value of human capital investment. An average of 66% of employers surveyed expect to get a return on  investment in upskilling and reskilling  within one year. However, this time horizon risks being too long for many employers in the context of the current economic shock, and nearly 17% remain uncertain on having any return on their investment. On average, employers expect to offer reskilling and upskilling to just over 70% of their employees by 2025. However, employee engagement into those courses is\xa0lagging, with only 42% of employees taking up employer-supported reskilling and upskilling opportunities. \n Companies need to invest in  better metrics of human and social capital  through adoption of environmental, social and governance (ESG) metrics and matched with renewed measures of human capital accounting. A significant number of business leaders understand that reskilling employees, particularly in industry coalitions and in  public-private collaborations , is both cost-effective and has significant mid- to long-term dividends—not only for their enterprise but also for the benefit of society more broadly. Companies hope to internally redeploy nearly 50% of workers displaced by  technological automation and augmentation , as opposed to making wider use of layoffs and automation-based labour savings as a core workforce strategy. \n The public sector needs to provide stronger support for  reskilling and upskilling  for at-risk or displaced workers. Currently, only 21% of businesses report being able to make use of public funds to support their employees through reskilling and upskilling. The public sector will need to create incentives for investments in the markets and jobs of tomorrow; provide stronger safety nets for displaced workers in the midst of job transitions; and to decisively  tackle long- delayed improvements to education and training systems . Additionally, it will be important for governments to consider the longer-term labour market implications of maintaining, withdrawing or partly continuing the strong COVID-19 crisis support they are providing to support wages and maintain jobs in most advanced economies. \n Future of Work Report 2021 \n 根據上列 report, KEY TAKEAWAYS: \n The COVID-19 pandemic is a double-whammy for inequality: The worst-off are hit harder while  accelerating economy-wide digitalization  further widens the skills gap. \n This report highlights technology\'s increasing impact on the workplace, providing valuable information for policymakers, business leaders, and educational institutions so they can make better decisions about how to prepare workers for the future. \n First, the report describes attitudes and perspectives toward  remote work and skills training , using a "Future of Work" survey of 1,000 managers and employees by technology consulting firm Infosys. Key findings include: \n a broad shift toward  remote working and hiring , with a greater focus on inclusion and diversity (however, lower-wage respondents saw fewer opportunities); \n net satisfaction with remote work and productivity, notwithstanding higher workloads and the loss of social interactions with colleagues; \n high trust in employees during remote work, though with increased surveillance; and \n a rise in employee skills training focused on working remotely, which most employees found useful (however, lower-wage employees felt more responsible for training themselves). \n Building on these findings, this report makes several recommendations to address rising inequality and disruption, supplemented with insights generated from numerous public events the Milken Institute has convened. These recommendations include: \n accelerating regional growth through public investments that broaden access to local sectors with high potential; \n financing access to education and skills training, including for underprivileged populations; \n strengthening business-education partnerships, including  just-in-time learning ,  agile curricula , and  flexible time commitment ; and \n regular and outcomes-based evaluation of initiatives, to continually identify areas for improvement. \n', 'tags': '', 'url': 'Trends.html'}, {'title': 'Gears', 'text': 'Advances in Gear Theory and Gear Cutting Tool Design  (2022) \n Recent Advances in Gearing  (2022)', 'tags': '', 'url': 'Gears.html'}, {'title': 'Robots', 'text': 'Fundamentals of Mechanics of Robotic Manipulation  (2022) \n', 'tags': '', 'url': 'Robots.html'}, {'title': 'Vehicle', 'text': 'Vehicle Dynamics  (2022)', 'tags': '', 'url': 'Vehicle.html'}, {'title': 'Aircraft', 'text': 'https://github.com/convexengineering/SPaircraft \n 2017_Application of Signomial Programming to Aircraft Design.pdf \n 2017_Turbofan Engine Sizing and Tradeoff Analysis via Signomial Programming.pdf \n https://github.com/camUrban/PteraSoftware \n https://github.com/vibrationtoolbox/vibration_toolbox \n https://github.com/white-noise-ntua/autogyro-blades-optimization \n https://github.com/matst1008/FlyPy \n Automated Low-Altitude Air Delivery  (2022) \n Fan Engineering 1840-1930 \n http://www.hevac-heritage.org \n', 'tags': '', 'url': 'Aircraft.html'}, {'title': '3D print', 'text': 'Additive Manufacturing Technologies  (2010) \n Innovations in Additive Manufacturing  (2022) \n', 'tags': '', 'url': '3D print.html'}, {'title': 'Computer Vision', 'text': 'Computer Vision  (2011) \n', 'tags': '', 'url': 'Computer Vision.html'}, {'title': 'Industry 4.0', 'text': 'Handbook Industry 4.0  (2022)', 'tags': '', 'url': 'Industry 4.0.html'}, {'title': 'Reference', 'text': 'https://mdecadp2018.github.io/site-40623128 \n https://mdecadp2018.github.io/site-40623130 \n https://mdecadp2018.github.io/site-40623224 \n https://mdecadp2018.github.io/site-40623242 \n', 'tags': '', 'url': 'Reference.html'}, {'title': 'Portable NX1980', 'text': '在 Windows 10 配置可攜 NX1980 程式, 需要: \n \n https://github.com/Bioruebe/UniExtract2 \n https://github.com/wixtoolset/wix3/releases/tag/wix3112rtm \n \n 等兩項工具, UniExtract2 用來解開 SiemensNX-1980_wntx64\\nx\\SiemensNX.msi, 以及 .msi, 而 wix 則用來解開 SiemensNX-1980_wntx64\\nx\\VC_redist.x64.exe, 指令為: \n wix311-binaries\\dark.exe vc_redist.x64.exe -x x64-extracted \n 表示要在 x64-extracted 目錄中取得 x64-extracted\\AttachedContainer\\packages\\vcRuntimeMinimum_amd64\\vc_runtimeMinimum_x64.msi 之後, 再利用 UniExtract2 解開所需的 dll 檔案後, 再放入 NXBIN 目錄. \n 製作 Portable NX1980 的步驟請參考以下影片: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'Portable NX1980.html'}, {'title': 'template and SSH', 'text': '以下教學影片說明如何利用  https://github.com/wcm2022/wcm2022  倉儲作為 template, 建立個人與分組的倉儲. 並且利用 putty 與 GIT_SSH 變數的設定, 採用 SSH 網路協定對 Github 上的倉儲進行改版: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'template and SSH.html'}, {'title': 'Pull Requests', 'text': '以下影片說明如何利用 Pull Requests 對沒有協同管理權限的 github 倉儲進行改版後, 要求合併內容: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n 以下影片說明如何透過逆向 Pull Requests 讓各學員帳號下的分組倉儲與組長帳號下的協同倉儲內容保持同步: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'Pull Requests.html'}, {'title': 'Resolve Conflicts', 'text': '解決協同設計流程中的倉儲衝突 \n 當各組學員對組長帳號下的分組倉儲具備協同管理權限後, 各學員可以 git 採非同步協同設計, 對組長帳號下的分組倉儲進行改版, 其間不免要設法以手動方式解決 config/content.htm 動態超文件中的衝突. \n 以下影片就是利用動態網頁系統中的 Search 與 Edit All 設法找出帶有衝突起點、中線與衝突終點的超文件範圍, 然後根據協同設計整體需求解決衝突後, 新增、提交並推送新版本. \n \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n \n', 'tags': '', 'url': 'Resolve Conflicts.html'}, {'title': 'Revealjs', 'text': 'https://revealjs.com/  是一個 Javascript 程式框架, 可用來建立全球資訊網上的簡報. \n 將 reveal.js 納入分組倉儲的真正目的, 是能直接在統一的 GitHub 提交推送過程中, 持續查核各組員對於協同產品開發流程的貢獻度. \n 至於為何要利用 markdown 格式, 在 Leo Editor 中轉為 index.html 進行展示, 是希望在組員改版間避開以 html 格式處理衝突的難度. \n 課程中所採的各種方法並非限制, 而是在衡量協同利弊得失後的可行方法之一.你們可以就各種工具在協同產品設計流程中的應用. 進行討論及實作, 然後查驗所採行的方法是否也能: \n \n 持續改進 \n 保有各組員的改版紀錄 \n 方便處理合併及展示 \n 具永續性及可應變性 \n \n https://github.com/hakimel/reveal.js  引用了許多 Javascript 程式庫, 這些程式庫的改版非常頻繁, 經常造成改版頻率相對緩慢的  cmsimde  經常收到來自 Github 的改版通知. \n 因此在利用  cmsimde  建立 cd2022 課程網站與大分組網站時, 若要直接使用 Reveal.js 建立線上簡報, 就必須將\xa0 cmsimde  的 reveal 目錄內容保持在最新的 Reveal.js 版本. \n https://github.com/mdecycu/cmsimde_site  就是用於開發  cmsimde  的倉儲. cmsimde_site 的 main 分支直接將  cmsimde  內容放入 cmsimde 目錄, 可以直接根據需求修改其中的任何內容, 當測試無誤後(尚未使用  unittest ), 將改版內容反應至  cmsimde  後, 將在 cmsimde_site 倉儲中的 submodule 分支中進行測試. \n 由於 cmsimde_site 的 main 分支直接將 cmsimde 當作子目錄, 而 submodule 分支則將 cmsimde 當作子模組. 從 main 分支切換到 submodule, 由於需要同時取下 cmsimde 子模組資料, 因此使用: \n git checkout -f submodule --recurse-submodules \n 而從 submodule 分支切換回 main 分支, 則使用: \n git checkout -f main \n cmsimde  倉儲中的 config/reveal.leo 使用  Leo Editor  編輯各簡報頁面內容. reveal.leo 中包含 demo.html 中的各種簡報應用, 使用者可以從 Leo Editor 專案中取出所需的簡報頁面進行編輯. \n 以下影片說明如何利用 Leo Editor 編輯 config/reveal.leo 網際簡報檔案: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n 以下影片說明如何利用 Leo Editor 編輯 config/pelican.leo 網誌檔案: \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'Revealjs.html'}, {'title': 'Virtualbox', 'text': '利用 nssm 與 vboxheadless 啟動虛擬主機. \n nssm install nxserver \n nssm edit nxserver \n nssm remove nxserver \n Path: C:\\Program Files\\Oracle\\VirtualBox\\VBoxHeadless.exe \n Startup directory: C:\\pj2022 \n Arguments: --startvm nxserver \n Log on: 輸入管理者帳號與密碼 \n', 'tags': '', 'url': 'Virtualbox.html'}, {'title': 'cube', 'text': '以下為採用 NX1980 繪製的正方體零件, 可能原先的繪圖流程是在草圖階段繪圖時並未對長度與寬度設定尺寸, 就直接長出實體, 然後再回到草圖設定尺寸, 因此 Tools -> Expressions 以 p1 定義高度, 而長度則設為 p2, 寬度設為 p3, 在沒有透過 set Expressions 對長度與寬度對應尺寸約束之前, 在 Tools -> Expressions 只能看到 p1, 其實 p2 與 p3 應該已經跟草圖的尺寸綁定, 因此可以透過 NXOpen Python API 程式 對無列出長寬尺寸變數的零件進行操控, 看是否能夠利用 p2 與 p3 變數控制草圖大小. \n 以下為設法透過草圖編輯列出尺變數的 Wink 影片: \n 參考零件.7z \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'cube.html'}, {'title': 'Solvespace', 'text': 'https://solvespace.com \n https://github.com/solvespace/solvespace \n https://github.com/KmolYuan/Pyslvs-UI \n 將 Solvespace 轉出的 Binary STL 零組件轉為 ASCII STL 程式碼: \n import struct\nnormals = []\npoints = []\ntriangles = []\ntriangle_number = 0\ndef load_binary_stl(fp):\n    \'\'\'\n    二位元 STL 檔案格式如下:\n    檔案標頭共有 80 個字元(bytes), 內容通常省略, 但是內容不可使用 solid, 以免與文字檔案 STL 混淆\n    UINT8[80] – Header\n    UINT32 – Number of triangles (I:佔 4 bytes 的 unsigned integer)\n   \n    foreach triangle\n    REAL32[3] – Normal vector (f:每一座標分量為一佔 4 bytes 的 float, 共佔 12 bytes)\n    REAL32[3] – Vertex 1\n    REAL32[3] – Vertex 2\n    REAL32[3] – Vertex 3\n    UINT16 – Attribute byte count (H:兩個 bytes 的 unsigned short, 表示 attribute byte count)\n    end\n   \n    \'\'\'\n    # 已經在外部開檔\n    #fp=open(filename,\'rb\')\n    header=fp.read(80)\n    triangle_number = struct.unpack(\'I\',fp.read(4))[0]\n    #print(triangle_number)\n    count=0\n    while True:\n        try:\n            p=fp.read(12)\n            if len(p)==12:\n                n=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                normals.append(n)\n                l = len(points)\n                #print(n)\n            p=fp.read(12)\n            if len(p)==12:\n                p1=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                points.append(p1)\n                #print(p1)\n            p=fp.read(12)\n            if len(p)==12:\n                p2=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                points.append(p2)\n            p=fp.read(12)\n            if len(p)==12:\n                p3=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                points.append(p3)\n                triangles.append((l, l+1, l+2))\n            # 使用 count 來計算三角形平面個數\n            # triangle_number 為 STL 檔案中的三角形個數\n            count += 1\n            #print(count)\n            # 在前面 12*4 個 bytes 的 normal 與三個點資料後, 為\n            # 一個 2 bytes 長的 unsigned short, 其值為零, 為 attribute\n            fp.read(2)\n            # 讀完所有三角平面後, 即跳出 while\n            if count > triangle_number:\n                break\n        except EOFError:\n            break\n    #fp.close()\ndef read_length(f):\n    length = struct.unpack("@i", f.read(4))\n    return length[0]\ndef read_header(f):\n    f.seek(f.tell()+80)\ndef write_as_ascii(outfilename):\n    f = open(outfilename, "w")\n    f.write ("solid "+outfilename+"\\n")\n    for n  in range(len(triangles)):\n        f.write ("facet normal {} {} {}\\n".format(normals[n][0],normals[n][1],normals[n][2]))\n        f.write ("outer loop\\n")\n        f.write ("vertex {} {} {}\\n".format(points[triangles[n][0]][0],points[triangles[n][0]][1],points[triangles[n][0]][2]))\n        f.write ("vertex {} {} {}\\n".format(points[triangles[n][1]][0],points[triangles[n][1]][1],points[triangles[n][1]][2]))\n        f.write ("vertex {} {} {}\\n".format(points[triangles[n][2]][0],points[triangles[n][2]][1],points[triangles[n][2]][2]))\n        f.write ("endloop\\n")\n        f.write ("endfacet\\n")\n    f.write ("endsolid "+outfilename+"\\n")\n    f.close()\ndef main():\n    infilename = "binary.stl"\n    outfilename = "ascii.stl"\n    try:\n        f = open(infilename, "rb")\n        #read_header(f)\n        #l = read_length(f)\n        try:\n            load_binary_stl(f)\n            l = len(normals)\n        except Exception as e:\n            print("Exception",e)\n        print(len(normals), len(points), len(triangles), l)\n        write_as_ascii(outfilename)\n        print("done")\n    except Exception as e:\n        print(e)\nif __name__ == \'__main__\':\n    main() \n 切割多零件 STL 檔案: \n stlSplitter.py 與 stlRW.py \n stlSplitter.py \n #!/usr/bin/env python\n# STL splitter\n# splits a STL file containing separate objects\n#\n# copyright 2014 Francesco Santini <francesco.santini@gmail.com>\n#\n# based on https://github.com/cmpolis/convertSTL by Chris Polis\n# and BinarySTL https://github.com/sukhbinder/python by Sukhbinder Singh\n#\n# Released under the MIT/X license\n \n \nimport stlRW\nimport sys\nfrom os import path\n \n## functions\n \n# maybe insert a tolerance for floating points?\ndef check_connection(tri1, tri2):\n    for v1 in tri1[0:2]:\n        for v2 in tri2[0:2]:\n            if (v1[0] == v2[0] and v1[1] == v2[1] and v1[2] == v2[2]): return True\n    return False\n     \n \nif len(sys.argv) < 2:\n    print("Usage: " + sys.argv[0] + " <file.stl>")\n    sys.exit(-1)\n \nfname = sys.argv[1]\n \nprint("Reading...")\n \nhead,points,n,v1,v2,v3,isAscii = stlRW.stlRead(fname)\n \nprint("Analyzing...")\n \nfaceTree = []\n \nfor triangleIndex in range(0, len(v1)):\n    triangle = [ v1[triangleIndex], v2[triangleIndex], v3[triangleIndex], n[triangleIndex] ]\n    connectedTo = []\n    for treeindex in range(0, len(faceTree)):\n        for face in faceTree[treeindex]:\n            if check_connection(face, triangle):\n                connectedTo.append(treeindex) # the triangle is connected to at least one triangle of the current treeIndex\n                break\n       \n    if len(connectedTo) == 0:\n        # this is a triangle from a new set\n        #print "new set"\n        faceTree.append([])\n        faceTree[len(faceTree)-1].append(triangle)\n    elif len(connectedTo) == 1:\n        #print "existing set"\n        # the triangle is connected to one set\n        faceTree[connectedTo[0]].append(triangle)\n    else:\n        #print "connecting triangle"\n        #this triangle connects two branches of the tree: collapse the branches\n        faceTree[connectedTo[0]].append(triangle)\n        for i in range(len(connectedTo)-1, 0, -1):\n            faceTree[connectedTo[0]].extend(faceTree.pop(connectedTo[i]))\n       \nprint("Number of separate objects: ", len(faceTree))\n \nprint("Writing files")\n \norigFile, origExt = path.splitext(fname)\nfor i in range(0, len(faceTree)):\n    newFile = origFile + "-" + str(i+1) + origExt\n    print("Writing ", newFile)\n    n = [field[2] for field in faceTree[i]]\n    v1 = [field[0] for field in faceTree[i]] \n    v2 = [field[1] for field in faceTree[i]] \n    v3 = [field[2] for field in faceTree[i]]\n    stlRW.stlWrite(newFile, n, v1, v2, v3) \n stlRW.py \n # STL reader-writer\n#\n# copyright 2014 Francesco Santini <francesco.santini@gmail.com>\n#\n# based on https://github.com/cmpolis/convertSTL by Chris Polis\n# and BinarySTL https://github.com/sukhbinder/python by Sukhbinder Singh\n#\n# Released under the MIT/X license\n \nimport numpy as np\nfrom struct import unpack, pack\n \ndef stlReadBinary(fname):\n    fp = open(fname, \'rb\')\n    Header = fp.read(80)\n    nn = fp.read(4)\n    Numtri = unpack(\'i\', nn)[0]\n    #print nn\n    record_dtype = np.dtype([\n                  (\'normals\', np.float32,(3,)),  \n                  (\'Vertex1\', np.float32,(3,)),\n                  (\'Vertex2\', np.float32,(3,)),\n                  (\'Vertex3\', np.float32,(3,)) ,              \n                  (\'atttr\', \'<i2\',(1,) )\n    ])\n    data = np.fromfile(fp , dtype = record_dtype , count =Numtri)\n    fp.close()\n \n    Normals = data[\'normals\']\n    Vertex1= data[\'Vertex1\']\n    Vertex2= data[\'Vertex2\']\n    Vertex3= data[\'Vertex3\']\n \n    p = np.append(Vertex1,Vertex2,axis=0)\n    p = np.append(p,Vertex3,axis=0) #list(v1)\n    Points =np.array(list(set(tuple(p1) for p1 in p)))\n \n    return Header,Points,Normals,Vertex1,Vertex2,Vertex3,False\n \ndef stlReadAscii(fname):\n    fp = open(fname, \'r\')\n    Normals = []\n    Vertex1 = []\n    Vertex2 = []\n    Vertex3 = []\n    Points = []\n    while True:\n        line = fp.readline()\n        if not line: break\n        if line.find("solid") > -1 or line.find("endfacet") > -1: continue\n        if line.find("facet normal") > -1:\n            normline = line[line.find("facet normal")+len("facet normal"):]\n            normal = np.array([float(val.strip()) for val in normline.split()])\n            Normals.append(normal)\n            vertices = []\n            fp.readline() # outer loop\n            # read vertices after normal\n            for vIndex in range(0,3):\n                vLine = fp.readline()\n                vLine = vLine[vLine.find("vertex")+len("vertex"):]\n                vertices.append(np.array([float(val.strip()) for val in vLine.split()]))\n            Vertex1.append(vertices[0])\n            Vertex2.append(vertices[1])\n            Vertex3.append(vertices[2])\n            Points.extend(vertices)\n            fp.readline() # endloop\n    return "", Points, Normals, Vertex1, Vertex2, Vertex3,True\n     \n   \ndef stlRead(fname):\n    fp = open(fname, "r")\n    try:\n        if fp.readline().find("solid") > -1:\n            fp.close()\n            return stlReadAscii(fname)\n        else:\n            fp.close()\n            return stlReadBinary(fname)\n    except:\n        return stlReadBinary(fname)\n     \ndef stlWriteBinary(fname, normals, v1, v2, v3):\n    with open(fname, "wb") as fout:\n        # write 80 bytes header\n        for i in range(0, 80): fout.write(pack("<c", b" "))\n        fout.write(pack("<I", len(normals))) # number of triangles\n        for i in range(0, len(normals)):\n            fout.write(pack("<fff", *normals[i]))\n            fout.write(pack("<fff", *v1[i]))\n            fout.write(pack("<fff", *v2[i]))\n            fout.write(pack("<fff", *v3[i]))\n            fout.write(pack("<H", 0)) # attribute\n       \ndef writeVector(fd, vec):\n    for v in vec:\n        fd.write("{:.7e}".format(v))\n        fd.write(" ")\n       \ndef stlWriteAscii(fname, normals, v1, v2, v3):\n    with open(fname, "w") as fout:\n        fout.write("solid \\n")\n        for i in range(0, len(normals)):\n            fout.write("  facet normal ")\n            writeVector(fout, normals[i])\n            fout.write("\\n")\n            fout.write("    outer loop\\n")\n            fout.write("      vertex ")\n            writeVector(fout, v1[i])\n            fout.write("\\n")\n            fout.write("      vertex ")\n            writeVector(fout, v2[i])\n            fout.write("\\n")\n            fout.write("      vertex ")\n            writeVector(fout, v3[i])\n            fout.write("\\n")\n            fout.write("    endloop\\n")\n            fout.write("  endfacet\\n")\n       \n       \ndef stlWrite(fname, normals, v1, v2, v3, isAscii=False):\n    if isAscii:\n        stlWriteAscii(fname, normals, v1, v2, v3)\n    else:\n        stlWriteBinary(fname, normals, v1, v2, v3)\n       \n# test\nif __name__ == "__main__":\n    import sys\n    fname = sys.argv[1]\n    h,p,n,v1,v2,v3,isAscii = stlRead(fname)\n    print(len(n))\n    print(v1[0])\n    stlWriteBinary("binary.stl", n, v1, v2, v3);\n    stlWriteAscii("ascii.stl", n, v1, v2, v3); \n 用法: \n python stlSplitter.py solvespace_assembly_ascii.stl \n 目前可以分割從 Solvespace 轉出的組立檔案, 但是各零件比例與座標位置錯誤, 希望修正後可以套用到 wrl 組立件檔案的分割, 以便將 Solvespace 轉出的 wrl 組立檔案輸入 Webots. \n Solvespace 轉出的 STL 組件, 利用 stlSplitter.py 轉出各零件 STL 後, 再利用\xa0 https://www.patrickmin.com/meshconv/ \xa0轉為 WRL, 之後再將 WRL 零件轉入 Webots. \n STL 零件檔案也可以利用\xa0 https://github.com/cnr-isti-vclab/meshlab \xa0(GUI 以 Qt 編寫) 轉為 WRL, 之後再轉入 Webots. \n 相關 converter 程式與 meshconv.exe:\xa0 \n meshconv_stl_split_and_converter.7z  (for @nfu users only) \n 可攜  meshlab_portable.7z  (for @nfu users only) \n \n Split STL in Javascript:\xa0 http://mde.tw/cad2019/downloads/splitstl/ \n Split STL in C++:\xa0 https://github.com/admesh/stlsplit \n STL viewer in C:\xa0 https://github.com/hroncok/viewstl \n Flutter and three.js:\xa0 https://github.com/andreibosco/flutter_threejs_test \n An Optimal Algorithm for 3D Triangle Mesh Slicing.pdf  (for @nfu users only) \n Libfivepy \n https://gitlab.com/rcmz0/libfivepy \n https://github.com/mkeeter/fstl \n https://github.com/wxkNeter/qt-stl', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'Realizable', 'text': '機械元件建模工具: \n Solvespace  (開源)、 NX1980  (高端)、 Onshape  (全雲端) \n 電子電機控制與感測模擬工具: \n Beginning Robotics with Raspberry Pi and Arduino  (在校園網路下載) \n Wokwi (web-based): \n https://wokwi.com/ \n https://github.com/wokwi \n https://github.com/wokwi \n Servo motor 控制 \n Unoardusim  (單機) \n PICSimLab  (開源) \n 3D 列印與模擬工具 \n G-code based 列印模擬: \n https://github.com/sudipchakraborty/A-simulated-3D-Printer-In-CoppeliaSim  ( Paper ) \n https://github.com/mdecourse/gsim  (執行需要 PyGObject,  參考 ) \n https://github.com/mdecourse/FIBR3DEmul  (CoppeliaSim plugin in Cpp,  paper) \n G-code processing: \n https://github.com/mdecourse/gcode_machine \n 3D Printer based 列印模擬: \n https://all3dp.com/2/gcode-viewer-3d-printer-simulator-best-tools/ \n 雷射切割模擬工具: \n https://github.com/mdecourse/papercraft \xa0 (Unfold STL for laser cutting) \n', 'tags': '', 'url': 'Realizable.html'}, {'title': 'Bash', 'text': 'Bash:  https://en.wikipedia.org/wiki/Bash_(Unix_shell) \n acp \n #! /bin/bash\n# bash script for Linux and Mac\n# chmod u+x acp\n# source acp "commit message"\ngit add .\ngit commit -m "$1"\ngit push \n cms \n #! /bin/bash\n# for Linux and Mac\n# chmod u+x cms\n# source cms\npython3 cmsimde/wsgi.py \n ssh-keygen:  https://en.wikipedia.org/wiki/Ssh-keygen   \n chmod:  https://en.wikipedia.org/wiki/Chmod \n vi:  https://en.wikipedia.org/wiki/Vi \n References: \n 2021 Pro Windows Subsystem for Linux (WSL)  \n 2008 Beginning Ubuntu LTS Server Administration \n 2008 Beginning Ubuntu Linux', 'tags': '', 'url': 'Bash.html'}, {'title': 'Leo Editor', 'text': 'https://leoeditor.com/ \n https://github.com/leo-editor/leo-editor \n https://groups.google.com/g/leo-editor \n https://edreamleo.blogspot.com/', 'tags': '', 'url': 'Leo Editor.html'}, {'title': 'Fossil SCM', 'text': 'https://www.fossil-scm.org \n https://sqlite.org/whynotgit.html \n', 'tags': '', 'url': 'Fossil SCM.html'}, {'title': 'Classroom', 'text': 'https://youtu.be/4i1D5rIrkAM \n', 'tags': '', 'url': 'Classroom.html'}, {'title': 'Gazebo', 'text': 'https://gazebosim.org \n https://community.gazebosim.org/ \n https://gazebosim.org/docs/garden/install_windows_src \n', 'tags': '', 'url': 'Gazebo.html'}, {'title': 'Webots', 'text': 'https://cyberbotics.com \n https://github.com/cyberbotics/webots \n https://robotbenchmark.net/ \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'Deep RL', 'text': 'Deep Learning: \n Introduction to Deep Learning  from MIT (2022) \n Lecture  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  9 ,  10 \n Learning to play  (2020) \n Deep Reinforcement Learning  (2020) \n Deep Reinforcement Learning  (2022) \n Deep Reinforcement Learning Book  (2020) \n 模擬環境中機器人學習 \n Robotic Assembly Using Deep Reinforcement Learning  (2020) \n RL STaR Platform: Reinforcement Learning for Simulation based Training of Robots  (2020) \n Robots Learn Visual Pouring Task Using Deep Reinforcement Learning with Minimal Human Effort  (2021) \n Deep reinforcement learning based moving object grasping  (2021) \n https://github.com/gbartyzel/gym-vrep', 'tags': '', 'url': 'Deep RL.html'}, {'title': 'NX', 'text': 'https://www.plm.automation.siemens.com/global/en/products/nx/ \n 下載  NX12.0.2.9_lite_cad2022.7z  (for @gm users only, 1.20 GB, 解開後 6.24 GB) \n 下載  NX2027.3401_lite_cad2022.7z  (for @gm users only, 1.97 GB, 解開後 7.49 GB) \n 下載  NX2027.3401_cad2022.7z  (for @gm users only, 8.02 GB, 解開後 28.32 GB) \n 下載  NX2007_documentation.7z  (for @gm users only, 2.18 GB, 解開後 2.86 GB), 使用時執行 start_static.py 後, 以瀏覽器 http://localhost:7443 開啟. \n 線上  NX2007 EN Documentation . \n 完整版的 NX2027.3401 各目錄容量如下, 總容量為 28.32 GB, NX2206 總容量則為 31 GB: \n AUTOMATED_TESTING : 1.52 MB AUTOMATION_DESIGNER : 254.08 MB CAPITALINTEGRATION : 2.04 MB CATIAV5 : 784.01 KB CLOUDDM : 31.07 KB CMM_INSPECTION : 143.31 MB DESIGNSPACEEXPLORER : 7.31 KB DESIGN_TOOLS : 275.8 MB DIAGRAMCORE : 5.81 MB DIAGRAMMING : 64.65 MB DRAFTING : 123.65 MB DXFDWG : 206.79 MB IGES : 5.2 MB INSTALL : 55.55 KB LOCALIZATION : 1.09 GB MACH : 1.96 GB MANUFACTURING_PLANNING : 141.66 MB MBD : 54.05 MB MECH : 793.28 MB MECHATRONICS : 212.81 MB MENDIXREPORTING : 1.04 MB MOLDCOOLING : 12.28 KB MOLDWIZARD : 226.71 MB MPA : 1.5 MB NXAECDESIGN : 15.48 KB NXASSEMBLY : 120.98 MB NXBIN : 5.07 GB NXCABLEROUTER : 190.45 KB NXCAE_EXTRAS : 2.36 GB NXCOATINGS : 645.3 KB NXCREO : 6.17 MB NXHUMAN : 247.51 MB NXJOIN : 16.38 MB NXNASTRAN : 2.93 GB NXPARTS : 53.76 MB NXPLOT : 151.34 MB NXPROE : 6.17 MB NXREPORTS : 9.42 MB NXSHIP : 359.0 MB NXSTRUCTUREDESIGN : 106.47 MB NXVR : 441.53 MB NX_VSA : 13.88 MB OCCUPANTSAFETY : 514.74 MB POSTBUILD : 37.65 MB PSTUDIO : 35.5 MB PVTRANS : 102.46 KB REL_INFO : 36.92 KB ROUTING : 315.47 MB RULE : 316.7 KB SIMULATION : 4.19 GB STAGE_MODEL : 3.53 MB STAMPING_TOOLS : 77.06 MB STEP203UG : 1.28 MB STEP214UG : 1.27 MB TDP : 237.62 MB temp : 0B TOOLING_BASE : 970.0 KB TRANSLATORS : 157.87 MB UGALLIANCE : 82.9 KB UGAUTOMOTIVE : 99.41 MB UGCATIA : 6.53 MB UGFLEXLM : 29.4 MB UGFPCD : 35.19 KB UGII : 677.93 MB UGIMW : 8.45 MB UGMANAGER : 117.29 MB UGOPEN : 425.32 MB UGOPENPP : 567.28 KB UGPCBX : 3.42 MB UGPCBXCHANGE : 90.23 MB UGPHOTO : 2.98 GB UGSTRUCTURES : 735.35 MB UGSTUDIO : 14.03 MB UGTIPS : 278.35 MB UGTO2D : 911.38 KB UGWEB : 9.08 MB UGWELD : 2.07 MB UNFOLD : 71.92 KB VDA : 25.44 KB VDV : 13.11 KB total: 28.32 GB \n NX2206 只包含下列目錄 (CAD_lite), 檔案容量 7.5 GB: dir /b /ad > dir.txt \n DESIGNSPACEEXPLORER ( Webina r (41 分 19 秒 - View with Gmail account) DESIGN_TOOLS ( A look at NX Check-Mate ) DIAGRAMCORE (利用  yFiles  繪製 Diagrams) DIAGRAMMING ( Piping and Instrumentation Diagramming ) DRAFTING ( Basic Drafting Tutorial ) DXFDWG IGES INSTALL MECHATRONICS NXASSEMBLY NXBIN NXPARTS STEP203UG STEP214UG Temp TRANSLATORS UGFLEXLM UGII UGMANAGER UGOPEN UGOPENPP UNFOLD \n 若加上簡單的 CAE 工程分析模組 (CAX_lite), 檔案容量 21 GB: \n AUTOMATED_TESTING AUTOMATION_DESIGNER DESIGNSPACEEXPLORER DESIGN_TOOLS DRAFTING DXFDWG IGES INSTALL MACH MANUFACTURING_PLANNING MECHATRONICS NXASSEMBLY NXBIN NXCAE_EXTRAS NXHUMAN NXNASTRAN NXPARTS NXSTRUCTUREDESIGN SIMULATION STEP203UG STEP214UG Temp TRANSLATORS UGFLEXLM UGII UGMANAGER UGOPEN UGOPENPP UGSTRUCTURES UNFOLD \n 若包含全模組, 檔案容量 31 GB: \n AUTOMATED_TESTING AUTOMATION_DESIGNER CAPITALINTEGRATION CATIAV5 CLOUDDM CMM_INSPECTION DESIGNSPACEEXPLORER DESIGN_TOOLS DIAGRAMCORE DIAGRAMMING DRAFTING DXFDWG IGES INSTALL LOCALIZATION MACH MANUFACTURING_PLANNING MBD MECH MECHATRONICS MENDIXREPORTING MOLDCOOLING MOLDWIZARD MPA NXAECDESIGN NXASSEMBLY NXBIN NXCABLEROUTER NXCAE_EXTRAS NXCOATINGS NXCREO NXHUMAN NXJOIN NXNASTRAN NXPARTS NXPLOT NXPROE NXREPORTS NXSHIP NXSTRUCTUREDESIGN NXVR NX_VSA POSTBUILD PSTUDIO PVTRANS REL_INFO ROUTING RULE SAFETY SIMULATION STAGE_MODEL STAMPING_TOOLS STEP203UG STEP214UG TDP Temp TOOLING_BASE TRANSLATORS UGALLIANCE UGAUTOMOTIVE UGCATIA UGFLEXLM UGFPCD UGII UGIMW UGMANAGER UGOPEN UGOPENPP UGPCBX UGPCBXCHANGE UGPHOTO UGSTRUCTURES UGSTUDIO UGTIPS UGTO2D UGWEB UGWELD UNFOLD VDA VDV', 'tags': '', 'url': 'NX.html'}, {'title': 'NX1980_setup', 'text': '以下影片說明如何設定 Journal 存檔格式, 關閉 Product Execellence Program, 並查驗版本與授權使用單位: \n w5_nx_api.7z \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': 'NX1980_setup.html'}, {'title': 'NX2206', 'text': '2022.06.17 正式推出 SiemensNX-2206_wntx64.zip (10.9GB) \n NX2206 完整系統容量為 29.35 GB \n 以下列 get_dir_size.py 計算 NX2206 各目錄容量: \n import os\nimport math\n \ndef convert_size(size_bytes):\n    # from https://stackoverflow.com/questions/5194057/better-way-to-convert-file-sizes-in-python\n    if size_bytes == 0:\n        return "0B"\n    size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")\n    i = int(math.floor(math.log(size_bytes, 1024)))\n    p = math.pow(1024, i)\n    s = round(size_bytes / p, 2)\n    return "%s %s" % (s, size_name[i])\n    \ndef get_dir_size(path=\'.\'):\n    # from https://note.nkmk.me/en/python-os-path-getsize/\n    total = 0\n    with os.scandir(path) as it:\n        for entry in it:\n            if entry.is_file():\n                total += entry.stat().st_size\n            elif entry.is_dir():\n                total += get_dir_size(entry.path)\n    return total\n \n#for (root,dirs,files) in os.walk(\'./\', topdown=True):\n    #print (dirs)\n \ntotal = 0\nnx_dir_list = os.listdir(\'./\')\nfor i in nx_dir_list:\n    try:\n        # skip files\n        total += get_dir_size(i)\n        print(i, ":", convert_size(get_dir_size(i)))\n    except:\n        #print(i)\n        pass\nprint("total:", convert_size(total)) \n 執行結果: \n AUTOMATED_TESTING : 3.9 MB\nAUTOMATION_DESIGNER : 276.42 MB\nCAPITALINTEGRATION : 2.04 MB\nCATIAV5 : 763.49 KB\nCLOUDDM : 99.22 KB\nCMM_INSPECTION : 143.32 MB\nDESIGNSPACEEXPLORER : 7.87 KB\nDESIGN_TOOLS : 64.18 MB\nDIAGRAMCORE : 5.77 MB\nDIAGRAMMING : 51.07 MB\nDRAFTING : 123.71 MB\nDXFDWG : 207.4 MB\nIGES : 5.2 MB\nINSTALL : 55.05 KB\nLOCALIZATION : 1.1 GB\nMACH : 1.96 GB\nMANUFACTURING_PLANNING : 136.6 MB\nMBD : 62.8 MB\nMECH : 568.6 MB\nMECHATRONICS : 216.88 MB\nMENDIXREPORTING : 1.04 MB\nMOLDCOOLING : 12.17 KB\nMOLDWIZARD : 230.24 MB\nMPA : 1.5 MB\nNXAECDESIGN : 32.3 MB\nNXASSEMBLY : 127.27 MB\nNXBIN : 5.24 GB\nNXCABLEROUTER : 205.75 KB\nNXCAE_EXTRAS : 3.3 GB\nNXCOATINGS : 645.3 KB\nNXCREO : 6.19 MB\nNXHUMAN : 247.8 MB\nNXJOIN : 18.22 MB\nNXNASTRAN : 2.94 GB\nNXPARTS : 53.28 MB\nNXPLOT : 255.92 MB\nNXPROE : 6.19 MB\nNXREPORTS : 9.45 MB\nNXSHIP : 340.46 MB\nNXSTRUCTUREDESIGN : 121.55 MB\nNXVR : 446.12 MB\nNX_VSA : 13.88 MB\nPOSTBUILD : 37.65 MB\nPSTUDIO : 35.5 MB\nPVTRANS : 104.49 KB\nREL_INFO : 36.92 KB\nROUTING : 324.37 MB\nRULE : 302.85 KB\nSAFETY : 522.78 MB\nSIMULATION : 4.29 GB\nSTAGE_MODEL : 3.53 MB\nSTAMPING_TOOLS : 93.18 MB\nSTEP203UG : 1.28 MB\nSTEP214UG : 1.27 MB\nTDP : 237.67 MB\nTOOLING_BASE : 970.12 KB\nTRANSLATORS : 157.99 MB\nUGALLIANCE : 85.09 KB\nUGAUTOMOTIVE : 105.7 MB\nUGCATIA : 6.55 MB\nUGFLEXLM : 31.5 MB\nUGFPCD : 35.19 KB\nUGII : 698.39 MB\nUGIMW : 8.45 MB\nUGMANAGER : 118.83 MB\nUGOPEN : 436.93 MB\nUGOPENPP : 567.28 KB\nUGPCBX : 3.92 MB\nUGPCBXCHANGE : 81.62 MB\nUGPHOTO : 2.99 GB\nUGSTRUCTURES : 789.79 MB\nUGSTUDIO : 14.03 MB\nUGTIPS : 192.46 MB\nUGTO2D : 921.06 KB\nUGWEB : 9.08 MB\nUGWELD : 2.07 MB\nUNFOLD : 71.92 KB\nVDA : 25.43 KB\nVDV : 14.55 KB\ntotal: 29.35 GB \n 假如只需要 NX2206 Modeling, Drawing, Mechatronic Design Studio, Product Template Studio 等功能, 則只需要下列目錄檔案, 容量為 7.49GB, NX2206_CAD_lite.7z: \n DESIGNSPACEEXPLORER : 7.87 KB\nDESIGN_TOOLS : 64.18 MB\nDIAGRAMCORE : 5.77 MB\nDIAGRAMMING : 51.07 MB\nDRAFTING : 123.71 MB\nDXFDWG : 207.4 MB\nIGES : 5.2 MB\nINSTALL : 55.05 KB\nMECHATRONICS : 216.88 MB\nNXASSEMBLY : 127.27 MB\nNXBIN : 5.24 GB\nNXPARTS : 53.28 MB\nSTEP203UG : 1.28 MB\nSTEP214UG : 1.27 MB\nTemp : 1.02 KB\nTRANSLATORS : 157.99 MB\nUGFLEXLM : 31.5 MB\nUGII : 698.39 MB\nUGMANAGER : 118.83 MB\nUGOPEN : 436.93 MB\nUGOPENPP : 567.28 KB\nUNFOLD : 71.92 KB\ntotal: 7.49 GB \n 基本 NX2206 CAD 教育版功能模組: \n # NX Academic - Core & CAD\n3d_to_2d_flattener\nacis_nx_translator\nadv_assemblies\nadv_sheet_metal_dsgn\naero_sheet_metal\nassemblies\ncam_additive_1\ncam_additive_2\ncam_additive_post\ncam_robotics_1000\ncam_robotics_1001\ncam_robotics_1002\ncam_robotics_1003\ncam_robotics_1004\ncam_robotics_1006\ncam_robotics_1009\ncatv5_nx_sca\nconf_cooling_channel\ndes_top_opt\ndesign_studio\ndie_engineering\ndrafting\ndxf_to_ug\ndxfdwg\nfeatures_modeling\nfree_form_modeling\ngateway\ngeometric_tol\ngrip_execute\nifc_to_nx\niges\ninsp_programming\nld_line_designer\nmrl_connect\nnx_3d_path_planning\nnx_4gd_integration\nnx_access_tcclass\nnx_additive_design\nnx_aero_design\nnx_animationdesigner\nnx_cam_deburr_planar\nnx_cam_deburring3x\nnx_cam_deburring4x\nnx_cam_deburring5x\nnx_cam_rotary_4x\nnx_cam_smks_3x\nnx_cam_smks_4x\nnx_cam_smks_additive\nnx_cam_smks_complex\nnx_cam_turn_prime\nnx_coatings\nnx_design_explorer\nnx_diagramming\nnx_drawing_auto\nnx_electrode_wizard\nnx_flexible_pcb\nnx_freeform_1\nnx_freeform_2\nnx_gc_toolkit\nnx_general_packaging\nnx_issue_mgmt\nnx_isv_mtb\nnx_isv_vm_hmi\nnx_jacktkapi\nnx_join\nnx_lnx_batch\nnx_mc_basic\nnx_mc_full\nnx_mcd_core\nnx_ml_cmd_pred_ui\nnx_onestep_analysis\nnx_penetration_mgmt\nnx_pid_design_author\nnx_pmi_effectivity\nnx_point_cloud_view\nnx_polygon_modeling\nnx_post_config_adv\nnx_post_config_full\nnx_posture\nnx_reuse_cadenas\nnx_samcef_ui\nnx_sdpd_mpm_a\nnx_sdpd_mpm_v\nnx_sdpd_pam_a\nnx_sdpd_pam_v\nnx_sheet_metal\nnx_ship_basic\nnx_ship_concept\nnx_ship_detail\nnx_ship_drafting\nnx_ship_gen_arrange\nnx_ship_mfg_prep\nnx_snap_author\nnx_structure_design\nnx_subdivision\nnx_sysnoise_bem\nnx_to_ifc\nnx_visual_reporting\nnx_wi_authoring\nnx_xr\npcf_package_file\nproenx\nprog_die_wizard\npstudio_cons\npts_author\npts_consumer\npv_ugdatagenerator\nrouting_advanced\nrouting_base\nrouting_cabling\nrouting_harness\nrouting_hvac\nrouting_pid\nrouting_pipetube\nrouting_platform\nsc_des_topol_opt\nsc_fp_sa\nsc_fp_sa_beam\nsc_fp_sa_dyn\nsc_fp_sa_dyn_nl\nsc_fp_sa_opt\nsc_fp_sa_shell\nshape_search\nsinumerik_spline\nsla_3d_systems\nsolid_modeling\nstd_ug_library\nstep_ap203\nstep_ap214\nstep_ap242\nstructure_weld\nstudent_read\nstudio_analyze\nstudio_free_form\nstudio_render\nstudio_visualize\nug_body_design\nug_checkmate\nug_comp_flattener\nug_comp_pipeline\nug_die_design\nug_human\nug_kf_author\nug_kf_checker\nug_kf_execute\nug_mold_design\nug_opt_wizard\nug_prod_des_advisor\nug_visualize\nug_web_express\nugopen_menuscript\nugweld\nui_styler\nusr_defined_features\nwave \n 假如要再加上 CAE 與 CAM 功能, 則需要下列目錄, 容量為 21.47GB, NX2206_CAX_lite.7z \n AUTOMATED_TESTING : 3.9 MB\nAUTOMATION_DESIGNER : 276.42 MB\nDESIGNSPACEEXPLORER : 7.87 KB\nDESIGN_TOOLS : 64.18 MB\nDRAFTING : 123.71 MB\nDXFDWG : 207.4 MB\nIGES : 5.2 MB\nINSTALL : 55.05 KB\nMACH : 1.96 GB\nMANUFACTURING_PLANNING : 136.6 MB\nMECHATRONICS : 216.88 MB\nNXASSEMBLY : 127.27 MB\nNXBIN : 5.24 GB\nNXCAE_EXTRAS : 3.3 GB\nNXHUMAN : 247.8 MB\nNXNASTRAN : 2.94 GB\nNXPARTS : 53.28 MB\nNXSTRUCTUREDESIGN : 121.55 MB\nSIMULATION : 4.29 GB\nSTEP203UG : 1.28 MB\nSTEP214UG : 1.27 MB\nTemp : 0B\nTRANSLATORS : 157.99 MB\nUGFLEXLM : 31.5 MB\nUGII : 698.39 MB\nUGMANAGER : 118.83 MB\nUGOPEN : 436.93 MB\nUGOPENPP : 567.28 KB\nUGSTRUCTURES : 789.79 MB\nUNFOLD : 71.92 KB\ntotal: 21.47 GB \n NX2206 基本 CAE + CAM 教育版功能: \n # NX Academic Perpetual License CAE+CAM\n3d_to_2d_flattener\nappearance_mgmt\nappearance_mgmt_aw\nappearance_mgmt_mgd\nassemblies\ncam_additive_3\ncam_base\ncam_facets\ncavity_milling\ncontour_profile\ndmu_markup\ndxf_to_ug\ndxfdwg\nelma\nfbm_author\nfix_axis_surf_mill\nflow_cut\ngateway\ngmc\ngraphical_tool_path\ngrip_execute\niges\nmechanisms\nmotion_cd_tire\nmotion_ext_control\nmotion_flex_modal\nmotion_std_tire\nmotion_swift_tire\nmotion_tno_tire\nnc_external_program\nnc_wizard_builder\nnurb_output_enabler\nnx_3d_swept_volume\nnx_abaqus_env\nnx_abaqus_export\nnx_abaqus_export_g\nnx_abaqus_import\nnx_acoustic_modeling\nnx_acoustics_bem_hpc\nnx_adv_durability\nnx_adv_fld_mod_solv\nnx_adv_fluid_mod\nnx_algorithmic\nnx_ansys_env\nnx_ansys_export\nnx_ansys_export_g\nnx_ansys_import\nnx_cam_deburring4x\nnx_cam_rotary_4x\nnx_cam_smks_3x\nnx_cam_smks_4x\nnx_cam_smks_complex\nnx_correl_base\nnx_correl_update\nnx_design_sim\nnx_drafting_plus\nnx_draw_shape\nnx_durability_wiz\nnx_easyfill_advanced\nnx_easyfill_analysis\nnx_esc_solv\nnx_esc_ui\nnx_flow_adv_solv\nnx_flow_adv_ui\nnx_flow_solver\nnx_flow_ui\nnx_general_packaging\nnx_implicit\nnx_isv_mtb\nnx_lam_comp_adv\nnx_lam_composites\nnx_layout\nnx_lsdyna_export\nnx_lsdyna_import\nnx_mach_line_planner\nnx_masterfem\nnx_mbd\nnx_ml_sel_pred_std\nnx_ml_show_hide\nnx_mlp_setup\nnx_mlp_solid\nnx_mscnastran_env\nnx_mu_notifications\nnx_multi_blade_mill\nnx_nas_acous_adv\nnx_nas_aero_dsk\nnx_nas_bn_basic_dsk\nnx_nas_dmap_dsk\nnx_nas_dyn_dsk\nnx_nas_nonlin_dsk\nnx_nas_optim_dsk\nnx_nas_rotdyn_dsk\nnx_nas_supel_dsk\nnx_nas_topol\nnx_nas_uss_dsk\nnx_nastran_export\nnx_nastran_export_g\nnx_post_config_adv\nnx_response_anlys\nnx_ship_super_plate\nnx_space_therm_solv\nnx_space_therm_ui\nnx_spsd_stress\nnx_spsd_vibration\nnx_sysnoisebem_ui\nnx_tdp\nnx_thermal_adv_solv\nnx_thermal_adv_ui\nnx_thermal_solver\nnx_thermal_ui\nnx_tilt_tool_axis\nnx_vr_sudr\nnx_wedm_base\nnx_wedm_extra\nnx_wedm_gear\nnx_wedm_ruled\nnx_wedmp_db\nnx_wedmp_no_db\nnx_wi_authoring\nplanar_milling\nprobe\npstudio_auth\npstudio_cons\npv_ugdatagenerator\nsequential_milling\nshop_doc\nsla_3d_systems\nstage_model\nstep_ap203\nstep_ap214\nsurface_milling\nsync_mgr\ntol_cavity_milling\nug_epak\nug_holemaking\nug_isv_full\nug_kf_execute\nug_library_access\nug_nas_bn\nug_nas_des\nug_pcb_exchange\nug_pcb_modeler\nug_post_exe\nug_post_kinematics\nug_post_mill\nug_schematics\nug_smart_models\nug_strength_wizard\nug_to_dxf\nug_to_vericut\nug_turning\nug_visualize\nugopen_menuscript\nvar_axis_surf_mill\nvehicle_des_val\nwire_edm_machining \n \n', 'tags': '', 'url': 'NX2206.html'}, {'title': 'NXOpen', 'text': 'NX Open is an Application Programming Interface (API) that lets you write programs to customize or extend NX. The benefit is that applications created this way can often speed up repetitive tasks, and capture important design process knowledge. \n Python 範例: UGOPEN\\SampleNXOpenApplications\\Python \n Introduction_to_NXOpen.pdf  from  https://github.com/derda48/NXOpen \n NXOpen Programmer\'s Guide  (NX12) \n NXOpen for Python Reference Guide  (NX12 \n NXOpen_spur_gear.c \n Get Started with NXOpen.pdf  (2019) \n NX10:  https://docs.plm.automation.siemens.com/data_services/resources/nx/10/nx_api/en_US/custom/nxopen_python_ref/index.html \n NX12:  https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/custom/en_US/nxopen_python_ref/index.html \n SNAP_Getting_Started_nx1872.pdf \n A  Component  (組件) is an  occurrence  (事件) whose  prototype  (原型) is a NXOpen.Part. \n Component 為電腦事件, 其原型為零件檔案. \n 下圖的黃色部分即為組件 (Components), 也就是所謂的零件事件. 透過組件間的樹狀結構, 就可以得知組立件中的零件組成, 而無需開啟零件檔案. \n 每一個組立件中都有一個根組件 (RootComponent), 也就是該組立件的樹狀結構源頭. 若一個 prt 檔案中並無根組件, 代表其並非組立件. \n 因為每一個組件都應該帶有連結到其子組件、父組件與其零件檔案的連結. 而其中的零件檔案就稱為該組件的原型. 至於根組件並非"真實的"組件, 因為其原型連結有特殊意義, 也就是根組件的原型連結會"連回"其零件檔案本身. \n \n \n NXOpen Python 程式範例: \n nxopen_ex1.py \n nxopen_ex2.py \n nxopen_ex3.py \n Convert VB to Python: \n https://community.sw.siemens.com/s/question/0D54O000061xRnYSAU/convert-vb-to-python   \n Referene: \n NX 各版本技術手冊 \n https://docs.plm.automation.siemens.com/tdoc/nx/1899/nx_help \n NX1980\\NXBIN\\managed\\exceladdin_x64.dll \n ugii_env_ug.dat.txt \n UGII_PYTHONPATH \n UGII_PYTHON_LIBRARY_DIR \n https://ntnuopen.ntnu.no/ntnu-xmlui/handle/11250/2656770  (Design of a KBE system for automatic weld path definition in CAD \n', 'tags': '', 'url': 'NXOpen.html'}, {'title': 'Mechatronics', 'text': 'Mechatronic Concept Designer \n NX10_MCD_Quick_Start.pdf \n Mechatronics_Cooncept_Designer_WP.pdf \n TURN-TABLE_MODEL_MECHATRONIC_CONCEPT_DESIGNER.pdf \n Creating a Static 3D Model Using the NX CAD System.pdf \n 借助 CAD 系统 NX 创建静态 3D 模型.pdf \n Creation_of_a_dynamic_3D_model_using_the_MCD.pdf \n 使用 CAE 系统 Mechatronics Concept Designer 创建动态 3D 模型.pdf \n Configuration of the Automation Program of a Dynamic 3D Model in the TIA Portal.pdf \n 通过动态 3D 模型 实现制造工厂的虚拟调试.pdf \n Web Based Customized Design.pdf \n Mechatronics Concept Designer is a new solution for concept design of mechatronics products. The software enables 3D modeling and simulation of concepts with multi-body physics and automation-related behavior typically found in mechatronics products. \n Supporting a functional design approach, Mechatronics Concept Designer integrates upstream and downstream engineering domains, including requirements management, mechanical design, electrical design, and software/automation engineering. \n Mechatronics Concept Designer accelerates development of products that involve mechanical, electrical, and software design disciplines, allowing them to work in parallel, focused on a concept design that includes mechanical components, sensors, actuators, and motion.\xa0 \n', 'tags': '', 'url': 'Mechatronics.html'}, {'title': 'CoppeliaSim', 'text': 'CD (Collaborative Design) 協同產品設計實習課程, 旨在探討多名設計人員, 從利用 NX 及 Solvespace 等單機套件, 過渡到採用 Onshape 雲端 MCAD 套件執行零組件繪製後, 並匯入 CoppeliaSim 建立機電資系統整合模擬流程中, 該如何執行同步 (Simultaneous) 協同設計? \n Controlling your robot with Python \n How to pick a mobile robot simulator: A quantitative comparison of CoppeliaSim, Gazebo, MORSE and Webots with a focus on accuracy of motion \n User Manual:  https://mde.tw/pjcopsim  (相關專題:  https://mde.tw/pj5083 ) \n https://www.coppeliarobotics.com/ \n https://github.com/CoppeliaRobotics \n ABB SCARA Robots: \n https://new.abb.com/products/robotics/industrial-robots/irb-920t \n abb_irb_920t.ttt \n Foosball Table: \n cad2022_foosball_table.ttt  ( source ) \n foosball_nx2206.7z  (4.237 MB) \n foosball_nx12.7z  (2.75 MB) \n Foosball Table Goalkeeper Automation Using Reinforcement Learning.pdf , 2021 ( source ) \n Real-Time Ball Tracking in a Semi-automated Foosball Table  (2009) \n https://www.cambridgeconsultants.com/insights/opinion/diary-developer-part-3-foosbot-strategy  (2019) \n KIRo  (2002,  source ) \n KIcker  (2020) \n FoosAI  (2017) \n AI learns to play table soccer  (2018) \n Training a Reinforcement Learning Agent to play Soccer  (2020) \n mdecourse/site-40623128: site-40623128 created by GitHub Classroom  (2018) \n mdecourse/site-40623130: site-40623130 created by GitHub Classroom  (2018) \n mdecourse/site-40623224: site-40623224 created by GitHub Classroom  (2018) \n 40623224 Foosball Table using Onshape  (2018) \n The Study of Semi-Automated Football Table  (2022) \n Snooker Table: \n Snooker Table Assembly_sldasm.stp  ( source )', 'tags': '', 'url': 'CoppeliaSim.html'}, {'title': 'Foosball', 'text': 'foosball keyword searching on IEEE \n Development Of Robotic Foosball As A Versatile Platform For Robotics Research and Contests  (2003) \n Kiro  (2006) \n Space Foosball: Coupling Tangible Interfaces with a Real-time Game Physics Engine  (2009) \n Automated Foosball Table  (2013) \n https://2019wcm.blogspot.com/search/label/foosball \n https://www.ximea.com/en/corporate-news/foosball-table-robot-camera \n Foosball tracking  (2012) \n Foose  (2012) \n https://cduck.me/2015/robotic-foosball-table/  (2015) \n https://www.siliconrepublic.com/machines/chess-go-and-now-foosball-ai-is-coming-for-you  (2016) \n https://www.thestar.com/news/insight/2016/05/12/can-a-computer-beat-you-at-foosball-yes-yes-it-can.html  (2016) \n Low latency vision-based control for robotics  (2018) \n KIcker  (2021) \n https://youtu.be/Hu7LFrP43tA \n https://forum.allaboutcircuits.com/threads/automated-foosball-hardware-advice-for-crazy-speeds.137860/ \n foosball_solvespace_vrep.7z', 'tags': '', 'url': 'Foosball.html'}, {'title': 'Mujoco', 'text': 'https://mujoco.org/ \n https://mujoco.readthedocs.io/en/latest/overview.html \n https://www.deepmind.com/blog/opening-up-a-physics-simulator-for-robotics \n https://www.coursehero.com/study-guides/boundless-biology/somatosensation/ \n https://www.deepmind.com/blog/open-sourcing-mujoco \n https://github.com/deepmind/mujoco \n', 'tags': '', 'url': 'Mujoco.html'}, {'title': 'ROS', 'text': 'Robot Operating System for Absolute Beginners  (2022) \n', 'tags': '', 'url': 'ROS.html'}, {'title': 'Projects', 'text': '在大學階段執行專案題目研究 (即畢業專題) 的目的: \n \n 整合 專業課程所學, 實際 體驗 多人 協同 完成任務的過程 \n 學習如何 規劃並管理 多人協同 專案 \n 學習如何 搜尋、歸納及應用文獻 資料 \n 學習如何 編寫 研究 報告 \n 學習如何 簡報 研究 結果 \n 針對 研究所 推薦甄試標的, 提供具體 佐證資料 \n \n \n Senior Design Projects in Mechanical Engineering  (2022) \n 2022 Projects: \n pj40921:  https://github.com/mdecycu/pj40921 \n pj40922:  https://github.com/mdecycu/pj40922 \n pj5083:  https://github.com/mdecycu/pj5083 \n 2021 Projects: \n https://github.com/mdecycu/4072pj1  - 中興機研所 (2) 北科機電所 (1) \n https://github.com/mdecycu/4072pj2  - 中央機研所 (1) \n https://github.com/mdecycu/4072pj3  - 中興機研所 (1) 海大機電所 (1) 台科色彩所 (1) 虎科機設所 (1) \n https://github.com/mdecycu/pj5073 \n 2020 Project: \n https://github.com/mdecycu/airhockey  - 中興機研所 (3) 虎科機設所 (1) \n 2019 Project: \n https://mde.tw/kll3pp  - 台科機研所 (1) \n https://www.youtube.com/shorts/TNzToIqLJIU \n       \n 平面多連桿機構之合成與應用  (4+1 碩論) - 台大機研所博班 \n 深度學習在機器人視覺辨識中的應用  (4+1 碩論) - 台大機研所博班 \n Django 網際框架在平面四連桿尺寸合成系統上的應用  (2015) \n 網際程式框架在平面連桿機構尺寸合成系統上的應用  (2013) \n 網際雙自由度凸輪機構尺寸合成系統  (2012) \n 網際符號輔助軸接連桿機構之基因演算法尺寸合成系統  (2012 4+2 碩論) - 中正機研所博班 \n 網際史都華平台機構逆運動學分析與模擬  (2012) \n 網際六軸機械臂系統的逆運動學分析與模擬  (2010) \n 基因演算法在網際機構合成系統上的應用  (2009)', 'tags': '', 'url': 'Projects.html'}, {'title': 'pjcopsim', 'text': '專題動機: \n CoppeliaSim 的 用戶手冊 , 資料來自  helpFiles  倉儲, 但從網頁連結上, 只能取得最新版的資料, 隨著 CoppeliaSim 主要程式庫與模組的 API 架構不斷翻新, 當使用者採用舊版本套件時, 從 用戶手冊 就會攫取到不相應的內容. \n 探討如何利用網際內容管理系統架構, 讓 Coppeliasim 用戶手冊, 得以更加容易進行資料附加與應用, 擬藉此提升課程教學與專題研究效益. \n 相關轉檔程式:  https://github.com/mdecycu/copsimdoc \n 初步結果:  https://mde.tw/pjcopsim \n AI and CoppeliaSim: \n Deep Learning: \n Introduction to Deep Learning  from MIT (2022) \n Lecture  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  8 ,  9 ,  10 \n Vista  on Coppeliasim \n Tree-based Machine Learning for Image Recognition: \n From local explanations to global understanding with explainable AI for trees \n https://www.nature.com/articles/s42256-019-0138-9.epdf   \n https://suinlee.cs.washington.edu/home   \n https://erdogant.github.io/treeplot/pages/html/index.html   \n Interpretable Machine Learning: \n https://christophm.github.io/interpretable-ml-book/influential.html  ', 'tags': '', 'url': 'pjcopsim.html'}, {'title': 'Webots Doc', 'text': '網際文件處理技術 \n 2019 年時 Webots 的使用者手冊文件目錄, 位於  docs , 其中  doc.php  負責處理當時網站 /doc 目錄下的文件網際派送, 共有三個主要文件: \n Webots Guide:  https://cyberbotics.com/doc/guide/index \n Webots Reference Manual:  https://cyberbotics.com/doc/reference/index \n Webots for Automobiles:  https://cyberbotics.com/doc/automobile/index \n 意即, 2019 年時 Webots 的網頁採用 php 程式, WWW 伺服器採用 Apache, 而操作系統則使用 Ubuntu. (註: 目前的  docs 架構 已經與當時完全不同). \n 從當年的  local_exporter.py  也可以發現, Webots 建議在近端使用 doc 目錄下文件的方式為, 利用 local_exporter.py 從官方網站下載 index.html 與 dependencies 目錄中所需的 Javascript, 然後再透過 index.html 導引各 Javascript 程式, 從 guide, reference 與 automobile 目錄中, 將 markdown 格式文件動態轉為 html. \n 利用 Markdown 與 Javascript 處理遠端與近端文件的好處是, 文件管理人員可以採用各式合用的文字編輯器管理所有 Markdown 檔案, 且各版本間的內容可以納入分散式版次管理系統, 不僅能夠多人非同步協同, 且透過資料庫中版次的內容擷取, 可以在同一網站中透過網際 URL 版次變數的宣告而擷取不同版本的文件. \n 例如:  https://www.cyberbotics.com/doc/guide/page?version=R2019a  可以取得倉儲中 tag 為 R2019a 版次的 Webots guide 文件內容. \n 而  https://www.cyberbotics.com/doc/guide/page?version=R2019a-rev1  則是 R2019a-rev1 版次的文件內容. \n 以上處理網際文件的技術, 除了能夠將軟體套件的手冊納入分散式版次管理系統 (如 Git 或 Fossil SCM) 之外, 還能讓之後的多語系文件, 以不同的 Markdown 文件目錄儲存, 然後在主文件連結中提供不同語系 Markdown 文件所在目錄即可, 例如: \n /doc/guide_zh-TW 指向中文正體文件目錄, 而 /doc/guide_zh-CN 則指向中文簡體文件目錄等, 各語系文件可以採用分散式版次管理的流程, 以非同步協同方式自行管理維護不同 Webots 套件的各種技術文件. \n KMOL 能夠從 Webots 技術文件處理流程中學到甚麼? \n 這應該是一個不錯的 4+1 碩士題目:-) \n Webots 早在 2008-2009 年間, 就已經 透過  https://en.wikibooks.org/wiki/Cyberbotics%27_Robot_Curriculum  完成兩本導引課程文件的建構: \n Cyberbotics Robot Curriculum.pdf \n Design and Assessment of a Robot Curriculum based on the E-puck Robot and Webots.pdf \n 假如當年在編輯處理這些資料的過程, 能夠採用 Git ( Git on Wikipedia ) 或 Fossil SCM ( Fossil on Wikipedia ) 分散式版次管理系統, 現在應該就不只留下  Wikibooks  或 pdf 等零散資料, 而是能夠讓隨後的學員回到當時的網際技術與文件格式情境, 充分了解改版與內容取捨細節, 以便更近一步掌握過去十年各種電腦與網路技術推陳出新的脈絡, 作為之後判斷與持續改進的依據. \n', 'tags': '', 'url': 'Webots Doc.html'}, {'title': 'pjgazebo', 'text': "Gazebo 套件的安裝與應用研究 \n Installation and application study of the Gazebo software \n 專題動機: \n CoppeliaSim 雖然提供 主要程式庫 與 各模組 的原始碼, 但根據其 使用授權 所載內容, 卻遠不如  Gazebo   使用授權 ( Apache-2.0 ) 開放. 意即, 學生在校期間針對 CoppeliaSim 所研究或開發的延伸套件, 往後若要在業界沿用, 仍必須受到官方關鍵模組使用授權的箝制. 為了提升在機電系統產品開發流程上的自由度, 除了課程教學使用 CoppeliaSim 外, 也希望對  Gazebo  之配置安裝與後續使用授權方面, 能有更深入的探討與研究. \n 並且, 最近幾年正是 Gazebo 套件從  classic Gazebo  轉為  Gazebo  的時間點, 推出時程規劃可參見  releases , 由於 classic Gazebo 的 版本釋出 以 source codes 為主, 在 Windows 操作系統安裝配置的參考資料較少, 而新版的 Gazebo 則提供較詳細的 安裝步驟 . 因此本專題將研究新版本 Gazebo 的安裝流程與其後續模擬應用. \n 研究主題: \n \n 建立 Gazebo 機電資模擬場景 (Pick and Place, Fosball Table, Switch-like Ball Game Playground) \n 深度強化學習:  https://github.com/topics/deep-reinforcement-learning?l=python   \n Python 分散式運算研究與應用:  https://github.com/ray-project/ray \n \n 研究方法: \n \n 文獻探討: (一)  How to pick a mobile robot simulator: A quantitative comparison of CoppeliaSim, Gazebo, MORSE and Webots with a focus on accuracy of motion , (二)  Feature and performance comparison of the V-REP, Gazebo and ARGoS robot simulators , (三)  Comparative Analysis Between Gazebo and V-REP Robotic Simulators , (四)  https://learn.e.ros4.pro/en/robotic_simulators/comparison/ . \n 依據 安裝步驟 , 完成新版 Gazebo 的安裝. ( https://github.com/gazebosim/gz-sim ) \n 研究是否可以將 Gazebo 配置為可攜套件. \n 嘗試利用 Gazebo 模擬 foosball table 機電系統. \n 嘗試利用 Gazebo 模擬  uarm robot  機械手臂 pick and place 流程. \n 比較 Gazebo 與 CoppeliaSim 在安裝配置與模擬應用流程上的差異. \n \n 從  https://gazebosim.org/about  可得知 gazebo 正面臨關鍵改版中, 引用官方網站內容說明如下: \n Gazebo is a collection of open source software libraries designed to simplify development of high-performance applications. The primary audience for Gazebo are  robot developers ,  designers, and educators . However, Gazebo has been structured to suit many different use cases. Each library within Gazebo has minimal dependencies, allowing them to be used in tasks ranging from solving mathematical transforms, to video encoding, and up to simulation and process management. Just choose the libraries you need for your application without committing to a whole ecosystem. Trust and reliablity has been established through a curation and maintainence process lead by  Open Robotics  in collaboration with a community of developers. Each library within Gazebo has been designed to serve a specific purpose. This philosophy reduces code clutter, establishes consistency between libraries, and simplifies finding solutions. Development and maintenance adheres to a protocol consisting of multiple reviews, code checkers, and continuous integration. Take a look at Gazebo's roadmap for upcoming features and the latest improvements. \n https://gazebosim.org/docs/garden/install_windows_src", 'tags': '', 'url': 'pjgazebo.html'}, {'title': 'pjcontrol', 'text': 'Automatic Control Systems With MATLAB  (2022) \n Python for MATLAB Development  (2022) \n Control Systems  (2022) \n https://lcapy.readthedocs.io/en/latest/   \n https://github.com/mdecycu/multisim   \n https://www2.mvcc.edu/users/faculty/jfiore/OpAmps/OperationalAmplifiersAndLinearICs_3E.pdf   \n 將上述課程範例, 改為以  https://github.com/python-control/python-control  解題.', 'tags': '', 'url': 'pjcontrol.html'}, {'title': 'pjgithub', 'text': '專題動機: \n 設法利用 Github 與 Github Actions 功能, 簡化網際內容管理系統的製作流程, 使得參與協同產品設計者可以快速建立具版次管理的設計歷程網頁、網頁式簡報與結案報告 (pdf). \n 專題成員可以將 Github 倉儲 import 至 Replit, 並利用其 IDE 編輯器環境協同管理所有檔案. 在 Replit 改版後的資料可以 git push 回 Github 倉儲, 而在 Github 改版的內容, 則可自 Replit 專案中以 pull 功能取回. \n github actions 自動轉靜態網頁研究 \n https://github.com/features/actions \n https://docs.github.com/en/actions \n github_actions.7z \n References: \n https://www2.fossil-scm.org \n https://github.com/mdecycu/cmsimde \n https://github.com/KmolYuan/reveal-yaml-rs \n https://github.com/KmolYuan/latex-paper \n https://replit.com \n \xa0', 'tags': '', 'url': 'pjgithub.html'}, {'title': 'pjexam', 'text': '以 Python Flask 改寫  TCExam . \n 專案動機: \n \n TCExam 採 PHP 編寫, 可利用 PostgreSQL 資料庫儲存資料, 因流程完整, 值得深入研究, 並改以較具未來性的 Python 進行改寫. \n 若採人工命題, 可以建立各通識或專業課程有關的題目, 讓學員自行評測或作為教學評量. \n 因  https://en.wikipedia.org/wiki/Wikipedia:Database_download  可取得與各學科有關的知識內容, 長遠上可朝電腦輔助命題的方向進行研究. \n \n 研究主題: \n \n PostgreSQL 資料庫系統 \n Python Flask 與 PostgreSQL 結合運用 (或可透過 Peewee ORM 進行) \n 利用 AI 擷取 Wikipedia database 執行電腦輔助命題與自動評量 \n \n 執行步驟: \n \n 利用  https://github.com/pgsql-tw/portable-pgsql  啟動資料庫系統. \n 利用 Python Flask 讀取 TCExam PostgreSQL 資料庫資料. \n 利用 Python Flask 改寫部分 TCExam 模組. \n \n 參考資料: \n tcexam_12_eng.pdf \n Quality_features_of_TCExam.pdf \n https://mde.tw/blog/about-tcexam.html', 'tags': '', 'url': 'pjexam.html'}, {'title': 'pyslvs', 'text': '平面摺疊機構應用研究 \n https://github.com/KmolYuan/Pyslvs-UI \n 摺疊自行車研究: \n https://www.foldingcyclist.com/folding-bike-history.html \n Brompton 摺疊專利  ( 其他相關專利 ) \n 1896_folding_bike_US569354.pdf \n References: \n TenFold Engineering  ( video ) \n Häfele "LeMans" Blind Corner Organizer \n An overview on the applications of mechanisms in architecture. Part I: bar structures \n https://nolte-nc-kurventechnik.homepage.t-online.de/   \n Optimal Synthesis of Four-Bar Linkage Path Generation through Evolutionary Computation with a Novel Constraint Handling Technique \n FOUR-BAR LINKAGE SYNTHESIS FOR A COMBINATION OF MOTION AND PATH-POINT GENERATION', 'tags': '', 'url': 'pyslvs.html'}, {'title': 'pjfem', 'text': 'FEM 有限元素套件編譯與應用研究 \n 專題動機: \n Ansys 、 Comsol 、 Abaqus  與  Simcenter Nastran  都是商用 FEM CAE 套件, 也都可以用來執行最佳化機械零組件設計, 但若能從簡單的 1D、2D 乃至 3D 基本的 FEM 數值分析原理的推導, 以及相關開源套件的原始碼編譯及應用研究做起, 應該更有助於更深入使用商用 FEM CAE 套件的各種功能與延伸應用. \n 本專題擬利用簡單的機械零組件 FEM 分析, 比較 Range3、NGSolve 與商用 FEM CAE 套件的分析結果進行比較, 設法了解網格選擇、軟體設定與數值分析流程對分析結果所造成的影響. \n 專題執行步驟: \n \n FEM 理論推導. \n 開源 FEM 套件原始碼分析. \n 開源 FEM 套件編譯. \n 相同案例在不同套件分析結果比較. \n \n https://github.com/Range-Software/range3 \n https://ngsolve.org/ \n References: \n https://github.com/mdecycu/4072pj2 \n The Mathematical Theory of Finite Element Methods  (2002) \n Finite Element Methods and Their Application s (2005) \n Structural Analysis with the Finite Element Method - Linear Statics  (2009) \n The Finite Element Method - Theory, Implementation, and Applications  (2013)', 'tags': '', 'url': 'pjfem.html'}, {'title': 'pjblender', 'text': 'https://www.blender.org/  建立模型, 轉入 Gazebo 或 CoppeliaSim 執行機電模擬. \n 3D 零件轉檔研究 \n CAD Sketcher 研究 \n 平面機構自動組立 \n STL 零組件自動分割 \n stl_splitter.7z \n References: \n Blender Manual:  https://docs.blender.org/manual/en/latest/ \n https://hlorus.github.io/CAD_Sketcher/   \n https://github.com/hlorus/CAD_Sketcher \xa0', 'tags': '', 'url': 'pjblender.html'}, {'title': 'OpenTextbooks', 'text': '在下列開放課程使用授權範圍內, 利用網際內容管理架構分門別類進行整理與機電資產品開發有關的協同產品設計網站. \n https://open.umn.edu/opentextbooks/subjects/engineering \n', 'tags': '', 'url': 'OpenTextbooks.html'}]};