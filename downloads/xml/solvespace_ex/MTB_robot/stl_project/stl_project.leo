<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20220502144333.1"><vh>@settings</vh>
<v t="leo.20220502144333.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20220502144333.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20220502161804.1"><vh>專案說明</vh></v>
<v t="leo.20220502160945.1"><vh>importer</vh></v>
<v t="leo.20220502161105.1"><vh>pymesh</vh>
<v t="leo.20220502161105.2"><vh>@path ./</vh>
<v t="leo.20220502161105.3"><vh>@clean setup.py</vh></v>
<v t="leo.20220502161105.4"><vh>@path example</vh>
<v t="leo.20220502161105.5"><vh>@clean env.py</vh></v>
<v t="leo.20220502161105.6"><vh>@clean sample.py</vh>
<v t="leo.20220502161105.7"><vh>main</vh></v>
</v>
</v>
<v t="leo.20220502161105.9"><vh>@path pymesh</vh>
<v t="leo.20220502161105.10"><vh>@clean base.py</vh>
<v t="leo.20220502161105.11"><vh>class BaseMesh</vh>
<v t="leo.20220502161105.12"><vh>BaseMesh.__init__</vh></v>
<v t="leo.20220502161105.13"><vh>BaseMesh.set_initial_values</vh></v>
<v t="leo.20220502161105.14"><vh>BaseMesh.rotate_x</vh></v>
<v t="leo.20220502161105.15"><vh>BaseMesh.rotate_y</vh></v>
<v t="leo.20220502161105.16"><vh>BaseMesh.rotate_z</vh></v>
<v t="leo.20220502161105.17"><vh>BaseMesh.translate_x</vh></v>
<v t="leo.20220502161105.18"><vh>BaseMesh.translate_y</vh></v>
<v t="leo.20220502161105.19"><vh>BaseMesh.translate_z</vh></v>
<v t="leo.20220502161105.20"><vh>BaseMesh.scale</vh></v>
<v t="leo.20220502161105.21"><vh>BaseMesh.join</vh></v>
<v t="leo.20220502161105.22"><vh>BaseMesh.update_normals</vh></v>
<v t="leo.20220502161105.23"><vh>BaseMesh.get_volume</vh></v>
<v t="leo.20220502161105.24"><vh>BaseMesh.__calc_signed_volume</vh></v>
<v t="leo.20220502161105.25"><vh>BaseMesh.Save functions</vh></v>
<v t="leo.20220502161105.26"><vh>BaseMesh.save_stl</vh></v>
<v t="leo.20220502161105.27"><vh>BaseMesh.__save_stl_binary</vh></v>
<v t="leo.20220502161105.28"><vh>BaseMesh.__save_stl_ascii</vh></v>
<v t="leo.20220502161105.29"><vh>BaseMesh.save_obj</vh></v>
</v>
</v>
<v t="leo.20220502161105.30"><vh>@clean obj.py</vh>
<v t="leo.20220502161105.31"><vh>class Obj</vh>
<v t="leo.20220502161105.32"><vh>Obj.__init__</vh></v>
<v t="leo.20220502161105.33"><vh>Obj.__load</vh></v>
<v t="leo.20220502161105.34"><vh>Obj.__read</vh></v>
</v>
</v>
<v t="leo.20220502161105.35"><vh>@clean stl.py</vh>
<v t="leo.20220502161105.36"><vh>class Stl</vh>
<v t="leo.20220502161105.37"><vh>Stl.__init__</vh></v>
<v t="leo.20220502161105.38"><vh>Stl.__load</vh></v>
<v t="leo.20220502161105.39"><vh>Stl.__load_binary</vh></v>
<v t="leo.20220502161105.40"><vh>Stl.__load_ascii</vh></v>
<v t="leo.20220502161105.41"><vh>Stl.__ascii_reader</vh></v>
</v>
</v>
<v t="leo.20220502161105.42"><vh>@clean utils.py</vh>
<v t="leo.20220502161105.43"><vh>class Validator</vh></v>
</v>
<v t="leo.20220502161105.44"><vh>@clean __init__.py</vh></v>
</v>
<v t="leo.20220502161105.45"><vh>@path tests</vh>
<v t="leo.20220502161105.46"><vh>@clean test_obj.py</vh>
<v t="leo.20220502161105.47"><vh>class SimpleTest</vh>
<v t="leo.20220502161105.48"><vh>SimpleTest.setUp</vh></v>
<v t="leo.20220502161105.49"><vh>SimpleTest.tearDown</vh></v>
<v t="leo.20220502161105.50"><vh>SimpleTest.test_sample</vh></v>
</v>
</v>
<v t="leo.20220502161105.51"><vh>@clean test_stl.py</vh>
<v t="leo.20220502161105.52"><vh>class SimpleTest</vh>
<v t="leo.20220502161105.53"><vh>SimpleTest.setUp</vh></v>
<v t="leo.20220502161105.54"><vh>SimpleTest.tearDown</vh></v>
<v t="leo.20220502161105.55"><vh>SimpleTest.test_sample</vh></v>
</v>
</v>
<v t="leo.20220502161105.56"><vh>@clean __init__.py</vh></v>
</v>
</v>
</v>
<v t="leo.20220502224846.1"><vh>STL-Volume-Model-Calculator</vh>
<v t="leo.20220502224846.2"><vh>@path ./</vh>
<v t="leo.20220502224846.3"><vh>@clean mesure_volume.py</vh>
<v t="leo.20220502224846.4"><vh>class STLUtils</vh>
<v t="leo.20220502224846.5"><vh>STLUtils.resetVariables</vh></v>
<v t="leo.20220502224846.6"><vh>STLUtils.signedVolumeOfTriangle</vh></v>
<v t="leo.20220502224846.7"><vh>STLUtils.unpack</vh></v>
<v t="leo.20220502224846.8"><vh>STLUtils.read_triangle</vh></v>
<v t="leo.20220502224846.9"><vh>STLUtils.read_length</vh></v>
<v t="leo.20220502224846.10"><vh>STLUtils.read_header</vh></v>
<v t="leo.20220502224846.11"><vh>STLUtils.cm3_To_inch3Transform</vh></v>
<v t="leo.20220502224846.12"><vh>STLUtils.calculateMassCM3</vh></v>
<v t="leo.20220502224846.13"><vh>STLUtils.calculateVolume</vh></v>
</v>
</v>
</v>
</v>
<v t="leo.20220502234818.1"><vh>pySTL</vh>
<v t="leo.20220502234818.2"><vh>@path ./</vh>
<v t="leo.20220502234818.3"><vh>@clean editSTL.py</vh></v>
<v t="leo.20220502234818.4"><vh>@clean moveToCentroid.py</vh></v>
<v t="leo.20220502234818.5"><vh>@clean pySTL.py</vh>
<v t="leo.20220502234818.6"><vh>rotationAboutX</vh></v>
<v t="leo.20220502234818.7"><vh>rotationAboutY</vh></v>
<v t="leo.20220502234818.8"><vh>rotationAboutZ</vh></v>
<v t="leo.20220502234818.9"><vh>class triangle</vh>
<v t="leo.20220502234818.10"><vh>triangle.__init__</vh></v>
<v t="leo.20220502234818.11"><vh>triangle.calculate_normal</vh></v>
</v>
<v t="leo.20220502234818.12"><vh>class STLmodel</vh>
<v t="leo.20220502234818.13"><vh>STLmodel.__init__</vh></v>
<v t="leo.20220502234818.14"><vh>STLmodel.get_triangles</vh></v>
<v t="leo.20220502234818.15"><vh>STLmodel.get_centroid</vh></v>
<v t="leo.20220502234818.16"><vh>STLmodel.get_volume</vh></v>
<v t="leo.20220502234818.17"><vh>STLmodel.calculateCentroid</vh></v>
<v t="leo.20220502234818.18"><vh>STLmodel.load_stl</vh></v>
<v t="leo.20220502234818.19"><vh>STLmodel.load_text_stl</vh></v>
<v t="leo.20220502234818.20"><vh>STLmodel.load_binary_stl</vh></v>
<v t="leo.20220502234818.21"><vh>STLmodel.write_text_stl</vh></v>
<v t="leo.20220502234818.22"><vh>STLmodel.translate</vh></v>
<v t="leo.20220502234818.23"><vh>STLmodel.rotate</vh></v>
<v t="leo.20220502234818.24"><vh>STLmodel.scale</vh></v>
</v>
</v>
<v t="leo.20220502234818.25"><vh>@clean sample.py</vh>
<v t="leo.20220502234818.26"><vh>leoprint</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20220502144333.1"></t>
<t tx="leo.20220502144333.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20220502144333.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20220502160945.1">'''Recursively import all python files in a directory and clean the result.'''
 
c.recursiveImport(
    dir_ = r'./pySTL',
    kind = '@clean', 
    safe_at_file = False,
    theTypes =  ['.py']
)</t>
<t tx="leo.20220502161105.1"></t>
<t tx="leo.20220502161105.10">@path ./pymesh/pymesh/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

from __future__ import absolute_import, print_function
import datetime
import math
import numpy
import os
import struct
from . import __title__
from . import __version__
from . import __url__

MODE_STL_AUTO = 0
MODE_STL_ASCII = 1
MODE_STL_BINARY = 2


@others
</t>
<t tx="leo.20220502161105.11">class BaseMesh(object):

    stl_dtype = numpy.dtype([
        ('normals', numpy.float32, (3, )),
        ('vectors', numpy.float32, (3, 3)),
        ('attr', numpy.uint16, (1, )),
    ])

    @others
</t>
<t tx="leo.20220502161105.12">def __init__(self):
    self.data = None
    self.normals = []
    self.vectors = []
    self.attr = []
    self.mode = MODE_STL_BINARY

</t>
<t tx="leo.20220502161105.13">def set_initial_values(self):
    """Set initial values form existing self.data value
    :return: None
    """
    self.normals = self.data['normals']
    self.vectors = numpy.ones((
        self.data['vectors'].shape[0],
        self.data['vectors'].shape[1],
        self.data['vectors'].shape[2] + 1
    ))
    self.vectors[:, :, :-1] = self.data['vectors']
    self.attr = self.data['attr']
    return

</t>
<t tx="leo.20220502161105.14">def rotate_x(self, deg):
    """Rotate mesh around x-axis

    :param float deg: Rotation angle (degree)
    :return:
    """
    rad = math.radians(deg)
    mat = numpy.array([
        [1, 0, 0, 0],
        [0, math.cos(rad), math.sin(rad), 0],
        [0, -math.sin(rad), math.cos(rad), 0],
        [0, 0, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.15">def rotate_y(self, deg):
    """Rotate mesh around y-axis

    :param float deg: Rotation angle (degree)
    """
    rad = math.radians(deg)
    mat = numpy.array([
        [math.cos(rad), 0, -math.sin(rad), 0],
        [0, 1, 0, 0],
        [math.sin(rad), 0, math.cos(rad), 0],
        [0, 0, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.16">def rotate_z(self, deg):
    """Rotate mesh around z-axis

    :param float deg: Rotation angle (degree)
    """
    rad = math.radians(deg)
    mat = numpy.array([
        [math.cos(rad), math.sin(rad), 0, 0],
        [-math.sin(rad), math.cos(rad), 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.17">def translate_x(self, d):
    """Translate mesh for x-direction

    :param float d: Amount to translate
    """
    mat = numpy.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [d, 0, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.18">def translate_y(self, d):
    """Translate mesh for y-direction

    :param float d: Amount to translate
    """
    mat = numpy.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, d, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.19">def translate_z(self, d):
    """Translate mesh for z-direction

    :param float d: Amount to translate
    """
    mat = numpy.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, d, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.2"></t>
<t tx="leo.20220502161105.20">def scale(self, sx, sy, sz):
    """Scale mesh

    :param float sx: Amount to scale for x-direction
    :param float sy: Amount to scale for y-direction
    :param float sz: Amount to scale for z-direction
    """
    mat = numpy.array([
        [sx, 0, 0, 0],
        [0, sy, 0, 0],
        [0, 0, sz, 0],
        [0, 0, 0, 1]
    ])
    self.vectors = self.vectors.dot(mat)
    return self

</t>
<t tx="leo.20220502161105.21">def join(self, another):
    """

    :param m: BaseMesh
    :return:
    """
    if another is None:
        raise AttributeError("another BaseMesh instance is required")

    if not isinstance(another, BaseMesh):
        raise TypeError("anther must be an instance of BaseMesh")

    self.data = numpy.append(self.data, another.data)
    self.normals = numpy.append(self.normals, another.normals, axis=0)
    self.vectors = numpy.append(self.vectors, another.vectors, axis=0)
    self.attr = numpy.append(self.attr, another.attr, axis=0)
    return self

</t>
<t tx="leo.20220502161105.22">def update_normals(self):
    v0 = self.vectors[:, 0, :3]
    v1 = self.vectors[:, 1, :3]
    v2 = self.vectors[:, 2, :3]
    _normals = numpy.cross(v1 - v0, v2 - v0)

    for i in range(len(_normals)):
        norm = numpy.linalg.norm(_normals[i])
        if norm != 0:
            _normals[i] /= numpy.linalg.norm(_normals[i])

    self.normals[:] = _normals
    return self

</t>
<t tx="leo.20220502161105.23">#####################################################################
# Analyze functions
#
def get_volume(self):
    total_volume = 0
    for triangle in self.vectors:
        total_volume += BaseMesh.__calc_signed_volume(triangle)
    return total_volume

</t>
<t tx="leo.20220502161105.24">@staticmethod
def __calc_signed_volume(triangle):
    """ Calculate signed volume of given triangle
    :param list of list triangle:
    :rtype float
    """
    v321 = triangle[2][0] * triangle[1][1] * triangle[0][2]
    v231 = triangle[1][0] * triangle[2][1] * triangle[0][2]
    v312 = triangle[2][0] * triangle[0][1] * triangle[1][2]
    v132 = triangle[0][0] * triangle[2][1] * triangle[1][2]
    v213 = triangle[1][0] * triangle[0][1] * triangle[2][2]
    v123 = triangle[0][0] * triangle[1][1] * triangle[2][2]

    signed_volume = (-v321 + v231 + v312 - v132 - v213 + v123) / 6.0
    return signed_volume

</t>
<t tx="leo.20220502161105.25">#####################################################################
# Save functions
#

</t>
<t tx="leo.20220502161105.26"># STL
def save_stl(self, path, mode=MODE_STL_AUTO, update_normals=True):
    """Save data with stl format
    :param str path:
    :param int mode:
    :param bool update_normals:
    """
    if update_normals:
        self.update_normals()

    filename = os.path.split(path)[-1]

    if mode is MODE_STL_AUTO:
        if self.mode == MODE_STL_BINARY:
            save_func = self.__save_stl_binary

        elif self.mode == MODE_STL_ASCII:
            save_func = self.__save_stl_ascii

        else:
            raise ValueError("Mode %r is invalid" % mode)

    elif mode is MODE_STL_BINARY:
        save_func = self.__save_stl_binary

    else:
        raise ValueError("Mode %r is invalid" % mode)

    with open(path, 'wb') as fh:
        save_func(fh, filename)

</t>
<t tx="leo.20220502161105.27">def __save_stl_binary(self, fh, name):
    fh.write(("%s (%s) %s %s" % (
        "{}".format(__title__),
        "{}".format(__version__),
        datetime.datetime.now(),
        name
    ))[:80].ljust(80, ' '))

    bin_data = numpy.zeros(self.data.size, BaseMesh.stl_dtype)
    bin_data['normals'] = self.normals[:]
    bin_data['vectors'] = self.vectors[:, :, :3]
    bin_data['attr'] = self.attr
    fh.write(struct.pack('i', bin_data.size))
    bin_data.tofile(fh)

</t>
<t tx="leo.20220502161105.28">def __save_stl_ascii(self, fh, name):
    print("solid {}".format(name), file=fh)
    for i in range(len(self.vectors)):
        print("facet normal %f %f %f" % tuple(self.normals[i][:3]), file=fh)
        print("  outer loop", file=fh)
        print("    vertex %f %f %f" % tuple(self.vectors[i][0][:3]), file=fh)
        print("    vertex %f %f %f" % tuple(self.vectors[i][1][:3]), file=fh)
        print("    vertex %f %f %f" % tuple(self.vectors[i][2][:3]), file=fh)
        print("  endloop", file=fh)
        print("endfacet", file=fh)
    print("endsolid {}".format(name), file=fh)

</t>
<t tx="leo.20220502161105.29"># OBJ
def save_obj(self, path, update_normals=True):
    """Save data with OBJ format
    :param stl path:
    :param bool update_normals:
    """
    if update_normals:
        self.update_normals()

    # Create triangle_list
    vectors_key_list = []
    vectors_list = []
    normals_key_list = []
    normals_list = []
    triangle_list = []
    for i, vector in enumerate(self.vectors):
        one_triangle = []
        for j in range(3):
            v_key = ",".join(map(str, self.vectors[i][j][:3]))
            if v_key in vectors_key_list:
                v_index = vectors_key_list.index(v_key)
            else:
                v_index = len(vectors_key_list)
                vectors_key_list.append(v_key)
                vectors_list.append(self.vectors[i][j][:3])
            one_triangle.append(v_index + 1)

        n_key = ",".join(map(str, self.normals[i][:3]))
        if n_key in normals_key_list:
            n_index = normals_key_list.index(n_key)
        else:
            n_index = len(normals_key_list)
            normals_key_list.append(n_key)
            normals_list.append(self.normals[i][:3])

        # print(normals_list)
        triangle_list.append((one_triangle, n_index + 1))

    with open(path, "wb") as fh:
        print("# {} {}".format(__title__, __version__), file=fh)
        print("# {}".format(datetime.datetime.now()), file=fh)
        print("# {}".format(__url__), file=fh)
        print("", file=fh)
        for v in vectors_list:
            print("v {} {} {}".format(v[0], v[1], v[2]), file=fh)
        for vn in normals_list:
            print("vn {} {} {}".format(vn[0], vn[1], vn[2]), file=fh)
        for t in triangle_list:
            faces = t[0]
            normal = t[1]

            print("f {}//{} {}//{} {}//{}".format(
                faces[0], normal,
                faces[1], normal,
                faces[2], normal,
            ), file=fh)

</t>
<t tx="leo.20220502161105.3">@path ./pymesh/
@language python
@tabwidth -4
from setuptools import setup
import pymesh

setup(
    name=pymesh.__title__,
    packages=[pymesh.__title__],
    version=pymesh.__version__,
    author=pymesh.__author__,
    author_email="taxpon@gmail.com",
    description="Library for manipulating (Translate, Rotate and Scale) 3D data using numpy.",
    url=pymesh.__url__,
    license=pymesh.__license__,
    classifiers=[
        'License :: OSI Approved :: MIT License',
        "Programming Language :: Python",

    ],
    install_requires=[
        'numpy'
    ],
)
</t>
<t tx="leo.20220502161105.30">@path ./pymesh/pymesh/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

from __future__ import absolute_import, print_function
import numpy
from .base import BaseMesh


@others
</t>
<t tx="leo.20220502161105.31">class Obj(BaseMesh):

    obj_dtype = numpy.dtype([
        ('normals', numpy.float32, (3, )),
        ('vectors', numpy.float32, (3, 3)),
        ('attr', numpy.uint16, (1, )),
    ])

    @others
</t>
<t tx="leo.20220502161105.32">def __init__(self, path=None):
    """Create an instance of Obj (Wavefront)
    :param str path:
    """
    super(Obj, self).__init__()

    if path is None:
        # Create EMPTY data
        self.name = "empty"
        self.data = numpy.zeros(0, dtype=Obj.obj_dtype)

    else:
        # Create data from file
        with open(path, "rb") as fh:
            data = Obj.__load(fh)
        self.name = path
        self.data = data

    super(Obj, self).set_initial_values()
    return

</t>
<t tx="leo.20220502161105.33">@staticmethod
def __load(fh):
    return numpy.fromiter(Obj.__read(fh), dtype=Obj.obj_dtype)

</t>
<t tx="leo.20220502161105.34">@staticmethod
def __read(fh):
    vertices_list = []
    triangles_list = []

    try:
        while True:
            line = fh.readline()
            if line == "":
                break

            elif line.lstrip().startswith("vn"):
                continue

            elif line.lstrip().startswith("v"):
                vertices = line.replace("\n", "").split(" ")[1:]
                vertices_list.append(map(float, vertices))

            elif line.lstrip().startswith("f"):
                t_index_list = []
                for t in line.replace("\n", "").split(" ")[1:]:
                    t_index = t.split("/")[0]
                    t_index_list.append(int(t_index) - 1)
                triangles_list.append(t_index_list)

            else:
                continue

        for t in triangles_list:
            yield ([0, 0, 0], (vertices_list[t[0]], vertices_list[t[1]], vertices_list[t[2]]), 0)

    except:
        raise RuntimeError("Failed to load OBJ file.")
</t>
<t tx="leo.20220502161105.35">@path ./pymesh/pymesh/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

from __future__ import absolute_import, print_function
import numpy
import os
import struct
from .base import BaseMesh


@others
</t>
<t tx="leo.20220502161105.36">class Stl(BaseMesh):

    MODE_AUTO = 0
    MODE_ASCII = 1
    MODE_BINARY = 2

    HEADER_SIZE = 80
    COUNT_SIZE = 4
    MAX_COUNT = 1e6
    BUFFER_SIZE = 4096

    stl_dtype = numpy.dtype([
        ('normals', numpy.float32, (3, )),
        ('vectors', numpy.float32, (3, 3)),
        ('attr', numpy.uint16, (1, )),
    ])

    @others
</t>
<t tx="leo.20220502161105.37">def __init__(self, path=None, mode_policy=MODE_AUTO):
    """Craete a instance of Stl.
    :param str path: The file path to open
    :param int mode_policy: The mode to open, default is :py:data:`AUTOMATIC`.
    """
    super(Stl, self).__init__()

    if path is None:
        # Create EMPTY data
        self.name = "empty"
        self.data = numpy.zeros(0, dtype=Stl.stl_dtype)
        self.mode = Stl.MODE_BINARY

    else:
        # Create data from file
        with open(path, "rb") as fh:
            name, data, mode = Stl.__load(fh, mode=mode_policy)
        self.name = name
        self.data = data
        self.mode = mode

    super(Stl, self).set_initial_values()
    return

</t>
<t tx="leo.20220502161105.38">@staticmethod
def __load(fh, mode=MODE_AUTO):
    """Load Mesh from STL file

    :param FileIO fh: The file handle to open
    :param int mode: The mode to open, default is :py:data:`AUTOMATIC`.
    :return:
    """
    header = fh.read(Stl.HEADER_SIZE).lower()
    name = ""
    data = None
    if not header.strip():
        return

    if mode in (Stl.MODE_AUTO, Stl.MODE_ASCII) and header.startswith(b'solid'):
        try:
            name = header.split('\n', 1)[0][:5].strip()
            data = Stl.__load_ascii(fh, header)
            mode = Stl.MODE_ASCII

        except:
            pass

    else:
        data = Stl.__load_binary(fh)
        mode = Stl.MODE_BINARY

    return name, data, mode

</t>
<t tx="leo.20220502161105.39">@staticmethod
def __load_binary(fh):
    # Read the triangle count
    count, = struct.unpack("i", fh.read(Stl.COUNT_SIZE))
    assert count &lt; Stl.MAX_COUNT, \
        'File too large, got {} triangles which exceeds the maximum of {}' .format(
            count, Stl.MAX_COUNT
        )
    return numpy.fromfile(fh, Stl.stl_dtype, count=count)

</t>
<t tx="leo.20220502161105.4"></t>
<t tx="leo.20220502161105.40">@staticmethod
def __load_ascii(fh, header):
    return numpy.fromiter(Stl.__ascii_reader(fh, header), dtype=Stl.stl_dtype)

</t>
<t tx="leo.20220502161105.41">@staticmethod
def __ascii_reader(fh, header):
    """
    :param fh:
    :param header:
    :return:
    """

    lines = header.split('\n')
    recoverable = [True]

    def get(prefix=''):
        if lines:
            line = lines.pop(0)
        else:
            raise RuntimeError(recoverable[0], 'Unable to find more lines')

        if not lines:
            recoverable[0] = False

            # Read more lines and make sure we prepend any old data
            lines[:] = fh.read(Stl.BUFFER_SIZE).split('\n')
            line += lines.pop(0)
        line = line.lower().strip()
        if prefix:
            if line.startswith(prefix):
                values = line.replace(prefix, '', 1).strip().split()
            elif line.startswith('endsolid'):
                raise StopIteration()
            else:
                raise RuntimeError(recoverable[0],
                                   '%r should start with %r' % (line,
                                                                prefix))

            if len(values) == 3:
                vertex = [float(v) for v in values]
                return vertex
            else:  # pragma: no cover
                raise RuntimeError(recoverable[0],
                                   'Incorrect value %r' % line)
        else:
            return line

    line = get()
    if not line.startswith('solid ') and line.startswith('solid'):
        print("Error")

    if not lines:
        raise RuntimeError(recoverable[0],
                           'No lines found, impossible to read')

    while True:
        # Read from the header lines first, until that point we can recover
        # and go to the binary option. After that we cannot due to
        # unseekable files such as sys.stdin
        #
        # Numpy doesn't support any non-file types so wrapping with a
        # buffer and/or StringIO does not work.
        try:
            normals = get('facet normal')
            assert get() == 'outer loop'
            v0 = get('vertex')
            v1 = get('vertex')
            v2 = get('vertex')
            assert get() == 'endloop'
            assert get() == 'endfacet'
            attrs = 0
            yield (normals, (v0, v1, v2), attrs)
        except AssertionError as e:
            raise RuntimeError(recoverable[0], e)
        except StopIteration:
            if any(lines):
                # Seek back to where the next solid should begin
                fh.seek(-len('\n'.join(lines)), os.SEEK_CUR)
            raise

</t>
<t tx="leo.20220502161105.42">@path ./pymesh/pymesh/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-


@others
</t>
<t tx="leo.20220502161105.43">class Validator(object):

    @staticmethod
    def is_string(value):
        if value is None  or not isinstance(value, (str, unicode)):
            return False
        return True
</t>
<t tx="leo.20220502161105.44">@path ./pymesh/pymesh/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

#
# PyMesh
#

__title__ = "pymesh"
__versioninfo__ = (1, 0, 2)
__version__ = ".".join(map(str, __versioninfo__))
__author__ = "Takuro Wada"
__license__ = "MIT"
__copyright__ = "Copyright 2015 Takuro Wada"
__url__ = "https://github.com/taxpon/pymesh"
</t>
<t tx="leo.20220502161105.45"></t>
<t tx="leo.20220502161105.46">@path ./pymesh/tests/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

import unittest
from pymesh import stl


@others
if __name__ == "__main__":
    unittest.main()
</t>
<t tx="leo.20220502161105.47">class SimpleTest(unittest.TestCase):
    @others
</t>
<t tx="leo.20220502161105.48">def setUp(self):
    pass

</t>
<t tx="leo.20220502161105.49">def tearDown(self):
    pass

</t>
<t tx="leo.20220502161105.5">@path ./pymesh/example/
@language python
@tabwidth -4
import sys
import os

this = os.path.normpath(os.path.abspath(os.path.dirname(__file__)))
sys.path.insert(0, "/".join(this.split("/")[:-1]))
# sys.path.append("/".join(this.split("/")[:-1]))
</t>
<t tx="leo.20220502161105.50">def test_sample(self):
    pass


</t>
<t tx="leo.20220502161105.51">@path ./pymesh/tests/
@language python
@tabwidth -4
# -*- coding: utf-8 -*-

import unittest
from pymesh import stl


@others
if __name__ == "__main__":
    unittest.main()
</t>
<t tx="leo.20220502161105.52">class SimpleTest(unittest.TestCase):
    @others
</t>
<t tx="leo.20220502161105.53">def setUp(self):
    pass

</t>
<t tx="leo.20220502161105.54">def tearDown(self):
    pass

</t>
<t tx="leo.20220502161105.55">def test_sample(self):
    pass


</t>
<t tx="leo.20220502161105.56">@path ./pymesh/tests/
@language python
@tabwidth -4
</t>
<t tx="leo.20220502161105.6">@path ./pymesh/example/
@language python
@tabwidth -4
import env
from pymesh import stl
from pymesh import obj


@others
if __name__ == '__main__':
    main()
</t>
<t tx="leo.20220502161105.7">def main():
    print(stl.__file__)
    empty = stl.Stl()
    e2 = obj.Obj()
    m = stl.Stl('sample.stl')
    m2 = obj.Obj('sample.obj')
    print(m.get_volume())
    m.scale(1, 2, 1)
    m.rotate_x(90)
    m.rotate_y(30)
    m.translate_x(2)
    m.join(m2)
    empty.join(m2)
    empty.join(e2)
    m.save_stl("sample_out.stl", update_normals=True)
    empty.save_stl("empty.stl")


</t>
<t tx="leo.20220502161105.9"></t>
<t tx="leo.20220502161804.1"></t>
<t tx="leo.20220502224846.1"></t>
<t tx="leo.20220502224846.10">def read_header(self):
    self.f.seek(self.f.tell() + 80)

</t>
<t tx="leo.20220502224846.11">def cm3_To_inch3Transform(self, v):
    return v * 0.0610237441

</t>
<t tx="leo.20220502224846.12">def calculateMassCM3(self, totalVolume):
    totalMass = 0
    if material in {1, 'ABS'}:
        totalMass = (totalVolume * 1.04)
    elif material in {2, 'PLA'}:
        totalMass = (totalVolume * 1.25)
    elif material in {3, 'CFRP'}:
        totalMass = (totalVolume * 1.79)
    elif material in {4, 'Plexiglass'}:
        totalMass = (totalVolume * 1.18)
    elif material in {5, 'Alumide'}:
        totalMass = (totalVolume * 1.36)
    elif material in {6, 'Aluminum'}:
        totalMass = (totalVolume * 2.68)
    elif material in {7, 'Brass'}:
        totalMass = (totalVolume * 8.6)
    elif material in {8, 'Bronze'}:
        totalMass = (totalVolume * 9.0)
    elif material in {9, 'Copper'}:
        totalMass = (totalVolume * 9.0)
    elif material in {10, 'Gold_14K'}:
        totalMass = (totalVolume * 13.6)
    elif material in {11, 'Gold_18K'}:
        totalMass = (totalVolume * 15.6)
    elif material in {12, 'Polyamide_MJF'}:
        totalMass = (totalVolume * 1.01)
    elif material in {13, 'Polyamide_SLS'}:
        totalMass = (totalVolume * 0.95)
    elif material in {14, 'Rubber'}:
        totalMass = (totalVolume * 1.2)
    elif material in {15, 'Silver'}:
        totalMass = (totalVolume * 10.26)
    elif material in {16, 'Steel'}:
        totalMass = (totalVolume * 7.86)
    elif material in {17, 'Titanium'}:
        totalMass = (totalVolume * 4.41)
    elif material in {18, 'Resin'}:
        totalMass = (totalVolume * 1.2)
    return totalMass

</t>
<t tx="leo.20220502224846.13">def calculateVolume(self, infilename, unit):
    print(infilename)
    self.resetVariables()
    totalVolume = 0
    totalMass = 0
    try:
        self.f = open(infilename, "rb")
        self.read_header()
        l = self.read_length()
        print("total triangles:", l)
        try:
            while True:
                totalVolume += self.read_triangle()
        except Exception as e:
            print("End calculate triangles volume")
        totalVolume = (totalVolume / 1000)
        totalMass = self.calculateMassCM3(totalVolume)

        if totalMass &lt;= 0:
            print('Total mass could not be calculated')
        else:
            print('Total mass:', totalMass, 'g')

            if unit == "cm":
                print("Total volume:", totalVolume, "cm^3")
            else:
                totalVolume = self.cm3_To_inch3Transform(totalVolume)
                print("Total volume:", totalVolume, "inch^3")
    except Exception as e:
        print(e)
    return totalVolume


</t>
<t tx="leo.20220502224846.2"></t>
<t tx="leo.20220502224846.3">@path ./STL-Volume-Model-Calculator/
@language python
@tabwidth -4
#! /usr/bin/env python3
'''
VOLUME CALCULATION STL binary MODELS
Author: Mar Canet (mar.canet@gmail.com) - september 2012
Description: useful to calculate cost in a 3D printing ABS or PLA usage

Modified by:
Author: Saijin_Naib (Synper311@aol.com)
Date: 2016-06-26 03:55:13.879187
Description: Added input call for print material (ABS or PLA), added print of object mass, made Python3 compatible, changed tabs for spaces
Material Mass Source: https://www.toybuilderlabs.com/blogs/news/13053117-filament-volume-and-length
'''

import struct
import sys
print('Choose desired print material of STL file below:')
material = input('1 = ABS or 2 = PLA or 3 = 3k CFRP or 4 = Plexiglass : ')


@others
if __name__ == '__main__':
    if len(sys.argv) == 1:
        print("Define model to calculate volume ej: python measure_volume.py torus.stl")
    else:
        mySTLUtils = STLUtils()
        if(len(sys.argv) &gt; 2 and sys.argv[2] == "inch"):
            mySTLUtils.calculateVolume(sys.argv[1], "inch")
        else:
            mySTLUtils.calculateVolume(sys.argv[1], "cm")
</t>
<t tx="leo.20220502224846.4">class STLUtils:
    @others
</t>
<t tx="leo.20220502224846.5">def resetVariables(self):
    self.normals = []
    self.points = []
    self.triangles = []
    self.bytecount = []
    self.fb = []  # debug list

</t>
<t tx="leo.20220502224846.6"># Calculate volume for the 3D mesh using Tetrahedron volume
# based on: http://stackoverflow.com/questions/1406029/how-to-calculate-the-volume-of-a-3d-mesh-object-the-surface-of-which-is-made-up
def signedVolumeOfTriangle(self, p1, p2, p3):
    v321 = p3[0] * p2[1] * p1[2]
    v231 = p2[0] * p3[1] * p1[2]
    v312 = p3[0] * p1[1] * p2[2]
    v132 = p1[0] * p3[1] * p2[2]
    v213 = p2[0] * p1[1] * p3[2]
    v123 = p1[0] * p2[1] * p3[2]
    return (1.0 / 6.0) * (-v321 + v231 + v312 - v132 - v213 + v123)

</t>
<t tx="leo.20220502224846.7">def unpack(self, sig, l):
    s = self.f.read(l)
    self.fb.append(s)
    return struct.unpack(sig, s)

</t>
<t tx="leo.20220502224846.8">def read_triangle(self):
    n = self.unpack("&lt;3f", 12)
    p1 = self.unpack("&lt;3f", 12)
    p2 = self.unpack("&lt;3f", 12)
    p3 = self.unpack("&lt;3f", 12)
    b = self.unpack("&lt;h", 2)

    self.normals.append(n)
    l = len(self.points)
    self.points.append(p1)
    self.points.append(p2)
    self.points.append(p3)
    self.triangles.append((l, l + 1, l + 2))
    self.bytecount.append(b[0])
    return self.signedVolumeOfTriangle(p1, p2, p3)

</t>
<t tx="leo.20220502224846.9">def read_length(self):
    length = struct.unpack("@i", self.f.read(4))
    return length[0]

</t>
<t tx="leo.20220502234818.1"></t>
<t tx="leo.20220502234818.10">def __init__(self,p1,p2,p3,n=None):
    #3 points of the triangle
    self.vertices=np.array(p1),np.array(p2),np.array(p3)
  
    #triangles normal
    if n != None:
        self.normal= n
    else:
        self.normal = np.array(self.calculate_normal(self.vertices[0],self.vertices[1],self.vertices[2]))

</t>
<t tx="leo.20220502234818.11">def calculate_normal(self,p1,p2,p3):
    p12 = p2-p1
    p23 = p3-p2
    #calculate the cross product
    return np.cross(p12,p23)    




</t>
<t tx="leo.20220502234818.12">class STLmodel:

    @others
</t>
<t tx="leo.20220502234818.13">def __init__(self,filename):
    self.filename = filename
    self.triangles=[]
    self.centroid = None
    self.volume = None
    self.load_stl()
  
</t>
<t tx="leo.20220502234818.14">#return the faces of the triangles
def get_triangles(self):
    if self.triangles:
        for face in self.triangles:
            yield face

</t>
<t tx="leo.20220502234818.15">def get_centroid(self):
    # Yen fix this
    #if  self.centroid == None:
    if self.centroid is None:
        self.calculateCentroid()
    return self.centroid

</t>
<t tx="leo.20220502234818.16">def get_volume(self):
    if self.volume is None:
        self.calculateCentroid()
    return self.volume
        

</t>
<t tx="leo.20220502234818.17">def calculateCentroid(self):
    totalVolume=0
    currentVolume=0
    xCenter = 0
    yCenter = 0
    zCenter = 0
    #Each triangle forms a tetrahedron with the origin.  
    #Calculate the size inside the volume of the model. Then add the 
    #contributions to the centroid of the 3-d shape based on those volumes.
    for tri in self.triangles:
        p1 = tri.vertices[0]
        p2 = tri.vertices[1]
        p3 = tri.vertices[2]
        currentVolume = ((p1[0]*p2[1]*p3[2] - p1[0]*p3[1]*p2[2] - p2[0]*p1[1]*p3[2] +
                p2[0]*p3[1]*p1[2] + p3[0]*p1[1]*p2[2] - p3[0]*p2[1]*p1[2])/6)
        totalVolume += currentVolume
        xCenter += ((p1[0] + p2[0] + p3[0])/4) * currentVolume
        yCenter += ((p1[1] + p2[1] + p3[1])/4) * currentVolume
        zCenter += ((p1[2] + p2[2] + p3[2])/4) * currentVolume
    
    self.volume = totalVolume
    xCentroid = xCenter/totalVolume
    yCentroid = yCenter/totalVolume
    zCentroid = zCenter/totalVolume
    self.centroid = np.array([xCentroid,yCentroid,zCentroid])



</t>
<t tx="leo.20220502234818.18">#load stl file detects if the file is a text file or binary file
def load_stl(self):
    #read start of file to determine if its a binay stl file or a ascii stl file
    if self.filename:
        fp=open(self.filename,'r')
        h=fp.read(80)
        type=h[0:5]
        fp.close()

        if type=='solid':
            self.load_text_stl()
            #Many Binary Files also start with 'solid' unfortunately. 
            #if we don't have any triangles after attempting an ascii read
            #let's try a binary read and see if that works
            if len(self.triangles) &lt; 1:
                print('ASCII load did not find any triangles.  Your binary .STL file probably starts with "solid". Trying a binary read instead')
                self.load_binary_stl()
        
        else:
            self.load_binary_stl()

    #If we don't have any triangles.  Something went wrong. 
    if len(self.triangles) &lt; 1:
        print("No triangles found for file.  This may not be a .stl file.")
       

</t>
<t tx="leo.20220502234818.19">#read text stl match keywords to grab the points to build the model
def load_text_stl(self):
    print("Attempting to read ASCII STL: "+str(self.filename))
    fp=open(self.filename,'r')
    for line in fp:
        words=line.split()
        if len(words)&gt;0:
            if words[0]=='solid':
                try:
                    self.name=words[1]
                except IndexError:
                    self.name="polyhedron"

            if words[0]=='facet':
                center=[0.0,0.0,0.0]
                vertices=[]
                normal=(float(words[2]),float(words[3]),float(words[4]))
              
            if words[0]=='vertex':
                vertices.append((float(words[1]),float(words[2]),float(words[3])))
              
              
            if words[0]=='endloop':
                #make sure we got the correct number of values before storing
                if len(vertices)==3:
                    self.triangles.append(triangle(vertices[0],vertices[1],vertices[2],normal))
    fp.close()

</t>
<t tx="leo.20220502234818.2"></t>
<t tx="leo.20220502234818.20">#load binary stl file check wikipedia for the binary layout of the file
#we use the struct library to read in and convert binary data into a format we can use
def load_binary_stl(self):
    print("Attempting to read binary STL: "+str(self.filename,))
    fp=open(self.filename,'rb')
    h=fp.read(80)

    l=struct.unpack('I',fp.read(4))[0]
    count=0
    while True:
        try:
            p=fp.read(12)
            if len(p)==12:
                n=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]
              
            p=fp.read(12)
            if len(p)==12:
                p1=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]

            p=fp.read(12)
            if len(p)==12:
                p2=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]

            p=fp.read(12)
            if len(p)==12:
                p3=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]

            new_tri=(n,p1,p2,p3)

            if len(new_tri)==4:
                tri=triangle(p1,p2,p3,n)
                self.triangles.append(tri)
            count+=1
            fp.read(2)

            if len(p)==0:
                break
        except EOFError:
            break
    fp.close()

</t>
<t tx="leo.20220502234818.21">def write_text_stl(self, filename):
    print("Writing STL to: " + filename)

    try:
        f = open(filename, 'w')
        try:
            f.write('solid {:s}\n'.format(self.filename))
        except AttributeError:
            f.write('solid {:s}\n'.format('polyhedron'))

        for facet in self.triangles:
            normal = facet.normal
            f.write('  facet normal {0:.6E} {1:.6E} {2:.6E}\n'.format(normal[0], normal[1], normal[2]))
            f.write('    outer loop\n')
            for point in facet.vertices:
                f.write('      vertex {0:.6E} {1:.6E} {2:.6E}\n'.format(point[0], point[1], point[2]))
            f.write('    endloop\n')
            f.write('  endfacet\n')
        
        try:
            f.write('endsolid {:s}\n'.format(self.name))
        except AttributeError:
            f.write('endsolid {:s}\n'.format('polyhedron'))

        f.close()
    except IOError:
        print("Couldn't complete write. IOError encountered.")



</t>
<t tx="leo.20220502234818.22">#Pass this a numpy 3-array to translate all the points in the .stl file. 
def translate(self, p):
    for tri in self.triangles:
        for point in tri.vertices:
            point[0] += p[0]
            point[1] += p[1]
            point[2] += p[2]
    self.volume = None
    self.centroid = None

</t>
<t tx="leo.20220502234818.23">#Pass this a numpy 2D array, not a numpy matrix a rotation object.
def rotate(self, R):
    for tri in self.triangles:
        for point in tri.vertices:
            rotatedPoint = R.dot(point)
            point[0] = rotatedPoint[0]
            point[1] = rotatedPoint[1]
            point[2] = rotatedPoint[2]

    self.centroid = None
    self.volume = None

</t>
<t tx="leo.20220502234818.24">def scale(self, scale):
    for tri in self.triangles:
        for point in tri.vertices:
            point[0] = scale*point[0]
            point[1] = scale*point[1]
            point[2] = scale*point[2]

    self.volume = None
    self.centroid = None


</t>
<t tx="leo.20220502234818.25">@path ./pySTL/
@language python
@tabwidth -4
import pySTL
from numpy import array

@others
#Load a model from a file.
model = pySTL.STLmodel('./../../link2_ascii.stl')
leoprint(model.get_volume())

#print model properties
leoprint("Volume  " + str(model.get_volume()))
c = model.get_centroid()
leoprint("Centroid " +  "X: " + str(c[0]) + " Y:" + str(c[1]) + "  Z:" + str(c[2]))

#Translate the model so that the centroid is at the origin.
model.translate(-c)
model.write_text_stl("link2_AtCentroid.stl")

#Rotate the model 90 degrees about the Y-axis
R2 = pySTL.rotationAboutY(-3.14159/2)

model.rotate(R2)

c = model.get_centroid()

leoprint("Centroid " +  "X: " + str(c[0]) + " Y:" + str(c[1]) + "  Z:" + str(c[2]))

model.write_text_stl('link2_rot_90_about_Y.stl')

#Scale the model down by 100%
scale = 0.001
model.scale(scale)

model.write_text_stl('link2_scale_down_0.001.stl')

</t>
<t tx="leo.20220502234818.26">def leoprint(x):
    try:
        print(x)
    except:
        g.es(x)

</t>
<t tx="leo.20220502234818.3">@path ./pySTL/
@language python
@tabwidth -4
#!/usr/bin/python

import pySTL
import argparse


parser = argparse.ArgumentParser(description='Process a given STL file and perform rotation, translation, and scaling on it.  Actions happen in the order given here.  Scaling, then translation, then rotation. If selected, centroid translation happens last.')

parser.add_argument('-i', '--infile', action="store", help='input STL file', required=True)

parser.add_argument('-o', '--outfile', action="store", help='output STL file including the extension.  If none is given, processing is performed in place and the input file is replaced by the edited version', default="SECRET")

parser.add_argument('-s', '--scale', action="store", help='scaling factor for output STL', type=float, default=1.0)


parser.add_argument('-t', '--translate', action="store", help='translate the STL file: provide three numeric values for x, y, and z translation  e.g. --translate 10.1 -14.2 15', nargs=3, type=float, default=[])

parser.add_argument('-r', '--rotate', action="store", help='rotate the STL file: provide 3 angles for 3-1-3 body-fixed Euler angle rotations in radians', nargs=3, type=float, default=[]) 

parser.add_argument('-c', '--centroid', action="store_true", help='move the STL file so that the origin is the centroid after performing all other operations', default=False)
parser.add_argument('-v', '--verbose', action="store_true", help='print out operations', default=False)

args = parser.parse_args()
 
if args.verbose:
    def verboseprint(*args):
        # Print each argument separately so caller doesn't need to
        # stuff everything to be printed into a single string
        for arg in args:
           print(arg)
        print()
else:   
    verboseprint = lambda *a: None      # do-nothing function



model = pySTL.STLmodel(args.infile)

if args.scale != 1:
    verboseprint("Scaling model by factor: ", args.scale)
    model.scale(args.scale)


translation = args.translate
if len(translation) == 3:
    verboseprint("Performing translation: deltaX = ", str(translation[0]), ", deltaY = ", str(translation[1]), ", deltaZ = ", str(translation[2]))
    model.translate(translation)

eulerAngles = args.rotate
if len(eulerAngles) == 3:
    verboseprint('Performing Rotation')
    R1 = pySTL.rotationAboutZ(eulerAngles[0])
    R2 = pySTL.rotationAboutX(eulerAngles[1])
    R3 = pySTL.rotationAboutZ(eulerAngles[2])
    #For body-fixed, pre-multiply.   
    R = R3.dot(R2.dot(R1))
    verboseprint("Rotation Matrix: \n", R)
    model.rotate(R)


if args.centroid:
    verboseprint("Moving model to centroid")
    c = model.get_centroid()
    model.translate(-c)
   

if args.outfile == "SECRET":
    outfile = args.infile
else:
    outfile = args.outfile

model.write_text_stl(outfile)
</t>
<t tx="leo.20220502234818.4">@path ./pySTL/
@language python
@tabwidth -4
import pySTL
from numpy import array

#Load a model from a file.
model = pySTL.STLmodel('./../../link2_ascii.stl')

#print model properties
print "Volume  " + str(model.get_volume())
c = model.get_centroid()
print "Centroid " +  "X: " + str(c[0]) + " Y:" + str(c[1]) + "  Z:" + str(c[2])


#Translate the model so that the centroid is at the origin.
model.translate(-c)

model.write_text_stl('textCenteredAtCentroid.stl')

</t>
<t tx="leo.20220502234818.5">@path ./pySTL/
@language python
@tabwidth -4
import struct
import numpy as np
from math import cos
from math import sin

@others
</t>
<t tx="leo.20220502234818.6">#3 Utility methods to calculate rotation matrices.
def rotationAboutX(phi):
    R = np.array([[1, 0, 0],[0, cos(phi), sin(phi)],[0, -sin(phi), cos(phi)]])
    return R

</t>
<t tx="leo.20220502234818.7">def rotationAboutY(phi):
    R = np.array([[cos(phi), 0, -sin(phi)],[0, 1, 0],[sin(phi), 0, cos(phi)]])
    return R

</t>
<t tx="leo.20220502234818.8">def rotationAboutZ(phi):
    R = np.array([[cos(phi), sin(phi), 0],[-sin(phi), cos(phi), 0],[0, 0, 1]])
    return R

</t>
<t tx="leo.20220502234818.9">#3d face on a model
class triangle:
    
    @others
</t>
</tnodes>
</leo_file>
